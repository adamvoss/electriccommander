#!/usr/bin/env perl
# -*-Perl-*-

# postp -
#
# This file implements a basic postprocessor for ElectricCommander.  It
# processes log files generated by build steps to extract summary
# information and diagnostic messages.  It uses a table-driven approach
# to allow new kinds of errors to be added easily.
#                                                                                                            
# The following special keyword indicates that the "cleanup" script should
# scan this file for formatting errors, even though it doesn't have one of
# the expected extensions.
# CLEANUP: CHECK
#
# Copyright (c) 2006-2010 Electric Cloud, Inc.
# All rights reserved

use strict;
use warnings;
use Getopt::Long;
use File::Basename;
use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
use File::Path;
use File::Spec;
use File::Temp;
use XML::XPath;
use ElectricCommander;
use Cwd;
use Encode::Byte;

# Connect to the ElectricCommander server,
$::gCommander = new ElectricCommander({
    abortOnError => 0,
    retry => 1,
});

# This is the version of postp.  The Makefile sed's this script to define
# version properly when building the executable.

my $version = "4.1.0.46914";
if ( !defined( $version ) ) {
    $version = 'unpackaged';
}

my $gBanner = "Electric Cloud Step Postprocessor version $version\n"
    . "Copyright (C) 2005-" . (1900 + (localtime())[5]) 
    . " Electric Cloud, Inc.\n"
    . "All rights reserved.\n";

# ------------------------------------------------------------------------
# Postprocessing is driven by "matchers" that match certain lines in the
# log and indicate what to do when matching lines are found.  Each matcher
# is a hash with the following members:
#
# id -                 Identifying name for this matcher (no spaces, please)
#                      Used to select which matchers should be applied
#                      to a given log file.
# pattern -            Matches certain lines of the log file.  In addition
#                      to matching the line, it may contain ()'s that
#                      extract various other fields, which may used
#                      in the matcher's actions.
# action -             Perl script to eval whenever a matching line is
#                      found.
# ------------------------------------------------------------------------

# The following array defines built-in matchers (--load files can be used
# to define additional matchers).  Note: the order of entries may be
# significant: by default, matchers are applied in the order they appear
# here.

@::gMatchers = (

    # compilation commands
    # g++ -pthread -g -Wall ...
    # /usr/local/tools/gcc -c -Wall ...
    # cl -DUSE_PROFILING -DUSE_LOGGING -I ...
    # cc -c -I include ...
    # x86_64-pc-linux-gnu-g++ -pthread -g  ...
    # x86_64-pc-linux-gnu-gcc -pthread -g  ...

    {
        id =>               "compileCommand",
        pattern => q{^([^ ]+/)?(cl|cc|([^\s]+-)?(gcc|g\+\+)) },
        action =>           q{incValue("compiles");},
    },

    # Java compilations from Ant
    # [javac] Compiling 581 source files to ...
    #       or
    # [javac] Compiling 1 source file to ...

    {
        id =>               "javaCompiles",
        pattern =>          q{\[javac\] Compiling (\d+) source files? to},
        action =>           q{incValue("compiles", $1);},
    },

    # make aborts a build:
    # gmake: *** [testa.o] Error 1
    # Note: could be followed by "Target not remade" lines.  If they
    # are present, include them also.

    {
        id =>               "makeAbort",
        pattern =>          q{[eg]?make(\[\d*\])?: \*\*\* \[([^]]+)\] }
                                    . q{Error (\d+)},
        action =>           q{incValue("errors"); diagnostic($2, "error", -4,
                                forwardWhile(q{make.*: Target `[^']*' not}
                                . q{ remade because of errors}));},
    },

    # gmake target not remade:
    # make[1]: Target `test' not remade because of errors.

    {
        id =>               "makeNotRemade",
        pattern =>          q{make(\[\d*\])?: Target `([^']*)' not remade }
                                    . q{because of errors},
        action =>           q{incValue("errors"); diagnostic($2, "error",
                                    -4, 0);},
    },

    # make fails to build a target because it can't find a rule:
    # make[1]: *** No rule to make target `testa.cpp`, needed by `testa.o`.

    {
        id =>               "makeNoRule",
        pattern =>          q{make(\[\d*\])?: \*\*\* No rule to make target }
                                    . q{`([^']*)', needed by},
        action =>           q{incValue("errors"); diagnostic($2, "error",
                                    0, 0); }
    },

    # gmake starting recursive sub-make:
    # make[1]: Entering directory `n:/ecloud/minidumper'

    {
        id =>               "makeEnteringModule",
        pattern =>          q{make(\[\d*\])?: Entering directory `([^']*)'},
        action =>           q{pushModule($2);},
    },

    # gmake finishing recursive sub-make:
    # make[1]: Leaving directory `n:/ecloud/minidumper'

    {
        id =>               "makeLeavingModule",
        pattern =>          q{make(\[\d*\])?: Leaving directory `([^']*)'},
        action =>           q{popModule();},
    },

    # gcc errors:
    # testa.c: In function `proc1':
    # testa.c:16: error: too few arguments
    # tests/TestStringUtilities.cpp:854: warning: unsigned int format,
    #    long unsigned int arg (arg 7)
    #
    # Notes:
    # * Trigger on the error line, but include the "In function" line if
    #   it is present.
    # * Error messages may span multiple lines, but the continuation
    #   lines are indented.

    {
        id =>               "gccError",
        pattern =>          q{([^:]+):[\d:]+ error:},
        action =>           q{incValue("errors"); diagnostic($1, "error",
                                    backWhile(": In (member )?function"),
                                    forwardWhile("^   "))},
    },

    # gcc warnings:
    # testa.c:18:2: warning: no newline at end of file

    {
        id =>               "gccWarning",
        pattern =>          q{([^:]+):[\d:]+ warning:},
        action =>           q{incValue("warnings"); diagnostic($1, "warning",
                                    backWhile(": In function"), 0)},
    },

    # cl errors:
    #   testa.c(13) : error C2143: syntax error : missing ';' before '{'
    # Alternate form
    #   Prepare.proj(118,3): error MSB3021: Unable to copy file'

    {
        id =>               "clError",
        pattern =>          q{([^(]+)(\([\d,]+\))? ?: (fatal )?error [a-zA-Z]+[\d]+},
        action =>           q{incValue("errors"); diagnostic($1, "error")},
    
    },

    # cl warnings:
    # testa.c(13) : warning C4552: '<' : operator has no effect

    {
        id =>               "clWarning",
        pattern =>          q{([^(]+)\([\d,]+\) ?: warning },
        action =>           q{incValue("warnings"); diagnostic($1, "warning")},

    },

    # Miscellaneous error messages from Microsoft tools:
    # NMAKE : fatal error U1077: 'for' : return code '0x1'
    # BSCMAKE: error BK1506 : cannot open file ...
    # mt.exe : general error c10100b1: Failed to load file ...
    # midl : command line error MIDL1000 : missing source-file name

    {
        id =>              "msToolError",
        pattern =>         q{^([^\s:]+)\s*: [^:]*error [[:alnum:]]+ ?:},
        action =>          q{incValue("errors"); diagnostic("$1", "error");},
    },

    # Miscellaneous warning messages from Microsoft tools:
    # cl : Command line warning D4024 : unrecognized source file type ...
    # LINK : warning LNK4044: unrecognized option ...

    {
        id =>              "msToolWarning",
        pattern =>         q{^([^\s:]+)\s*: [^:]*warning [[:alnum:]]+ ?:},
        action =>          q{incValue("warnings");
                                    diagnostic("$1", "warning");},
    },

    # Error messages from Microsoft rc program (this one does not
    # conform to the generic pattern above)
    # fatal error RC1109: error creating .\objs\msvc.res

    {
        id =>              "msRcError",
        pattern =>         q{error RC[0-9]+:},
        action =>          q{incValue("errors"); diagnostic("RC", "error");},
    },

    # javac errors:
    # [javac] license\SignToolTest.java:296: cannot find symbol
    # [javac] symbol  : ...
    # [javac] location: class com.electriccloud.license.SignToolTest
    # [javac]         Pair<String, String> result = runMain(...);
    # [javac]                                       ^
    # [javac] 6 errors

    {
        id =>               "javacError",
        pattern =>          q{^\s*\[javac\] (\d+) error},
        action =>           q{incValue("errors", $1); diagnostic("", "error",
                                    backWhile(q{^\s*\[javac\] }))},
    },

    # javac warnings:
    # [javac] Compiling 257 source files to ...
    # [javac] Note: HibernateDao.java uses or overrides a deprecated API.
    # [javac] Note: Recompile with -Xlint:deprecation for details.

    {
        id =>               "javacNote",
        pattern =>          q{^\s*\[javac\] Note:},
        action =>           q{incValue("warnings", $1); diagnostic("",
                                    "warning", 0,
                                    forwardWhile(q{^\s*\[javac\] Note:}))},
    },

    # junit test summary line:
    # [junit] Testsuite: com.electriccloud.commander.agent.AgentManagerTest
    # [junit] Tests run: 24, Failures: 3, Errors: 1, ...

    {
        id =>               "junitSummary",
        pattern =>          q{^\s*\[junit\] Tests run: (\d+), }
                                    . q{Failures: (\d+), Errors: (\d+),},
        action =>           q{incValue("tests", $1);
                                    if (($2 + $3) > 0) {
                                        incValue("errors", $2 + $3);
                                        my $start = 0;
                                        if (logLine($::gCurrentLine-1) =~
                                                m/\[junit\] Testsuite:/) {
                                            $start = -1;
                                        }
                                        diagnostic("", "error", $start);
                                    }},
    },

    # Error information that appears in the middle of junit tests:
    #
    # [junit] Testcase: test_add_failed_port took 0.717 sec
    # [junit] Testcase: test_checkForTimeouts took 10.43 sec
    # [junit]     FAILED
    # [junit] 10218 < 1000
    # [junit] junit.framework.AssertionFailedError: 10218 < 1000
    # [junit]     at com.electriccloud.http.xxx(HTTPDispatcherTest.java:128)
    #
    # [junit] Testcase: testExecute_ok took 0.321 sec
    #
    # OR...
    #
    # [junit] Testcase: testBufferProblem took 5.827 sec
    # [junit]    Caused an ERROR
    # [junit] Read timed out
    # [junit] java.net.SocketTimeoutException: Read timed out
    # [junit]   at java.net.SocketInputStream.socketRead0(Native Method)
    # [junit]   at java.net.SocketInputStream.read(SocketInputStream.java:129)
    # [junit]
    # [junit] Testcase: testHttpHttps took 0.328 sec

    {
        id =>               "junitFailure",
        pattern =>          q{^\s*\[junit\]\s*(FAILED|Caused an ERROR)},
        action =>           q{incValue("errors"); junitFailure();},
    },

    # Overall junit failure banner, which can happen in situations
    # where there is no other error report:
    # [junit] Tests FAILED
    #
    # junit.report:
    # [junitreport] [Fatal Error] :-1:-1: Premature end of file.
    # [junitreport] The file ...

    {
        id =>               "junitTestsFailed",
        pattern =>          q{\[junit\] Tests FAILED},
        action =>           q{incValue("errors"); diagnostic("", "error", 0,
                                    forwardWhile(q{(^$)|(junit\.?report)}))},
    },

    # JAVA execution errors
    # this matcher looks for a common java error, bad
    # classpath resulting in class not found
    {
        id =>              "javaClassDefNotFound",
        pattern =>         q{java\.lang\.ClassNotFoundException},
        action =>          q{incValue("errors");
            diagnostic("javaClassDefNotFound", "error");},
    },

    # Diagnostic messages at the end of junit tests:
    # There was 1 failure:
    # There were 12 errors:
    # 1) testURLNoAccess(TestBuildList)
    # ...
    # FAILURES!!!

    {
        id =>               "junitDiagnostics",
        pattern =>          q{^There (were|was) \d+ (failure|error)s?:},
        action =>           q{junitDiagnostics()},
    },

    # Unix core dump:
    # "segmentation fault", "access violation", or "core dumped"

    {
        id =>               "unixCrash",
        pattern =>          q{[Ss]egmentation fault|core dump|}
                                    . q{[Aa]ccess violation},
        action =>           q{incValue("errors"); diagnostic("", "error", -4)},
    },

    # Windows core dump:
    # Application encountered an unexpected error. Stopping.

    {
        id =>               "winCrash",
        pattern =>          q{Application encountered an unexpected}
                                    . q{ error\. Stopping\.},
        action =>           q{incValue("errors"); diagnostic("", "error", -4)},
    },

    # Extraneous output in cppunit/junit test:
    # TestSymbol.testSymbolDefineIntegerSymbol........................... xxx
    # This is text to interfere with message output.<<< FAILED >>>
    # TestSymbol.testSymbolDefineInt64Symbol............................. xxx
    # This is text to interfere with message output.PASSED
    #
    # Note: this check is tricky, because (a) we want to handle lines with as
    # few dots as possible (to support very long test names), but (b) ".." can
    # occur commonly in messages (as part of filenames)  and (c) "..." can
    # also occur commonly, though typically only at the end of a line.
    #
    # Also, there are cases like the following where the PASSED or FAILED
    # information never appears for a test:
    # TestUploadManager.testVersionMismatch.................................
    # Application encountered an unexpected error.  Stopping.
    # Saved dump file to ...
    # make[1]: *** [cppunittest] Error 1
    # make[1]: Target `test' not remade because of errors.
    # make[1]: Leaving directory `...'
    #
    # Since we can't know for sure how many lines to include in the
    # diagnostic message, just include a fixed number, but then back up
    # the current line so that we will reprocess all of the lines after
    # the current line for additional issues.
    #
    # Don't increment "tests": this will happen when PASSED is seen by
    # testPass on a later line (if the PASSED is actually on this line,
    # then we will miss it... too bad).

    {
        id =>               "cppunitExtraOutput",
        pattern =>          q{(.*(?!\.\.).)\.\.\.\.+(?!\.)}
                                    . q{(?! ?(PASSED|SKIPPED|<<< FAILED >>>}
                                    . q{|<<< ERROR >>>))},
        action =>           q{incValue("warnings");
                                    my $savedLine = $::gCurrentLine;
                                    diagnostic($1, "warning", 0, 4);
                                    $::gCurrentLine = $savedLine;
                                    if (index($line, "PASSED") >= 0) {
                                        incValue("tests");
                                    }},
    },

    # cppunit test failed (diagnostic message at end of cppunit output):
    #
    # tests\TestSymbol.cpp(188) : Assertion
    # Test name: TestSymbol.testSymbolDefineStringSymbol
    # - Expected : 1
    #
    # - Actual   : 2
    #
    #
    # tests\TestSymbol.cpp(204) : Assertion
    # Test name: TestSymbol.testSymbolDefineStringPointerSymbol
    # - Expected : 16
    #
    # - Actual   : 4
    #
    #
    # Failures !!!
    # Run: 117   Failure total: 3   Failures: 3   Errors: 0   Skipped: 0

    {
        id =>               "cppunitFail",
        pattern =>          q{^Test name: (.*)},
        action =>           q{incValue("tests"); incValue("errors");
                                    diagnostic($1, "error", -1, forwardTo(
                                    " : Assertion|Failures !!!") -3);},
    },

    # generic test passed (e.g., tclTest, junit, cppunit):
    # ++++ A2AWorker::run-3 PASSED
    # agent-abortCommand-noCmdId ..................................PASSED
    # agent-abortCommand-noCmdId .................................. PASSED
    #
    # Notes:
    #     * Sometimes there are no dots for junit or cppunit (e.g., if
    #       the test name is very long).
    #     * This pattern must follow any patterns like cppunitExtraOutput,
    #       which check for special cases.

    {
        id =>               "testPass",
        pattern =>          "PASSED",
        action =>           q{incValue("tests")},
    },

    # generic test skipped (e.g., tclTest, junit, cppunit):
    # ++++ EfsCommander-14.1 SKIPPED: pcOnly
    # TestEfs.testGetRoots........................................SKIPPED
    # TestEfs.testGetRoots........................................ SKIPPED

    {
        id =>               "testSkipped",
        pattern =>          "SKIPPED",
        action =>           q{incValue("testsSkipped")},
    },

    # Tcl test failed:
    # ==== Exec-win::getChildren-1 no children FAILED
    # ==== Contents of test case:
    # testWrapper {
    #     testwin getchildren [pid]
    # }
    # ---- Result was:
    # 264 272
    # ---- Result should have been:
    #
    # ==== Exec-win::getChildren-1 FAILED
    #
    # Some of the test names include newlines, so trigger on the "===="
    # (which is enough to indicate an error) not the FAILED.

    {
        id =>               "tclTestFail",
        pattern =>          q{^==== ([^ ]+) },
        action =>           q{incValue("tests"); incValue("errors");
                                    diagnostic($1, "error", 0,
                                    forwardTo('^====.*FAILED'))},
    },

    # Tcl cluster system test timeout:
    # ***** test_2 stalled: killing make process (60000 ms)
    # ***** killing running builds on CM *****

    {
        id =>               "tclClusterTestTimeout",
        pattern =>          q{\*\*\*\*\* (.*) stalled:},
        action =>           q{incValue("tests"); incValue("errors");
                                    diagnostic($1, "error", 0,
                                    forwardWhile('^\*\*\*\*'))},
    },

    # generic errors:
    # ... ERROR: ...
    # ... error: ...
    # ... error (...): ...
    # ... Error [...]: ...

    {
        id =>               "error",
        pattern =>          q{^(.* )?(ERROR|[Ee]rror)}
                                    . q{( (\([^)]+\)|\[[^\]]+\]))?: },
        action =>           q{incValue("errors"); diagnostic("", "error", -4,
                                    forwardWhile("^   "))},
    },

    # generic error with additional number:
    # ... ERROR 2003 (...): ...

    {
        id =>               "errorWithNumber",
        pattern =>          q{^(.* )?ERROR \d+}
                                    . q{( \([^)]+\))?: },
        action =>           q{incValue("errors"); diagnostic("", "error", -4,
                                    forwardWhile("^   "))},
    },

    # generic warnings:
    # ... WARNING: ...
    # ... warning: ...

    {
        id =>               "warning",
        pattern =>          q{WARNING:|[Ww]arning:},
        action =>           q{incValue("warnings"); diagnostic("",
                                    "warning", -4)},
    },

    # Electric Cloud errors:
    # ERROR EC3123: ...

    {
        id =>               "ecloudError",
        pattern =>          q{^ERROR EC\d*:},
        action =>           q{incValue("errors"); diagnostic("",
                                    "error", 0, 1)},
    },

    # Electric Cloud warnings:
    # WARNING EC3123: ...

    {
        id =>               "ecloudWarning",
        pattern =>          q{^WARNING EC\d*:},
        action =>           q{incValue("warnings"); diagnostic("",
                                    "warning", 0, 1)},
    },

    # Oracle errors:
    # ORA-01940: cannot drop a user that is currently connected

    {
        id =>               "oracleError",
        pattern =>          q{^ORA-[0-9]{5}:},
        action =>           q{incValue("errors");
                              diagnostic($1, "error", 0, 1);},
    },

    # Match one kind of EMMA report path
    # The following output is generated when EMMA is used with Ant in
    # "on-the-fly" mode, or in "offline" and "on-the-fly" command line mode:
    #
    # EMMA: writing [txt] report to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage.txt] ...
    # EMMA: writing [html] report to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\index.html] ...
    {
        id =>               "emmaReport1",
        pattern =>          q{EMMA: writing},
        action =>           q{emmaExtractReport()},
    },

    # Match another kind of EMMA report path
    # The following output is generated when EMMA is used with Ant in "offline"
    # mode.  The lines that begin with "[report]" are the ones where we need to
    # extract the path.  However it's probably not sufficient to just match on
    # this pattern as it's quite generic and does not use the word "EMMA" at
    # all, so this could potentially have nothing to do with EMMA.  To get
    # around this, search back word until we see "[java] EMMA" as a sanity check
    # that this is in fact EMMA output:
    #
    # run:
    #    [instr] processing instrumentation path ...
    #    [instr] instrumentation path processed in 78 ms
    #    [instr] [3 class(es) instrumented, 0 resource(s) copied]
    #    [instr] metadata merged into [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\metadata.emma]
    #
    #     [java] EMMA: collecting runtime coverage data ...
    #     [java] main(): running doSearch()...
    #     [java] main(): done
    #     [java] EMMA: runtime coverage data written to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\coverage.emma] {in 63 m
    #   [report] processing input files ...
    #   [report] 2 file(s) read and merged in 0 ms
    #   [report] writing [txt] report to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\coverage.txt] ...
    #   [report] writing [xml] report to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\coverage.xml] ...
    #   [report] writing [html] report to [C:\Documents and Settings\localUser\Desktop\emma\emma-2.0.5312\examples\coverage\coverage.html] ...
    {
        id =>               "emmaReport2",
        pattern =>          q{\[report\] writing},
        action =>           q{emmaValidateOutput()},
    },

    # Match a junit report using junitreport Ant tag.
    #
    # The junitreport Ant task is supported in versions of Ant before 1.7.0
    # (e.g. 1.6.5) but in versions before 1.7.0, we don't have detailed
    # enough output to match the location of the report.
    #
    # Example output:

    # junit.report:
    # [junitreport] Processing /home/localUser/junitDemo1/sample/testreport/TESTS-TestSuites.xml to /tmp/null1214791178
    # [junitreport] Loading stylesheet jar:file:/usr/local/tools/common/apache-ant-1.7.0/lib/ant-junit.jar!/org/apache/tools/ant/taskdefs/optional/junit/xsl/junit-frames.xsl
    # [junitreport] Transform time: 622ms
    {
        id =>               "junitReportCapture",
        pattern =>          q{\[junitreport\] Processing},
        action =>           q{junitExtractReport()},
    },

    # Match [clover-html-report] Ant task.
    #
    # Example output:

    # [clover-html-report] Clover Version 2.4.0, built on November 05 2008 (build-747)
    # [clover-html-report] Loaded from: /home/cloverDemo/clover-ant-2.4.0/lib/clover.jar
    # [clover-html-report] Clover: Evaluation License registered to electric cloud.
    # [clover-html-report] You have 27 day(s) before your license expires.
    # [clover-html-report] Loading coverage database from: '/home/cloverDemo/clover-ant-2.4.0/tutorial/.clover/clover2_4_0.db'
    # [clover-html-report] Writing HTML report to '/home/cloverDemo/clover-ant-2.4.0/tutorial/clover_html'
    # [clover-html-report] Done. Processed 1 packages in 3227ms (3227ms per package).

    {
        id =>               "cloverHtmlReportAntTask",
        pattern =>          q{\[clover-html-report\] Writing HTML report to},
        action =>           q{cloverExtractReport()},
    },

);

# ------------------------------------------------------------------------
# Matchers can be organized into groups; selecting a group selects all of
# the matchers in that group.
# ------------------------------------------------------------------------

%::gMatcherGroups = (
    "none"               => [],
    "cppunit"            => ["cppunitPass", "cppunitFail",
                             "cppunitExtraOutput"],
    "make"               => ["compileCommand", "makeAbort", "makeNotRemade",
                             "gccError", "gccWarning", "clError", "clWarning"],
    "misc"               => ["unixCrash", "winCrash", "warning"],
    "javatools"          => ["emmaReport1", "emmaReport2", "junitReportCapture", "cloverHtmlReportAntTask"],
);

# ------------------------------------------------------------------------
# The following variables are used to read in the log file.  We retain
# in memory a sliding window of lines, so that when an error is found we
# can retrieve lines that precede the error message as well as those
# that follow it.
# ------------------------------------------------------------------------

$::gLogHandle = "";            # Handle for open log file.
####$::gLogSelector = new IO::Select();   # Object for testing input on the handle
@::gLogWindow = ();            # List of lines in reverse order:  first
                               # element is last line read.
$::gWindowSize = 200;          # Maximum number of lines to retain in the
                               # window at any given time that are older
                               # than $::gCurrentLine.
$::gLastLine = 0;              # Number of the last line in gLogWindow
                               # (the one most recently read).  1 means
                               # first line of the file.
$::gCurrentLine = 0;           # Number of the line we are currently
                               # processing.  Usually the same as $::gLastLine
                               # but can be different if logLine has read
                               # ahead.

# ------------------------------------------------------------------------
# The following information is used to control output of diagnostic
# property information.  After each diagnostic record is added to the
# diagnostics file we close the file, leaving it a complete and valid
# XML document.  This allows the contents of the file to be read and used
# between our updates.  When we make the next update, we have to overwrite
# the old file trailer and then create a new trailer.
# ------------------------------------------------------------------------

$::gDiagTrailerOffset = 0;     # Offset in the diagnostics file of the current
                               # file trailer: the next time we write a
                               # diagnostic, write the new information
                               # starting at this offset.  0 means no
                               # diagnostics have been written yet.
$::gDiagLastLine = 0;          # Line number of the last log line that was
                               # included in a diagnostic extract.  Allows
                               # us not to include a given log line in
                               # more than one diagnostic record.

# ------------------------------------------------------------------------
# Variables managed by pushModule and popModule:
# ------------------------------------------------------------------------

@::gModuleStack = ();          # Stack of module names (most nested
                               # module first).  Managed by
                               # pushModule and popModule to keep track
                               # of the name of the current module for
                               # error reporting.
$::gModulePrefix = "";         # Common prefix for all module names;
                               # only the portion of a module name after
                               # this is recorded.
$::gModulePrefixLength = 0;    # Number of characters in $::gModulePrefix.

# ------------------------------------------------------------------------
# Information used to update job step properties on the server:
# ------------------------------------------------------------------------

%::gProperties = ();           # Hash whose names and values represent all
                               # of the properties that should (eventually)
                               # be set on the server for the job step.
%::gChangedProperties= ();     # Hash whose names represent properties that
                               # have changed since the last update
                               # The value represents the last value that 
                               # was sent to the server.
$::gLastUpdateTime = 0;        # Time (as returned by the "time" function)
                               # we last updated the server.
$::gUpdateDelaySeconds = 30;   # For non-urgent property changes we wait
                               # this amount of time since the previous
                               # update before updating the server again,
                               # in order to reduce the load on the server.
$::gUrgentPropertyChange = 0;  # Nonzero means that an important property
                               # change has occurred, such as the occurrence
                               # of the first error.  This means we should
                               # update the server immediately, even if
                               # $::gUpdateDelaySeconds hasn't elapsed.
$::gSkipUpdates = 0;           # Set to a nonzero value when running unit
                               # tests; causes actual server requests to be
                               # skipped since there is typically no server
                               # available.

# ------------------------------------------------------------------------
# Miscellaneous values:
# ------------------------------------------------------------------------

$::gCurrentMatcher = undef;    # When the action for a matcher is
                               # executing this variable points to the
                               # matcher.
$::gDebugLogHandle = undef;    # If --debugLog has been specified, gives
                               # the handle for the log file.
@::gSelectedMatchers = ();     # The set of matchers that are actually used
                               # to compare against the log file (subset
                               # of @::gMatchers).
$::gContinue = 0;              # Global flag that indicates if the current
                               # matcher action should stop the matcher loop
                               # or not.  Reset to 0 before each action.

# ------------------------------------------------------------------------
# Command-Line Options
# ------------------------------------------------------------------------

# The following variables hold information from command-line arguments:

$::gCheck = "";                      # Comma-separated list of matchers (or
                                     # groups of matchers) to check against
                                     # the log file.
$::gDebugLog = "";                   # Name of file in which to write
                                     # debugging information.  Empty string
                                     # means don't save debugging info.
$::gDiagFile = "";                   # Name of file in which to place
                                     # diagnostic information extracted
                                     # from the log.
$::gDiagFileDir = "";                # Directory in which to place the
                                     # diagnostics file.
$::gDontCheck = "";                  # Comma-separated list of matchers (or
                                     # groups of matchers) that should not
                                     # be checked, even if specified in
                                     # $::gCheck.
@::gExcludePatterns = ();            # Any line matching one of these
                                     # patterns is ignored, even if it
                                     # matches one of the matchers.
$::gHelp = 0;                        # 1 means --help was specified.
$::gStepId = "";                     # ElectricCommander identifier for the
                                     # step whose log file we are processing.
$::gJobStepName = "";                # name of the current step
$::gLiveUpdate = 1;                  # Value of the --liveUpdate option.
@::gLoadFiles = ();                  # Names of Perl files to load and
                                     # evaluate immediately after option
                                     # processing; from the --load option.
@::gLoadProperties = ();             # Names of properties containing Perl
                                     # scripts to evaluate immediately after
                                     # processing --load options; from
                                     # the --loadProperty option.
$::gMaxLines = 200;                  # Value of --maxLines option: limit
                                     # length of any single diagnostic to
                                     # this many lines.
$::gPrintUpdates = 0;                # 1 means --printUpdates was specified.
@::gRequiredPatterns = ();           # Each element in this array must match
                                     # at least one line in the log;
                                     # otherwise the log is considered
                                     # incomplete and an error is generated.
                                     # As matches are found, elements are
                                     # removed from this array.
@::gExtraProperties = ();            # Information about additional
                                     # properties to set for the state;
                                     # from the --property option.
$::gVersion = 0;                     # 1 means --version was specified.
$::gWarningsAsInfo = 0;              # Flag for whether or not to treat warnings
                                     # as INFO diagnostics. Can be set with
                                     # the --warningsAsInfo flag

# Input for GetOptions:

my %gOptions = (
             "check=s"                           => \$::gCheck,
             "charEncoding=s"                    => \$::gCharEncoding,
             "debugLog=s"                        => \$::gDebugLog,
             "diagFile=s"                        => \$::gDiagFile,
             "diagDirectory=s"                   => \$::gDiagFileDir,
             "dontCheck=s"                       => \$::gDontCheck,
             "ignore=s"                          => \@::gExcludePatterns,
             "help"                              => \$::gHelp,
             "jobStepId=s"                       => \$::gStepId,
             "liveUpdate=i"                      => \$::gLiveUpdate,
             "load=s"                            => \@::gLoadFiles,
             "loadProperty=s"                    => \@::gLoadProperties,
             "maxLines=i"                        => \$::gMaxLines,
             "printUpdates"                      => \$::gPrintUpdates,
             "property=s"                        => \@::gExtraProperties,
             "require=s"                         => \@::gRequiredPatterns,
             "skipUpdates"                       => \$::gSkipUpdates,
             "updateDelay=i"                     => \$::gUpdateDelaySeconds,
             "version"                           => \$::gVersion,
             "warningsAsInfo"                    => \$::gWarningsAsInfo,
             );

# Help text to print in response to "-help":

$::gHelpMessage = "$gBanner\nUsage: postp [options] logFile

Options:
--charEncoding         Character encoding of the log file.
                       Defaults to system default.
--check                Comma-separated list of things to check
                       (names of matchers or matcher groups).
--debugLog             If specified, gives the name of a file in
                       which to log information about what postp
                       is doing.  Used primarily for debugging.
--diagFile             Name of file in which to place diagnostic
                       information extracted from log (defaults
                       to diag-jjj.xml where jjj is the job step
                       id).
--diagDirectory        Path to directory in which to write
                       --diagFile; empty string means use working
                       directory.; defaults to environment
                       variable COMMANDER_WORKSPACE, or empty
                       string if it doesn't exist.
--dontCheck            Comma-separated list of things not to check
                       (names of matchers or matcher groups).  This
                       option takes precedence over --check.
--help                 Print this message and exit without doing
                       anything.
--ignore               Regular expression pattern: any line in the
                       log file matching this pattern will be
                       skipped without matching it against the
                       matchers.  There may be multiple --ignore
                       options.
--jobStepId            Identifier for the ElectricCommander job
                       step being processed (defaults to
                       environment variable COMMANDER_JOBSTEPID).
--liveUpdate           Nonzero means properties on the job step
                       will be updated on-the fly as information
                       is processed from the log file.  Zero means
                       the update happens only after the entire
                       log file has been read.  Defaults to 1.
--load                 Name of a file containing Perl code to
                       evaluate after option processing.
                       Typically used to load additional matchers.
                       There may be multiple --load options.
                       Searches all directories in PATH environment
                       variable for the file, unless the file name
                       contains a \"/\".
--loadProperty         Name of an ElectricCommander property
                       containing Perl code to evaluate after
                       option processing (and after processing
                       --load options).  Typically used to load
                       additional matchers. There may be multiple
                       --loadProperty options.
--maxLines             Maximum number of lines to include in any
                       single diagnostic extract (default: 200).
--printUpdates         If specified, the final server update
                       message will be printed on standard output;
                       used for debugging and testing.
--property             Value has the form name=value; causes an
                       additional property to be set for the step
                       There may be multiple --property options.
--require              Regular expression pattern: there must be
                       a line in the log file that matches this
                       pattern; if not, an error will be generated
                       after reading the log file.  Typically used
                       to detect when a job step ends silently
                       without completing all of its tasks.  There
                       may be multiple --require options, in which
                       case all must match (but not necessarily
                       the same line).
--skipUpdates          If specified (no value) no requests will be
                       sent to the ElectricCommander server to
                       update property values, regardless of other
                       options. Used primarily for testing.
--updateDelay          When --liveUpdate is set this option
                       determines how frequently to update the
                       server, in seconds.  Updates will only occur
                       if a property has changed and this amount of
                       time has elapsed since the last update.  The
                       only exception is that updates occur
                       immediately when the step's outcome changes.
--version              Print postp version number.
--warningsAsInfo       Treat warnings as INFO messages. Setting this
                       flag will cause jobs with warnings to have
                       an outcome of 'success' rather than 'warning',
                       but the extracted diagnostics will still be
                       available. The number of warnings found using
                       this option will be stored in a property named 
                       benignWarnings.
                       
";

# ------------------------------------------------------------------------
# for integration with standard java tools
# ------------------------------------------------------------------------
$::gEmmaPropertyPrefix = "emma";
@::gEmmaElementsToCopy = ();
$::gEmmaMatches = 1;

$::gJUnitPropertyPrefix = "junit";
@::gJUnitElementsToCopy = ();
$::gJUnitMatches = 1;

$::gCloverPropertyPrefix = "clover";
@::gCloverElementsToCopy = ();
$::gCloverMatches = 1;

$::gArtifactDirRoot = undef;
$::gJobStepJavaToolsArtifactDir = undef;

$::gSeparator = '/';

# ------------------------------------------------------------------------
# isWindows
#
#      Returns true if we're running on Windows.
# ------------------------------------------------------------------------

sub isWindows() {
    return ($^O eq "MSWin32");
}

#-------------------------------------------------------------------------
# debugLog
#
#      Records information in the debug log, if logging is enabled.
#
# Results:
#      None.
#
# Side Effects:
#      Information they get written to the debug log file.
#
# Arguments:
#      A format string and additional arguments, in the same form
#      that might be passed to sprintf.
#-------------------------------------------------------------------------

sub debugLog(@) {
    if (defined($::gDebugLogHandle)) {
        my @time = localtime();
        printf($::gDebugLogHandle "%d/%d/%d %02d:%02d:%02d ",
                $time[4]+1, $time[3], $time[5] +1900, $time[2],
                $time[1], $time[0]);
        printf($::gDebugLogHandle @_);
    }
}

#-------------------------------------------------------------------------
# logOpen
#
#      Open the log file and initialize relevant data structures.
#
# Results:
#      None.
#
# Side Effects:
#      Information related to reading the log file gets initialized.
#
# Arguments:
#      name         - (string) Path of log file.
#-------------------------------------------------------------------------

sub logOpen($) {
    my ($name) = @_;

    if ($name) {
        my $handle;
        open($handle, "< $name")
                or die "couldn't open log file \"$name\": $!";
        $::gLogHandle = $handle;
    } else {
        $::gLogHandle = \*STDIN;
    }

    # Set up the selector for using IO::Select on the handle
    ####$::gLogSelector->add($::gLogHandle);
}

#-------------------------------------------------------------------------
# logNext
#
#      Return the next line in order from the log file, or undef if we
#      have reached the end of the file.
#
# Side Effects:
#      The line is saved in the sliding window, and old lines may be
#      ejected from the sliding window.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub logNext() {

    # Discard old lines (leave $::gWindowSize lines preceding
    # $::gCurrentLine).

    my $discard = @::gLogWindow - ($::gLastLine - ($::gCurrentLine+1))
            - $::gWindowSize;
    while ($discard > 0) {
        pop(@::gLogWindow);
        $discard--;
    }
    my $line = logLine($::gCurrentLine+1);
    $::gCurrentLine++ if defined $line;
    return $line;
}

#-------------------------------------------------------------------------
# logLine
#
#      Return a given line from the log file, or an empty string if the
#      line has been discarded from the sliding window.  Undef is
#      returned when we reach the end of the file.
#
# Side Effects:
#      More lines may be added to the sliding window.  This function
#      does *not* change $::gCurrentLine.
#
# Arguments:
#      lineNumber -       Line number for the desired line.
#-------------------------------------------------------------------------

sub logLine($) {
    my ($lineNumber) = @_;

    # There are three cases to consider:
    #   * The desired line has been dcarded from the sliding window.
    #   * The desired line is present in the current window.
    #   * The desired line has not yet been read.
    # Compute the index in the sliding window of the desired line
    # (assuming it is present in the window).  This allows us to
    # distinguish the 3 cases.

    my $index = $::gLastLine - $lineNumber;
    if ($index >= @::gLogWindow) {
        # Line has been discarded.

        return "";
    }
    if ($index >= 0) {
        # Line is present in the window.

        return $::gLogWindow[$index];
    }

    # The line hasn't been read yet.  Read lines into the window until
    # we get to the desired line.

    while ($index < 0) {
        my $line = postpReadline();
        if (!defined($line)) {
            # End of file.

            return $line;
        }

        # This handles a timeout from postpReadline (which does not work!)
        next unless (length $line);

        unshift(@::gLogWindow, $line);
        $::gLastLine++;
        $index++;
    }
    return $::gLogWindow[0];
}

my $gBuffer = "";
my $gFoundEof = 0;

#-------------------------------------------------------------------------
# postpReadline
#
#      Reads one line from the global file handle.
#      It was designed to work as a non-blocking readwith a timeout,
#      but "select" would not work in Windows
#
# Side Effects:
#      Loads a block of data into the global buffer.
#      Translates CRLF to newline
#
# Arguments:
#
# Returns:
#      line         -   The line will always be \n-terminated, except
#                         for the last line whicn MAY not have a \n.
#                       If the line is undefined, it means EOF was reached.
#
#-------------------------------------------------------------------------
sub postpReadline()
{
    my $bytesToRead = 65536;

    # If the buffer does not have a line, try to populate it
    if ($gBuffer !~ /\n/  &&  !$gFoundEof) {

        # Do a select() to find out if data is waiting
        #  WARNING - This does not work in Windows.  the
        #  select function of Perl maps to a winsock call, so it
        #  is ONLY INTENDED for sockets, not files
        #########my @ready = $::gLogSelector->can_read( $timeout );


        my $bytes = sysread $::gLogHandle, $gBuffer, $bytesToRead, length $gBuffer;
        if($bytes == 0) {
            $gFoundEof = 1;
        }
    }

    # Return a result based on the contents of the buffer
    #   use minimal match to get just one line
    #   (not really necessary because dot does not match newline)
    my $result = "";

    # replace all \r\n with \n
    $gBuffer =~ s/\r\n/\n/g;

    # At this point there should be no \r in $gBuffer.
    if($gBuffer =~ s/(.*?\n)//) {
        $result = $1;
    }
    elsif($gFoundEof)
    {
        # handle last line with no newline
        if (length $gBuffer) {
            $result = $gBuffer;
            $gBuffer = "";
        }
        else {
            # EOF found and all data returned
            $result = undef;
        }
    } elsif (length $gBuffer >= $bytesToRead) {
    # If we get here it means no \n was found and no eof was deteced
    # in $gBuffer of length $bytesToRead - 
    # which is a very long line.  This is likely indicative of something
    # strange in the log file.  Rather than keep
    # reading bytes in to $gBuffer and letting it get too big, just
    # log that we've found a very long line and process it as is.

    debugLog("WARNING: found a line of length %d with no new line.  Processing it as is.\n", length $gBuffer);

    $result = "$gBuffer\n";
    $gBuffer = "";
    }

    return $result;
}


#-------------------------------------------------------------------------
# forwardTo
#
#      Search forward to find a line matching a particular pattern.
#
# Results:
#      Return value is an offset (relative to the current line) of the
#      first line at or after $start that matches $pattern.  If we reach
#      the end of the file without a matching line, the return value is
#      the offset of the line just after the last one in the file.
#
# Side Effects:
#      None.
#
# Arguments:
#      pattern -       Regular expression pattern.
#      start -         Offset (relative to the current line) of the first
#                      line to check.  Defaults to 1.
#-------------------------------------------------------------------------

sub forwardTo($;$) {
    my ($pattern, $start) = @_;
    $start = 1 unless defined($start);

    my $offset;
    for ($offset = $start; ; $offset++) {
        my $line = logLine($offset + $::gCurrentLine);
        if (!defined($line)) {
            # We have reached the end of the file.

            return $offset;
        }
        if ($line =~ m/$pattern/) {
            return $offset;
        }
    }
}

#-------------------------------------------------------------------------
# forwardWhile
#
#      Search forward to find the last line that matches a particular
#      pattern.
#
# Results:
#      Return value is an offset (relative to the current line) of the
#      last line at or after $start that matches $pattern.  If
#      we reach the end of the file without a mismatching line, the
#      return value is the offset of the last line in the file.  If
#      no lines match, the return value is start-1.
#
# Side Effects:
#      None.
#
# Arguments:
#      pattern -       Regular expression pattern.
#      start -         Offset (relative to the current line) of the first
#                      line to check.  Defaults to 1.
#-------------------------------------------------------------------------

sub forwardWhile($;$) {
    my ($pattern, $start) = @_;
    $start = 1 unless defined($start);

    my $offset;
    for ($offset = $start; ; $offset++) {
        my $line = logLine($offset + $::gCurrentLine);
        if (!defined($line)) {
            # We have reached the end of the file.

            return $offset-1;
        }
        if ($line !~ m/$pattern/) {
            return $offset-1;
        }
    }
}

#-------------------------------------------------------------------------
# backTo
#
#      Search backward to find a line matching a particular pattern.
#
# Results:
#      Return value is an offset (relative to the current line) of the
#      highest-numbered line at or before $start that matches $pattern.
#      If we reach the end of sliding window without a matching line,
#      the return value is the offset of the line just before the first
#      one in the window.
#
# Side Effects:
#      None.
#
# Arguments:
#      pattern -       Regular expression pattern.
#      start -         Offset (relative to the current line) of the first
#                      line to check.  Defaults to -1.
#-------------------------------------------------------------------------

sub backTo($;$) {
    my ($pattern, $start) = @_;
    $start = -1 unless defined($start);

    my $offset;
    for ($offset = $start; ; $offset--) {
        my $line = logLine($offset + $::gCurrentLine);
        if ($line eq "") {
            # We have run off the end of the sliding window.

            return $offset;
        }
        if ($line =~ m/$pattern/) {
            return $offset;
        }
    }
}

#-------------------------------------------------------------------------
# backWhile
#
#      Search backward to find the last line that matches a
#      particular pattern.
#
# Results:
#      Return value is an offset (relative to the current line) of the
#      lowest-numbered line at or before $start that matches $pattern.
#      If we reach the end of the sliding window without a mismatching
#      line, the return value is the offset of the first line in the
#      sliding window.  If no lines match, the return value is start+1.
#
# Side Effects:
#      None.
#
# Arguments:
#      pattern -       Regular expression pattern.
#      start -         Offset (relative to the current line) of the first
#                      line to check.  Defaults to -1.
#-------------------------------------------------------------------------

sub backWhile($;$) {
    my ($pattern, $start) = @_;
    $start = -1 unless defined($start);

    my $offset;
    for ($offset = $start; ; $offset--) {
        my $line = logLine($offset + $::gCurrentLine);
        if ($line eq "") {
            # We have run off the end of the sliding window.

            return $offset+1;
        }
        if ($line !~ m/$pattern/) {
            return $offset+1;
        }
    }
}

#-------------------------------------------------------------------------
# pushModule
#
#      Add another module to those on the module stack.
#
# Results:
#      None.
#
# Side Effects:
#      The module name is pushed onto the module stack.  If a module
#      prefix is already known to us, and if that prefix matches the
#      first part of $name, that only the portion of $name after the
#      prefix is recorded.  If there is no prefix, or if it doesn't
#      match, than the portion of $name after the last "/" is
#      recorded. If this is the first module seen, its name is used
#      as the module prefix for future calls.
#
# Arguments:
#      name -          Name of the module, typically a file name
#                      path to the directory containing the module.
#-------------------------------------------------------------------------

sub pushModule($) {
    my ($name) = @_;

    # Push the (shortened) name onto the stack.

    if (($::gModulePrefix ne "") && ($::gModulePrefix eq
            substr($name, 0, $::gModulePrefixLength))) {
        # Prefix matches; use the portion after the prefix.

        $name = substr($name, $::gModulePrefixLength);
        $name =~ s|^/+||;
        unshift(@::gModuleStack, $name);
    } else {
        my $slash = rindex($name, "/");
        if ($slash >= 0) {
            # Record the portion after the last slash.

            unshift(@::gModuleStack, substr($name, $slash+1));
        } else {
            # No slash: record the entire name.

            unshift(@::gModuleStack, $name);
        }
    }

    # Save this name as the prefix if there isn't yet a prefix defined.

    if ($::gModulePrefix eq "") {
        $::gModulePrefix = $name;
        $::gModulePrefixLength = length($::gModulePrefix);
    }
}

#-------------------------------------------------------------------------
# popModule
#
#      Remove the most recently added module from the module stack.
#
# Results:
#      None.
#
# Side Effects:
#      The topmost module name is popped from the module stack (i.e.,
#      the one that was pushed most recently).
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub popModule() {
   shift @::gModuleStack;
}

#-------------------------------------------------------------------------
# currentModule
#
#      Returns the name of the current module (the most recent value
#      pushed onto the module stack) or an empty string if the stack is
#      empty.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub currentModule() {
    if (@::gModuleStack > 0) {
        return $::gModuleStack[0];
    }
    return "";
}

#-------------------------------------------------------------------------
# propertyUpdateRequest
#
#      This function returns an XML server request suitable for updating
#      all of the job step properties that have been set so far.
#
#   Parameters
#       deltasOnly     -   1 means the update should only include changed props
#                          0 means print all - (used for debug only)
#-------------------------------------------------------------------------

sub propertyUpdateRequest($) {

    my $deltasOnly = shift;
    my $request = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
            . "<requests xmlns:xsi=\"http://www.w3.org/2001/"
            . "XMLSchema-instance\" xsi:noNamespaceSchemaLocation"
            . "=\"commander.xsd\" version=\"2.0\"";
    if ($::gCommander->{sessionId} ne "") {
        $request .= " sessionId=\"" . $::gCommander->{sessionId} . "\">\n";
    } else {
        $request .= ">\n";
    }
    my $requestId = 1;

    # Choose all properties of just those that have changed
    my @propertiesToSend = ($deltasOnly)  ? keys(%::gChangedProperties) :
                                            keys(%::gProperties);

    # Send all properties that have changed
    #   Read the keys from the changed hash
    foreach my $name (sort(@propertiesToSend)) {

        # Take the value from the "real" hash 
        $request .= sprintf("    <request requestId=\"$requestId\">\n"
                . "        <setProperty>\n"
                . "            <jobStepId>%s</jobStepId>\n"
                . "            <propertyName>%s</propertyName>\n"
                . "            <value>%s</value>\n"
                . "        </setProperty>\n"
                . "    </request>\n",
                xmlQuote($::gStepId), xmlQuote($name),
                xmlQuote($::gProperties{$name}));
        $requestId++;

        # Delete the entry in the changed hash so that it is not sent again
        delete $::gChangedProperties{$name};
    }
    $request .= "</requests>\n";
    return $request;
}

#-------------------------------------------------------------------------
# sendUpdatesViaBatchAPI
#
#      This function sends all job step properties using the
#      Batch API  (introduced in V3.2)
#-------------------------------------------------------------------------

sub sendUpdatesViaBatchAPI() {

    # Use the batch processing feature of the API (starts with V3.2)
    my $batchAPI = $::gCommander->newBatch('single');

    # Send all properties that have changed
    #   Read the keys from the changed hash
    foreach my $name (sort(keys(%::gChangedProperties))) {

        # Take the value from the "real" hash 
        $batchAPI->setProperty($name, $::gProperties{$name},
                                  {jobStepId => $::gStepId});

        # Delete the entry in the changed hash so that it is not sent again
        delete $::gChangedProperties{$name};
    }
    $batchAPI->submit();
}


#-------------------------------------------------------------------------
# updateOutcome
#
#      Set the outcome for the step based on other properties such as
#      count of errors or warnings.
#
# Results:
#      None.
#
# Side Effects:
#      The "outcome" property gets set to "warning" or "error" if
#      there are warnings or errors for this step.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub updateOutcome() {
    if (defined($::gProperties{errors}) && ($::gProperties{errors} > 0)) {
        setProperty("outcome", "error");
    } elsif (defined($::gProperties{warnings})
            && ($::gProperties{warnings} > 0)) {
        setProperty("outcome", "warning");
    }
}

#-------------------------------------------------------------------------
# updateServer
#
#      This function is invoked after each line of the log file is
#      processed.  It figures out whether we need to update property
#      information on the server; if so, we do it.
#
# Results:
#      None.
#
# Side Effects:
#      The contents of the array $::gProperties may get copied to
#      properties on the server.  If so, various bits of our internal
#      state get modified to reflect this.  The "outcome" property
#      gets set to "warning" or "error" if there are warnings or
#      errors.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub updateServer() {
    # Quit if there are no changed properties
    if (scalar keys (%::gChangedProperties) == 0) {
        return;
    }

    # Check for meeting the time interval
    my $currentTime = time();
    if (!$::gUrgentPropertyChange && (($currentTime - $::gLastUpdateTime)
            < $::gUpdateDelaySeconds)) {
        return;
    }

    # Calculate the step's outcome
    updateOutcome();
    debugLog("Updating server, urgent: %d\n", $::gUrgentPropertyChange);

    # Clear the Urgent Update flag
    $::gUrgentPropertyChange = 0;

    # Send the updates
    if (!$::gSkipUpdates) {
        if ($::gCommander->{protocolVersion} eq '2.0') {
            # Use the "manual" approach for the old protocol
            $::gCommander->httpPost(propertyUpdateRequest(1));
        } else {
            # Server is 3.2 or newer - use the Batch API
            sendUpdatesViaBatchAPI();
        }
    }
    else {
        # For testing - Simulate sending by clearing the "changed" hash
        %::gChangedProperties= ();
    }

    # Reset the update timer
    $::gLastUpdateTime = $currentTime;
}

#-------------------------------------------------------------------------
# setProperty
#
#      Arranges for a property to be set in the ElectricCommander server
#      for the step whose log file we are processing.
#
# Results:
#      None.
#
# Side Effects:
#      Information is generated that will eventually cause a property
#      value to be set in the ElectricCommander server.
#
# Arguments:
#      name -          Name of the property to be set.
#      value -         Value of the property.
#-------------------------------------------------------------------------

sub setProperty($$) {
    # Get Parameters
    my ($name, $value) = @_;

    # Mark the value for inclusion in the update
    # This also saves the last sent value (if there is one)
    # The value is not currently used, but could be used ro:
    #     Sending increments of numeric values
    #     Suppressing changes that set it back to where it started
    # It will all be reset when sent
    if (! defined $::gChangedProperties{$name}) {
            
        $::gChangedProperties{$name} = (defined $::gProperties{$name}) ?
                                       $::gProperties{$name}  :  "";
    }

    # Save the value
    $::gProperties{$name} = $value;
    debugLog("Set property %s to \"%s\"\n", $name, $value);
}

#-------------------------------------------------------------------------
# incValue
#
#      This function is typically invoked in the action for a matcher.
#      It increments a property on the job step.
#
# Results:
#      None.
#
# Side Effects:
#      The value of the property given by $name is incremented by
#      $increment and will eventually be updated on the ElectricCommander
#      server.
#
# Arguments:
#      name -          Name of job step property to increment.
#      increment -     (optional) How much to increment the value; defaults
#                      to 1.
#-------------------------------------------------------------------------

sub incValue($;$) {
    my ($name, $increment) = @_;

    $increment = 1 unless defined($increment);
    
    # Handle the WarningsAsInfo flag. If this flag is set and $name
    # is "warnings", then change $name to "benignWarnings".
    if ( ($name eq "warnings") && ($::gWarningsAsInfo) ){
      $name = "benignWarnings"
    }

    if (!$::gProperties{$name} && ($increment > 0)) {
        # The first time that an error is recorded we want to insist on
        # an immediate update on the server so that appropriate
        # notifications can be made without delay.  Ditto for the first
        # warning unless there is already an error.

        if (($name eq "errors")
                || (($name eq "warnings") && !$::gProperties{"errors"})) {
            $::gUrgentPropertyChange = 1;
        }
    }

    # Use setProperty to update the changed properties 
    my $newValue = $::gProperties{$name};
    $newValue += $increment;
    setProperty ($name, $newValue);
    debugLog("    Incrementing %s to %d\n", $name, $::gProperties{$name});
}

#-------------------------------------------------------------------------
# xmlQuote
#
#      Quote special characters such as & to generate well-formed XML
#      character data.
#
# Results:
#      The return value is identical to $string except that &, <, and >,
#      have been translated to &amp;, &lt;, and &gt;, respectively.
#
# Side Effects:
#      None.
#
# Arguments:
#      string -        String whose contents should be quoted.
#-------------------------------------------------------------------------

sub xmlQuote($) {
    my ($string) = @_;
    eval {$string = Encode::Byte::decode($::gCharEncoding, $string);};
    if($@ ne '') {
        print STDERR "Error during character conversion: $@\nIn $string";
    }
    $string = Encode::Byte::encode("UTF-8", $string);


    $string =~ s/&/&amp;/g;
    $string =~ s/</&lt;/g;
    $string =~ s/>/&gt;/g;
    $string =~ s/\x00//g;
    $string =~ s{([\0-\x{08}\x{0b}\x{0c}\x{0e}-\x{1f}])}{
            sprintf("%%%02x", ord($1))}ge;
    $string = Encode::Byte::decode("UTF-8", $string);
    return $string;
}

#-------------------------------------------------------------------------
# writeDiagnostic
#
#      This function does the dirty work of writing a record to the
#      XML file containing diagnostic information.  It doesn't actually
#      collect the information to be written; that is done by "diagnostic"
#      and other functions.
#
# Results:
#      None.
#
# Side Effects:
#      Diagnostic information is saved as XML in $::gDiagFile.
#
# Arguments:
#      matcher -       Name of the matcher that generated this record, or
#                      empty string if none.
#      name -          Name to associate with this record, such as the
#                      name of a file that didn't compile or the name of
#                      a test that failed.
#      type -          Classification for this diagnostic, such as "error",
#                      "warning", or "info".  Used by reporting tools, e.g.
#                      to display an icon next to the diagnostic.
#      module -        Module name to associate with the record (e.g.,
#                      module containing the file that didn't compile), or
#                      empty string if no module known.
#      firstLine -     Line number in the log file corresponding to the
#                      first line contained in $message (1 means the first
#                      line of the file.
#      numLines -      Number of log file lines contained in $message.
#      message -       Information extracted from the log file and/or other
#                      information to display for the diagnostic.
#-------------------------------------------------------------------------

sub writeDiagnostic($$$$$$$) {
    my ($matcher, $name, $type, $module, $firstLine, $numLines, $message) = @_;

    # Open and position the diagnostics file.

    my $fileName = $::gDiagFile;
    if ($::gDiagFileDir ne "") {
        $fileName = $::gDiagFileDir . "/" . $fileName;
    }
    if ($::gDiagTrailerOffset == 0) {
        # New file: output header information.

        open(DIAG, "> $fileName") or die "couldn't open diagnostics file "
                . "\"$fileName\": $!";
        binmode DIAG, ":utf8";
        print(DIAG "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
                . "<diagnostics>\n");
        setProperty("diagFile", $::gDiagFile);
    } else {
        # We are adding to an existing diagnostics file; write the new
        # record after all the previously-written records, overwriting
        # the old file trailer.

        open(DIAG, "+< $fileName") or die "couldn't reopen diagnostics file "
                . "\"$fileName\": $!";
        binmode DIAG, ":utf8";        
        seek(DIAG, $::gDiagTrailerOffset, 0);
    }

    # Generate the new diagnostic record.

    printf(DIAG "    <diagnostic>\n"
            . "        <matcher>%s</matcher>\n"
            . "        <name>%s</name>\n"
            . "        <type>%s</type>\n",
            xmlQuote($matcher), xmlQuote($name), xmlQuote($type));
    if ($module ne "") {
        printf(DIAG "        <module>%s</module>\n",
                xmlQuote($module));
    }
    printf(DIAG "        <firstLine>%s</firstLine>\n"
            . "        <numLines>%s</numLines>\n"
            . "        <message>%s</message>\n"
            . "    </diagnostic>\n",
            $firstLine, $numLines, xmlQuote($message));

    # Save the file position so we know where to write the next
    # diagnostic record, then append a trailer so that the file
    # contains a complete XML document.

    $::gDiagTrailerOffset = tell(DIAG);
    print(DIAG "</diagnostics>\n");
    close(DIAG);

    debugLog("    Diagnostic generated for lines %d-%d, matcher: %s, "
            . "name: %s, type: %s\n",
            $firstLine, $firstLine + $numLines - 1, $matcher, $name, $type);
}

#-------------------------------------------------------------------------
# diagnostic
#
#      This function is invoked by the actions for matchers.  It
#      extracts a group of contiguous lines from the log file and
#      records them as diagnostic information in an XML file.
#
# Results:
#      None.
#
# Side Effects:
#      Diagnostic information is saved as XML in $::gDiagFile.  If
#      $last > 0, the current line is advanced by $last so we don't do
#      any more processing of any of the lines in the diagnostic.
#
# Arguments:
#      name -          Name to associate with this diagnostic, such as the
#                      name of a file that didn't compile or the name of
#                      a test that failed.
#      type -          Classification for this diagnostic, such as "error",
#                      "warning", or "info".  Used by reporting tools, e.g.
#                      to display an icon next to the diagnostic.
#      first -         Offset (from the current line) of the first line
#                      in the log file to include in the diagnostic message.
#                      Defaults to 0.
#      last -          Offset (from the current line) of the last line
#                      in the log file to include in the diagnostic message.
#                      Defaults to 0.
#-------------------------------------------------------------------------

sub diagnostic($$;$$) {
    my ($name, $type, $first, $last) = @_;
    $first = 0 unless defined($first);
    $last = 0 unless defined($last);


    # Handle the WarningsAsInfo flag. If this flag is set, then treat 
    # any diagnostics of type "warning" as type "info" instead
    if ( ($type eq "warning") && ($::gWarningsAsInfo) ){
      $type = "info";
    }


    # Convert the range to actual line numbers and handle boundary conditions.

    $first += $::gCurrentLine;
    $last += $::gCurrentLine;
    if ($first <= $::gDiagLastLine) {
        # Don't output lines before the beginning of the log file.
        # In addition, don't output lines that are before the current
        # line and have already been output.

        if ($::gDiagLastLine < $::gCurrentLine) {
            $first = $::gDiagLastLine + 1;
        } elsif ($first < $::gCurrentLine) {
            $first = $::gCurrentLine;
        }
    }
    if ($last < $first) {
        # Make sure we output at least 1 line.

        $last = $first;
    }

    # Limit the length of diagnostic messages.

    if (($last + 1 - $first) > $::gMaxLines) {
        # Too many lines.  In truncating the message, try to retain
        # the current line.

        my $half = $::gMaxLines/2;
        if (($last - $::gCurrentLine) <= $half) {
            $first = $last - ($::gMaxLines-1);
        } elsif (($::gCurrentLine - $first) <= $half) {
            $last = $first + ($::gMaxLines-1);
        } else {
            $first = $::gCurrentLine - $half;
            $last = $first + ($::gMaxLines-1);
        }
    }

    # Collect the log lines for the new diagnostic record.

    my $message = "";
    my $current = $first;
    while ($current <= $last) {
        my $line = logLine($current);
        if (defined($line)) {
            $message .= $line;
        } else {
            # End of file: ignore anything past the end of the file.

            $last = $current - 1;
            last;
        }
        $current++;
    }

    my $module = currentModule();
    writeDiagnostic($::gCurrentMatcher->{id}, $name, $type, $module,
            $first, $last + 1 - $first, $message);

    # If the diagnostic covers log lines that we haven't processed yet,
    # advance the current line to skip over them.

    if ($last > $::gCurrentLine) {
        $::gCurrentLine = $last;
    }
    $::gDiagLastLine = $last;
    debugLog("    Diagnostic generated for lines %d-%d, name: %s, type: %s\n",
            $first, $last, $name, $type);
}

#-------------------------------------------------------------------------
# junitDiagnostics
#
#      This function is invoked to process a block of junit error
#      messages, which has the following structure:
#      There were 12 errors:
#      1) testname
#         diagnostic
#      2) testname
#         diagnostic
#      ...
#      There were 4 failures:
#      1) testname
#         diagnostic
#      2) testname
#         diagnostic
#      ...
#      FAILURES!!!
#
#      This function is invoked when the first "There were" line is
#      encountered.
#
# Results:
#      None.
#
# Side Effects:
#      The count of errors is incremented, and diagnostic information is
#      saved.  All of the lines up through the "FAILURES" line are consumed.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub junitDiagnostics() {
    my $line;

    while (1) {
        $line = logNext();
        if (!defined($line)) {
            last;
        }
        if ($line =~ m/^\d+\) (.*)/) {
            # This line marks the start of a new diagnostic.

            my $name = $1;

            # For failures the name typically has a bunch of additional junk
            # added on, starting with "junit.".  Use only the part before the
            # junk.

            my $index = index($name, "junit.");
            if ($index > 0) {
                 $name = substr($name, 0, $index);
            }

            diagnostic($name, "error", 0, forwardTo(q{^(\d+\) )|(FAILURES!!!)}
                    . q{|(There (were|was) \d+ (failure|error)s?:)}) - 1);
            incValue("tests");
            incValue("errors");
        } elsif ($line =~ m/^FAILURES!!!/) {
            # End of the diagnostics.

            last;
        }
    }
}

#-------------------------------------------------------------------------
# junitFailure
#
#      This function is invoked to process diagnostic information for
#      a single test failure, which looks like the following:
#      [junit] Testsuite: com.electriccloud.http.HTTPDispatcherTest
#      [junit] Tests run: 5, Failures: 1, Errors: 0, Time elapsed: 12.014 sec
#
#      [junit] Testcase: test_add_failed_port took 0.717 sec
#      [junit] Testcase: test_checkForTimeouts took 10.43 sec
#      [junit]     FAILED
#      [junit] 10218 < 1000
#      [junit] junit.framework.AssertionFailedError: 10218 < 1000
#      [junit]     at com....(HTTPDispatcherTest.java:128)
#
#      [junit] Testcase: testExecute_ok took 0.321 sec
#      [junit] Testcase: testExecuteAll_ok took 0.318 sec
#      [junit] Testcase: testExecuteAll_oneFailure took 0.218 sec
#      [junit] TEST com.electriccloud.http.HTTPDispatcherTest FAILED
#      [junit] Testsuite: com.electriccloud.http.HttpServerTest
#      [junit] Tests run: 13, Failures: 0, Errors: 0, Time elapsed: 14.672 sec
#
#      This function is invoked when the FAILED line is encountered.
#
# Results:
#      None.
#
# Side Effects:
#      Diagnostic information is saved.  All of the lines up to the
#      next test case are consumed.  Note: this function does not
#      increment the error count; we assume that is handled by the
#      junitSummary pattern.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------

sub junitFailure() {
    my $name = "";

    # First, scan back to find the "Testcase" line, and extract the
    # name of the test case.

    my $first = backTo('\[junit\]\s+Testcase:');
    my $line = logLine($first + $::gCurrentLine);
    if ($line =~ m/\[junit\]\s*Testcase:\s*([^\s]+)/) {
        $name = $1;

        # Now scan back even further to find the name of the test suite.

        my $offset = backTo('\[junit\]\s+Testsuite:', $first-1);
        $line = logLine($offset + $::gCurrentLine);
        if ($line =~ m/\[junit\]\s+Testsuite:.*\.([^.\s]+)/) {
            $name = $1 . "." . $name;
        }
    }

    diagnostic($name, "error", $first, forwardTo(
            q{(\[junit\] Test)|^(?!.*junit)}) - 1);
}

#-------------------------------------------------------------------------
# CONTINUE
#
#       When called from inside a matcher action, causes the matcher loop
#       to continue searching for another match.
#-------------------------------------------------------------------------

sub CONTINUE()
{
    $::gContinue = 1;
}

#-------------------------------------------------------------------------
# scanLog
#
#      Scan a single log file, executing actions for any lines that
#      match any of our matchers.
#
# Results:
#      None.
#
# Side Effects:
#      Depends on what the actions do.
#
# Arguments:
#      fileName -      Name of the log file.
#      matchers -      Array of matchers to apply to the log file.
#-------------------------------------------------------------------------

sub scanLog($@) {
    my ($fileName, @matchers) = @_;


    # Read the log file one line at a time

    my $unProcessedLine = "";
    my $processingfinalLine = 0;
    logOpen($fileName);
    LINE: while (1) {

        # Handle a final line that is not terminated by newline

        if ($processingfinalLine) {
            last;
        }

        # Get the next line
        my $line = logNext();

        # If EOF, quit or handle unterminated final line
        if (!defined($line)) {
            if (! length $unProcessedLine) {
                last;
            }
            else {
                $line = $unProcessedLine;
                $processingfinalLine = 1;
            }
        }
        if (substr($line, -1) ne "\n") {
            # This line doesn't end with a newline.  This probably means we
            # are scanning a log file that isn't yet complete, so skip this
            # line.
            if (! $processingfinalLine) {
                # Save it in case it is the final
                $unProcessedLine = $line;
                next;
            }
        }

        $unProcessedLine = "";
        chomp($line);
        debugLog("Scanning line %d: %s\n", $::gCurrentLine, $line);

        # See if this line matches one of the required patterns.  If so,
        # delete the required pattern.

        for (my $i = 0; $i < @::gRequiredPatterns; $i++) {
            if ($line =~ $::gRequiredPatterns[$i]) {
                debugLog("Required pattern\"%s\" matched current line\n",
                        $::gRequiredPatterns[$i]);
                splice(@::gRequiredPatterns, $i, 1);

                # Back up the index so that we check the next required
                # pattern; otherwise we would skip it.

                $i--;
            }
        }

        # Check the line against all of the matchers and invoke
        # actions for those that match.
        for( my $matcherCounter=0;$matcherCounter< @matchers;$matcherCounter++) {
            my $matcher = $matchers[$matcherCounter];
            my $pattern =  $matchers[$matcherCounter]->{compiledPattern} ||=  qr/$matchers[$matcherCounter]->{pattern}/;

            if ($line =~ $pattern) {
                # Make sure this line doesn't match one of the exclude
                # patterns.  We only check the exclude patterns once
                # something else matches, so in the common case where a
                # line doesn't match anything we don't waste time checking
                # against the exclude patterns.

                foreach my $exclude (@::gExcludePatterns) {
                    if ($line =~ $exclude) {
                        debugLog("    Line excluded by pattern \"%s\"\n",
                                $exclude);
                        next LINE;
                    }
                }
                debugLog("    Line matched by %s\n", $matcher->{id});
                $::gCurrentMatcher = $matcher;
                $::gContinue = 0;
                eval $matcher->{action};
                if ($@) {
                    die "error in action for matcher "
                            . "\"$matcher->{id}\": $@";
                }
                last unless $::gContinue;
            }
        }

        # See if we need to update property information on the server.

        if ($::gLiveUpdate) {
            updateServer();
        }
    }
}

#-------------------------------------------------------------------------
# getMatchers
#
#      Locate the matcher(s) corresponding to a name.
#
# Results:
#      The return value is an array containing one or more matchers.
#
# Side Effects:
#      If no matcher could be found for "name" then the application
#      exits with an error message.
#
# Arguments:
#      name -          Name of a single matcher or a matcher group.
#                      "*" means include all known matchers.
#-------------------------------------------------------------------------

sub getMatchers($);
sub getMatchers($) {
    my ($name) = @_;

    # If the name refers to a group, collect all of the matchers
    # that the group refers to.

    my ($entry, $matcher, @matchers);
    if (defined($::gMatcherGroups{$name})) {
        my $names = $::gMatcherGroups{$name};
        foreach $entry (@$names) {
            push(@matchers, getMatchers($entry));
        }
        return @matchers;
    }

    # Not a group; search the list of matchers to find a single
    # matching matcher.

    foreach $matcher (@::gMatchers) {
        if ($matcher->{"id"} eq $name) {
            return ($matcher);
        }
    }

    # Couldn't find anything matching this name.  Log an error.

    die "couldn't find matcher named \"$name\"";
}

#-------------------------------------------------------------------------
# javaToolFinalize
#-------------------------------------------------------------------------
sub javaToolFinalize($$$$$) {
    debugLog("in javaToolFinalize \n");

    my ($toolName, $toolDirName, $toolArray, $toolMatches, $toolPrefix) = @_;

    # Do we have any tool reports to copy?
    if (@$toolArray == 0) {
        debugLog("  Nothing to be done for $toolName processing in " .
                     "javaToolFinalize\n");
        return;
    }

    my $relPath = $::gJobStepJavaToolsArtifactDir;

    # strip off the artifact dir root
    my $quotedArtifactDirRoot = quotemeta($::gArtifactDirRoot);

    $relPath =~ s/$quotedArtifactDirRoot//;

    # strip off leading slashes
    $relPath =~ s&^/*&&;

    # copy everything that is in $toolArray to
    # $::gJobStepJavaToolsArtifactDir
    # set properties with the appropriate paths

    debugLog("  Processing $toolName elements in javaToolFinalize ... \n");
        # create a directory in the workspace for the output

    foreach my $element (@$toolArray) {

        # get the directory that contains element
        my($filename, $dir) = fileparse($element);

        debugLog("  full $toolName element to be copied: $element \n");
        debugLog("  filename of $toolName element: $filename \n");
        debugLog("  dir of $toolName element: $dir \n");

        # The contents of this directory has to be copied to the workspace.
        # We can't just simply copy blindly, we have to name the destination
        # directory uniquely.

        my $dest = "$::gJobStepJavaToolsArtifactDir/$toolDirName/$$toolMatches";

        $dir =~ s&\\&/&g;

        debugLog("  dest is: $dest \n");
        # rcopy should create full path to destElement
        if (rcopy($dir, $dest)) {
            debugLog("  Copied $dir to $dest \n");
        } else {
            debugLog("  Failed copying $dir to $dest: $! \n");
        }

        my $urlFrag = "$relPath/$toolDirName/$$toolMatches/$filename";

        debugLog("  urlFrag is: $urlFrag \n");
        setProperty("/myJob/report-urls/Step Id $::gStepId $::gJobStepName - $$toolPrefix report# $$toolMatches", "jobSteps/$::gStepId/$urlFrag");

        debugLog("  setProperty is: jobSteps/$::gStepId/$urlFrag \n");
        $$toolMatches++;
    }
}

#-------------------------------------------------------------------------
# javaToolsEndProcessing
#-------------------------------------------------------------------------
sub javaToolsEndProcessing() {
   debugLog("in javaToolsEndProcessing \n");

   javaToolFinalize("EMMA", "emmaCoverage", \@::gEmmaElementsToCopy, \$::gEmmaMatches, \$::gEmmaPropertyPrefix);
   javaToolFinalize("junitReport", "junitReport", \@::gJUnitElementsToCopy, \$::gJUnitMatches, \$::gJUnitPropertyPrefix);
   javaToolFinalize("clover", "clover", \@::gCloverElementsToCopy, \$::gCloverMatches, \$::gCloverPropertyPrefix);
}

#-------------------------------------------------------------------------
# postpEndHook
#
#      This function is invoked after log file processing is complete.
#      The code here does nothing: it is simply a placeholder that can
#      be redefined with a --load script.  This provides a mechanism
#      for taking custom actions at the end of postp processing.
#
# Results:
#      None.
#
# Side Effects:
#      This function returns no result, but it can be replaced with a
#      version that does virtually anything.
#
# Arguments:
#      None.
#-------------------------------------------------------------------------
sub postpEndHook() {
}

#-------------------------------------------------------------------------
# setReportUrlOrSaveForLater
#
#      Sets a report-url property for the given path and report-type
#      args if the path is in the artifacts dir; otherwise it saves
#      the path for copying later.
#
# Arguments:
#      path - path to test report file for which we want to create a report-url
#      propPrefix - distinguisher in report-url property name that makes
#           it unique relative to other test-tools' report urls.
#      matchesRef - scalar ref to counter that keeps track of the number of
#           report-urls we've created for a particular test tool.
#      elementsToCopyRef - array ref of paths that need to be copied to the
#           artifacts dir (later) in order to make report-urls, for paths
#           that don't currently exist in the artifacts dir.
#-------------------------------------------------------------------------

sub setReportUrlOrSaveForLater($$$$)
{
    my ($path, $propPrefix, $matchesRef, $elementsToCopyRef) = @_;

    chomp($path);

    $path =~ s&\\&/&g;
    if (!defined($::gArtifactDirRoot)) {
        queryServerForArtifactDirAndStepName();
    }

    my $quotedArtifactDirRoot = quotemeta($::gArtifactDirRoot);
    debugLog(" path: $path \n");
    debugLog(" quotedArtifactDirRoot is: $quotedArtifactDirRoot\n");

    # On Windows, match case insensitively to determine if the output is
    # in the artifact dir.
    if ((isWindows() && $path =~ m/^$quotedArtifactDirRoot/i) ||
            $path =~ m/^$quotedArtifactDirRoot/) {
        # The output is in the artifact dir; strip off the artifact directory
        $path = substr($path, length($::gArtifactDirRoot));

        # Strip off leading and trailing slashes.
        $path =~ s|/*$||;
        $path =~ s|^/*||;

        debugLog("  NEW path: $path \n");
        setProperty("/myJob/report-urls/Step Id $::gStepId $::gJobStepName - " .
                        "$propPrefix report# $$matchesRef",
                    "jobSteps/$::gStepId/$path");
        $$matchesRef++;

    } else {
        # Output is not in the artifact dir, need to save the locations to be
        # copied later
        debugLog("  output not in artifact dir, saving $path to copy later\n");
        push(@$elementsToCopyRef, $path);
    }
}

#-------------------------------------------------------------------------
# emmaValidateOutput
#
#-------------------------------------------------------------------------
sub emmaValidateOutput() {

    debugLog("in emmaValidateOutput\n");

    my $first =  backTo('\[java\] EMMA');

    debugLog("  first= $first\n");

    my $line = logLine($first + $::gCurrentLine);

    debugLog("  this is line: $line \n");

    if ($line =~ m/\[java\] EMMA/) {
        debugLog("  EMMA line detected \n");
        emmaExtractReport();
    } else {
        debugLog("  no EMMA line detected \n");
    }
}

#-------------------------------------------------------------------------
# emmaExtractReport
#
#-------------------------------------------------------------------------
sub emmaExtractReport() {
    debugLog("in emmaExtractReport \n");

    debugLog("  current line: $::gCurrentLine \n");

    my $message = logLine($::gCurrentLine);

    debugLog("  message: $message \n");

    # get the last occurrence of [
    my $char = '[';
    my $startIndex = rindex($message, $char);
    debugLog("  index of the last [: $startIndex \n");

    # now find the first ] after the [
    $char = ']';
    my $endIndex = index($message, $char, $startIndex);
    debugLog("  index of the closing ]: $endIndex \n");

    # add 1 to startIndex to get passed the [
    $startIndex += 1;

    # subtract 1 from endIndex so ] will not be included
    $endIndex -= 1;

    # get the length of the path
    my $length = $endIndex - $startIndex + 1;

    debugLog("  length: $length \n");
    my $path = substr $message, $startIndex, $length;

    setReportUrlOrSaveForLater($path, $::gEmmaPropertyPrefix, \$::gEmmaMatches,
                               \@::gEmmaElementsToCopy);

    $::gContinue = 1;
}

#-------------------------------------------------------------------------
# junitExtractReport
#
#-------------------------------------------------------------------------
sub junitExtractReport() {
    debugLog("in junitExtractReport \n");

    debugLog("  current line: $::gCurrentLine \n");

    my $message = logLine($::gCurrentLine);

    debugLog("  message: $message \n");

    # The message line looks like this:
    # Processing XXX to <tmpdir>
    # We want XXX.
    if ($message !~ /Processing (.*) to /) {
        debugLog("This line doesn't match the pattern 'Processing XXX to'. " .
                     "Skipping.\n");
        return;
    }
    my $path = $1;
    debugLog("   path: $path\n");

    # Ok, so $path looks something like /foo/bar/testreport/foo.xml. We want
    # to cut out the foo.xml and add index.html.

    my $lastSep = rindex($path, $::gSeparator);
    $path = File::Spec->catfile(substr($path, 0, $lastSep), "index.html");
    debugLog("   path after replacing last component: $path\n");
    setReportUrlOrSaveForLater($path, $::gJUnitPropertyPrefix,
                               \$::gJUnitMatches, \@::gJUnitElementsToCopy);
    $::gContinue = 1;
}

#-------------------------------------------------------------------------
# cloverExtractReport
#
#-------------------------------------------------------------------------
sub cloverExtractReport() {
    debugLog("in cloverExtractReport \n");

    debugLog("  current line: $::gCurrentLine \n");

    my $message = logLine($::gCurrentLine);

    debugLog("  message: $message \n");

    # split the message and grab the last word
    if ($message !~ /'(.*)'/) {
        debugLog("The line doesn't have a single-quoted path, as expected! Skipping.\n");
        return;
    }
    my $path = $1;
    debugLog("  path: $path\n");

    # add index.html to $path.
    $path = File::Spec->catfile($path, "index.html");

    debugLog("  FINAL path: $path\n");

    setReportUrlOrSaveForLater($path, $::gCloverPropertyPrefix,
                               \$::gCloverMatches, \@::gCloverElementsToCopy);

    $::gContinue = 1;
}

#-------------------------------------------------------------------------
# getPropertyArtifactDirectory
#-------------------------------------------------------------------------
sub getPropertyArtifactDirectory($) {

    debugLog("in getPropertyArtifactDirectory\n");

    my ($prop) = @_;

    my $xpath;
    my $dir;

    $xpath = $::gCommander->getProperty($prop,
                {"jobStepId" => $::gStepId});

    my $ptest = $xpath->findvalue('/responses/response/property/propertyId');

    if (!$ptest) {
        debugLog("$prop does not exist \n");
        return (undef, "");
    }

    debugLog("$prop exists, value is $ptest \n");

    $dir = $xpath->findvalue('/responses/response/property/value');
    $dir = $dir->value();

    return (1, $dir);

}

#-------------------------------------------------------------------------
# queryServerForArtifactDirAndStepName - use batch api
#-------------------------------------------------------------------------
sub queryServerForArtifactDirAndStepName() {

    debugLog("in queryServerForArtifactDirAndStepName\n");

    if ($::gCommander->{protocolVersion} eq '2.0') {
        return queryServerForArtifactDirAndStepName_20();
    }

    # Use the batch api to check for an 'artifactsDirectory' property
    # in a few places, and find the job step name while we're at it.
    my $batch = $::gCommander->newBatch();
    my %reqs = ();
    foreach my $propName ("/myJob/artifactsDirectory",
                          "/myProject/artifactsDirectory",
                          "/server/settings/artifactsDirectory",
                          "stepName") {
        $reqs{$propName} = $batch->getProperty($propName,
                                               {jobStepId => $::gStepId});
    }

    my $xpath = $batch->submit();

    # Set the jobstep name global first.. it's easy!
    my $stepName = $batch->findvalue($reqs{"stepName"}, "property/value")
        ->value();

    # Ok, now get the artifacts dir from one of the other three properties.
    my $dir = undef;
    foreach my $propName ("/myJob/artifactsDirectory",
                          "/myProject/artifactsDirectory",
                          "/server/settings/artifactsDirectory") {
        if ($xpath->exists("property/value", $batch->find($reqs{$propName}))) {
            # Found one!
            $dir = $batch->findvalue($reqs{$propName},
                                     "property/value")->value();
            last;
        } else {
            debugLog("Didn't find prop $propName: " .
                         $batch->findvalue($reqs{$propName}, "code")->value() .
                             "\n");
        }
    }

    # If none of the artifactsDirectory properties returned a value,
    # default to 'artifacts'.
    if (!defined($dir)) {
        debugLog(qq(Defaulting artifact dir to "artifacts"\n));
        $dir = "artifacts";
    }
    updateArtifactGlobals($dir, $stepName);
}

#-------------------------------------------------------------------------
# queryServerForArtifactDirAndStepName_20 - old server protocol, no batch.
#-------------------------------------------------------------------------
sub queryServerForArtifactDirAndStepName_20()
{
    my $exists;
    my $dir;
    my $prop = "/myJob/artifactsDirectory";

    ($exists, $dir) = &getPropertyArtifactDirectory($prop);

    if (!$exists) {
        debugLog("$prop not set, trying another property\n");

        $prop = "/myProject/artifactsDirectory";

        ($exists, $dir) = &getPropertyArtifactDirectory($prop);

        if (!$exists) {
            debugLog("$prop not set, trying another property\n");

            $prop = "/server/settings/artifactsDirectory";

            ($exists, $dir) = &getPropertyArtifactDirectory($prop);

            if (!$exists) {
                debugLog("$prop not set, using artifacts as the default\n");

                # if we get here, it means artifactsDirectory has not been set,
                # so use the default, "artifacts"
                $dir = "artifacts";
            }
        }
    }

    debugLog("relative artifact directory is: $dir \n");

    # Find the step name.
    my $xpath = $::gCommander->getProperty("stepName",
                                           {"jobStepId" => $::gStepId});
    my $stepName = $xpath->findvalue('//value')->value();

    updateArtifactGlobals($dir, $stepName);
}

#-------------------------------------------------------------------------
# updateArtifactGlobals
#
# Update artifact-dir-related global vars based on the given relative
# artifact-dir.
#-------------------------------------------------------------------------

sub updateArtifactGlobals($$) {
    my ($dir, $stepName) = @_;
    my $curDir = cwd;

    debugLog("this is cwd: $curDir \n");

    # The various dir globals set here should be slash-delimited regardless
    # of platform.

    $::gArtifactDirRoot = File::Spec->rel2abs($dir);
    $::gArtifactDirRoot =~ s&\\&/&g;

    debugLog("full path to artifact directory is: $::gArtifactDirRoot \n");

    $::gJobStepJavaToolsArtifactDir = File::Spec->catfile($::gArtifactDirRoot,
                                                          "javaTools",
                                                          $::gStepId);
    $::gJobStepJavaToolsArtifactDir =~ s&\\&/&g;

    debugLog("full path to jobStepJavaToolsArifactsDir: " .
                 "$::gJobStepJavaToolsArtifactDir\n");

    $::gJobStepName = $stepName;
}

#-------------------------------------------------------------------------
# main
#
#      Main program for the application.
#-------------------------------------------------------------------------

sub main() {

    my $message;
    $::gCharEncoding = ElectricCommander::getLocaleString();
    if (isWindows()) {
        $::gSeparator = '\\';
    }

    # Parse command line arguments into global variables.

    if ($ENV{COMMANDER_JOBSTEPID}) {
        $::gStepId = $ENV{COMMANDER_JOBSTEPID};
    }
    if ($ENV{COMMANDER_WORKSPACE}) {
        $::gDiagFileDir = $ENV{COMMANDER_WORKSPACE};
    }
    if (!GetOptions(%gOptions)) {
        print $::gHelpMessage;
        exit(1);
    }

    # Set up the debug log, if requested.

    if ($::gDebugLog ne "") {
        my $handle;
        open($handle, "> $::gDebugLog")
                or die "couldn't open debug log file \"$::gDebugLog\": $!";
        $::gDebugLogHandle = $handle;

        # Make this file-handle "hot", making it auto-flush after every line.
        my $ofh = select $handle;
        $| = 1;
        select $ofh;

        debugLog("Postp starting\n");
    }

    # Load additional Perl scripts, if requested.  Check in all of the
    # directories in the PATH environment variable, unless the file name
    # contains a "/" or "\".

    foreach my $file (@::gLoadFiles) {
        debugLog("About to load file $file\n");
        my $actualName;
        my ($vol, $dir, $name) = File::Spec->splitpath($file);
        if ($vol ne "" || $dir ne "") {
            # Note that we must convert the file name to an absolute path
            # before passing it to the 'do' function because Perl looks along
            # the @INC path instead of looking in the current directory unless
            # the path is absolute.

            $actualName = File::Spec->rel2abs($file);
        } else {
            my $found = 0;
            foreach my $directory (File::Spec->path()) {
                $actualName = File::Spec->catfile($directory, $file);
                if (-e $actualName) {
                    $found = 1;
                    last;
                }
            }
            if (!$found) {
                die "Couldn't find \"$file\" in any of the directories "
                        . "in the PATH environment variable"
            }
        }
        if (!(do $actualName)) {
            $message = $@;
            if (!$message) {
                # If the file isn't found no message is left in $@,
                # but there is a message in $!.

                $message = "Can't read file \"$file\": " . lcfirst($!);
            }
            die $message;
        }
    }

    foreach my $propertyName (@::gLoadProperties) {
        debugLog("About to load property $propertyName\n");
        if ($::gStepId eq "") {
            print "Must either specify --jobStepId or provide "
                    . "COMMANDER_JOBSTEPID environment variable\n";
            exit(1);
        }
        my $xpath = $::gCommander->getProperty($propertyName,
                {"jobStepId" => $::gStepId});
        $message = $::gCommander->checkAllErrors($xpath);
        if ($message ne "") {
            die "error fetching property \"$propertyName\" from "
                    . "server: $message";
        }
        my $value = $xpath->findvalue('/responses/response/property/value');
        $value = $value->value();
        eval $value;
        if ($@) {
            die "error in loaded property \"$propertyName\": $@";
        }
    }

    if ($::gHelp) {
        print $::gHelpMessage;
        exit(0);
    }

    if ($::gVersion) {
        print "$gBanner";
        exit(0);
    }
    
    if ($::gWarningsAsInfo) {
      $::gWarningsAsInfo = 1;
    }

    if (@ARGV >1) {
        shift(@ARGV);
        printf ("Extra arguments: % s\n", join(" ", @ARGV));
        print $::gHelpMessage;
        exit(1);
    }
    if (!$::gSkipUpdates && $::gStepId eq "") {
        print "Must either specify --jobStepId or provide COMMANDER_JOBSTEPID "
                . "environment variable\n";
        exit(1);
    }
    if (!$::gDiagFile) {
        $::gDiagFile = "diag-$::gStepId.xml";
    }

    # Set extra properties, if requested.

    foreach my $property (@::gExtraProperties) {
        if ($property =~ m/([^=]*)=(.*)/) {
            setProperty($1, $2);
        } else {
            print "Bad value \"$property\" for --property option: "
                    . "must be name=value\n";
            exit (1);
        }
    }

    # Figure out which matchers we will use.

    my $name;
    if ($::gCheck eq "") {
        @::gSelectedMatchers = @::gMatchers;
    } else {
        foreach $name (split(",", $::gCheck)) {
            push(@::gSelectedMatchers, getMatchers($name));
        }
    }
    if ($::gDontCheck ne "") {
        # Generate a hash whose keys represent the names of all the
        # matchers we should not use.

        my %skip = ();
        foreach $name (split(",", $::gDontCheck)) {
            if (defined($::gMatcherGroups{$name})) {
                my $names = $::gMatcherGroups{$name};
                foreach my $name2 (@$names) {
                    $skip{$name2} = 1;
                }
            } else {
                $skip{$name} = 1;
            }
        }

        # Filter the list of matchers to remove all of those
        # named by the --dontCheck option.

        my @newMatchers = ();
        foreach my $matcher (@::gSelectedMatchers) {
            if (!$skip{$matcher->{"id"}}) {
                push(@newMatchers, $matcher);
            }
        }
        @::gSelectedMatchers = @newMatchers;
    }

    # set up job step name
    if ($::gStepId eq "") {
        print "Must either specify --jobStepId or provide "
            . "COMMANDER_JOBSTEPID environment variable\n";
        exit(1);
    }
    debugLog("step-id: $::gStepId\n");

    if ($::gSkipUpdates) {
        # 'skipUpdates' is on, meaning we're testing.  The artifacts
        # dir should just be 'artifacts' then.

        if (!defined($::gArtifactDirRoot)) {
            updateArtifactGlobals("artifacts", "");
        }
    }

    # Scan the log file.

    $::gLastUpdateTime = time();
    setProperty('charEncoding', $::gCharEncoding);
    scanLog($ARGV[0], @::gSelectedMatchers);

    # Make sure that all of the required patterns were matched.

    if (@::gRequiredPatterns > 0) {
        $message = "Log file is incomplete:";
        foreach my $pattern (@::gRequiredPatterns) {
            $message .= "\n    No line matched the pattern \"$pattern\"";
        }
        incValue("errors");
        writeDiagnostic("", "logIncomplete", "error", "",
                $::gCurrentLine, 1, $message);
    }
    updateOutcome();
    
    # if the WarningsAsInfo flag is set, then add a post-summary that 
    # indicates the number of benignWarnings found. Note that this code
    # is intentionally inserted just before the postpEndHook so that the 
    # EndHook can override the post-summary if desired.
    if($::gWarningsAsInfo){
      setProperty("postSummary",$::gProperties{"benignWarnings"} . " benign warnings");
    }
    
  

    javaToolsEndProcessing();
    postpEndHook();

    # Force one final update of the properties on the server.

    $::gUrgentPropertyChange = 1;
    updateServer();

    # Print the properties on standard output also if requested.

    if ($::gPrintUpdates) {
        print propertyUpdateRequest(0);
    }

    if ($::gDebugLog ne "") {
        debugLog("Postp finished\n");
        close($::gDebugLogHandle);
    }

    my $foo = $::gUpdateDelaySeconds + $::gLastUpdateTime;
}

main();
