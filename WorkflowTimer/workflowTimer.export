<?xml version="1.0" encoding="UTF-8"?>
<exportedData xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="commander.xsd" version="55" buildLabel="build_4.1_50466_2012.05.09_07:40:31" buildVersion="4.1.0.50466" passkey="1a4bf23cbae2b9cdda9df148b44f628713080809">
  <exportPath>/projects/workflowTimer</exportPath>
  <project>
    <projectName>workflowTimer</projectName>
    <description>&lt;html&gt;&lt;b&gt;Workflow Timer&lt;/b&gt; - a library project to support and manage timed workflow transitions&lt;/html&gt;&#10;</description>
    <resourceName>local</resourceName>
    <workspaceName>default</workspaceName>
    <propertySheet>
      <property>
        <propertyName>Manip.pm</propertyName>
        <expandable>1</expandable>
        <value>package Date::Manip;&#10;# Copyright (c) 1995-2008 Sullivan Beck.  All rights reserved.&#10;# This program is free software; you can redistribute it and/or modify it&#10;# under the same terms as Perl itself.&#10;&#10;###########################################################################&#10;###########################################################################&#10;&#10;use warnings;&#10;&#10;use vars qw($OS %Lang %Holiday %Events %Curr %Cnf %Zone $VERSION @ISA @EXPORT);&#10;&#10;# Determine the type of OS...&#10;$OS="Unix";&#10;$OS="Windows"  if ((defined $^O and&#10;                    $^O =~ /MSWin32/i ||&#10;                    $^O =~ /Windows_95/i ||&#10;                    $^O =~ /Windows_NT/i) ||&#10;                   (defined $ENV{OS} and&#10;                    $ENV{OS} =~ /MSWin32/i ||&#10;                    $ENV{OS} =~ /Windows_95/i ||&#10;                    $ENV{OS} =~ /Windows_NT/i));&#10;$OS="Unix"     if (defined $^O and&#10;                   $^O =~ /cygwin/i);&#10;$OS="Netware"  if (defined $^O and&#10;                   $^O =~ /NetWare/i);&#10;$OS="Mac"      if ((defined $^O and&#10;                    $^O =~ /MacOS/i) ||&#10;                   (defined $ENV{OS} and&#10;                    $ENV{OS} =~ /MacOS/i));&#10;$OS="MPE"      if (defined $^O and&#10;                   $^O =~ /MPE/i);&#10;$OS="OS2"      if (defined $^O and&#10;                   $^O =~ /os2/i);&#10;$OS="VMS"      if (defined $^O and&#10;                   $^O =~ /VMS/i);&#10;$OS="AIX"      if (defined $^O and&#10;                   $^O =~ /aix/i);&#10;&#10;# Determine if we're doing taint checking&#10;$Date::Manip::NoTaint = eval { local $^W=0; eval("#" . substr($^X, 0, 0)); 1 };&#10;&#10;###########################################################################&#10;# CUSTOMIZATION&#10;###########################################################################&#10;#&#10;# See the section of the POD documentation section CUSTOMIZING DATE::MANIP&#10;# below for a complete description of each of these variables.&#10;&#10;&#10;# Location of a the global config file.  Tilde (~) expansions are allowed.&#10;# This should be set in Date_Init arguments.&#10;$Cnf{"GlobalCnf"}="";&#10;$Cnf{"IgnoreGlobalCnf"}="";&#10;&#10;# Name of a personal config file and the path to search for it.  Tilde (~)&#10;# expansions are allowed.  This should be set in Date_Init arguments or in&#10;# the global config file.&#10;&#10;@Date::Manip::DatePath=();&#10;if ($OS eq "Windows") {&#10;  $Cnf{"PathSep"}         = ";";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".";&#10;&#10;} elsif ($OS eq "Netware") {&#10;  $Cnf{"PathSep"}         = ";";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".";&#10;&#10;} elsif ($OS eq "MPE") {&#10;  $Cnf{"PathSep"}         = ":";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".";&#10;&#10;} elsif ($OS eq "OS2") {&#10;  $Cnf{"PathSep"}         = ":";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".";&#10;&#10;} elsif ($OS eq "Mac") {&#10;  $Cnf{"PathSep"}         = ":";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".";&#10;&#10;} elsif ($OS eq "VMS") {&#10;  # VMS doesn't like files starting with "."&#10;  $Cnf{"PathSep"}         = ",";&#10;  $Cnf{"PersonalCnf"}     = "Manip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = "/sys\$login";&#10;&#10;} else {&#10;  # Unix&#10;  $Cnf{"PathSep"}         = ":";&#10;  $Cnf{"PersonalCnf"}     = ".DateManip.cnf";&#10;  $Cnf{"PersonalCnfPath"} = ".:~";&#10;  @Date::Manip::DatePath=qw(/bin /usr/bin /usr/local/bin);&#10;}&#10;&#10;### Date::Manip variables set in the global or personal config file&#10;&#10;# Which language to use when parsing dates.&#10;$Cnf{"Language"}="English";&#10;&#10;# 12/10 = Dec 10 (US) or Oct 12 (anything else)&#10;$Cnf{"DateFormat"}="US";&#10;&#10;# Local timezone&#10;$Cnf{"TZ"}="";&#10;&#10;# Timezone to work in (""=local, "IGNORE", or a timezone)&#10;$Cnf{"ConvTZ"}="";&#10;&#10;# Date::Manip internal format (0=YYYYMMDDHH:MN:SS, 1=YYYYHHMMDDHHMNSS)&#10;$Cnf{"Internal"}=0;&#10;&#10;# First day of the week (1=monday, 7=sunday).  ISO 8601 says monday.&#10;$Cnf{"FirstDay"}=1;&#10;&#10;# First and last day of the work week  (1=monday, 7=sunday)&#10;$Cnf{"WorkWeekBeg"}=1;&#10;$Cnf{"WorkWeekEnd"}=5;&#10;&#10;# If non-nil, a work day is treated as 24 hours long (WorkDayBeg/WorkDayEnd&#10;# ignored)&#10;$Cnf{"WorkDay24Hr"}=0;&#10;&#10;# Start and end time of the work day (any time format allowed, seconds&#10;# ignored)&#10;$Cnf{"WorkDayBeg"}="08:00";&#10;$Cnf{"WorkDayEnd"}="17:00";&#10;&#10;# If "today" is a holiday, we look either to "tomorrow" or "yesterday" for&#10;# the nearest business day.  By default, we'll always look "tomorrow"&#10;# first.&#10;$Cnf{"TomorrowFirst"}=1;&#10;&#10;# Erase the old holidays&#10;$Cnf{"EraseHolidays"}="";&#10;&#10;# Set this to non-zero to be produce completely backwards compatible deltas&#10;$Cnf{"DeltaSigns"}=0;&#10;&#10;# If this is 0, use the ISO 8601 standard that Jan 4 is in week 1.  If 1,&#10;# make week 1 contain Jan 1.&#10;$Cnf{"Jan1Week1"}=0;&#10;&#10;# 2 digit years fall into the 100 year period given by [ CURR-N,&#10;# CURR+(99-N) ] where N is 0-99.  Default behavior is 89, but other useful&#10;# numbers might be 0 (forced to be this year or later) and 99 (forced to be&#10;# this year or earlier).  It can also be set to "c" (current century) or&#10;# "cNN" (i.e.  c18 forces the year to bet 1800-1899).  Also accepts the&#10;# form cNNNN to give the 100 year period NNNN to NNNN+99.&#10;$Cnf{"YYtoYYYY"}=89;&#10;&#10;# Set this to 1 if you want a long-running script to always update the&#10;# timezone.  This will slow Date::Manip down.  Read the POD documentation.&#10;$Cnf{"UpdateCurrTZ"}=0;&#10;&#10;# Use an international character set.&#10;$Cnf{"IntCharSet"}=0;&#10;&#10;# Use this to force the current date to be set to this:&#10;$Cnf{"ForceDate"}="";&#10;&#10;# Use this to make "today" mean "today at midnight".&#10;$Cnf{"TodayIsMidnight"}=0;&#10;&#10;###########################################################################&#10;&#10;require 5.000;&#10;require Exporter;&#10;@ISA = qw(Exporter);&#10;@EXPORT = qw(&#10;   DateManipVersion&#10;   Date_Init&#10;   ParseDateString&#10;   ParseDate&#10;   ParseRecur&#10;   Date_Cmp&#10;   DateCalc&#10;   ParseDateDelta&#10;   UnixDate&#10;   Delta_Format&#10;   Date_GetPrev&#10;   Date_GetNext&#10;   Date_SetTime&#10;   Date_SetDateField&#10;   Date_IsHoliday&#10;   Events_List&#10;&#10;   Date_DaysInMonth&#10;   Date_DayOfWeek&#10;   Date_SecsSince1970&#10;   Date_SecsSince1970GMT&#10;   Date_DaysSince1BC&#10;   Date_DayOfYear&#10;   Date_DaysInYear&#10;   Date_WeekOfYear&#10;   Date_LeapYear&#10;   Date_DaySuffix&#10;   Date_ConvTZ&#10;   Date_TimeZone&#10;   Date_IsWorkDay&#10;   Date_NextWorkDay&#10;   Date_PrevWorkDay&#10;   Date_NearestWorkDay&#10;   Date_NthDayOfYear&#10;);&#10;use strict;&#10;use integer;&#10;use Carp;&#10;&#10;use IO::File;&#10;&#10;$VERSION="5.54";&#10;&#10;########################################################################&#10;########################################################################&#10;&#10;$Curr{"InitLang"}      = 1;     # Whether a language is being init'ed&#10;$Curr{"InitDone"}      = 0;     # Whether Init_Date has been called&#10;$Curr{"InitFilesRead"} = 0;&#10;$Curr{"ResetWorkDay"}  = 1;&#10;$Curr{"Debug"}         = "";&#10;$Curr{"DebugVal"}      = "";&#10;&#10;$Holiday{"year"}       = 0;&#10;$Holiday{"dates"}      = {};&#10;$Holiday{"desc"}       = {};&#10;&#10;$Events{"raw"}         = [];&#10;$Events{"parsed"}      = 0;&#10;$Events{"dates"}       = [];&#10;$Events{"recur"}       = [];&#10;&#10;########################################################################&#10;########################################################################&#10;# THESE ARE THE MAIN ROUTINES&#10;########################################################################&#10;########################################################################&#10;&#10;# Get rid of a problem with old versions of perl&#10;no strict "vars";&#10;# This sorts from longest to shortest element&#10;sub _sortByLength {&#10;  return (length $b &lt;=&gt; length $a);&#10;}&#10;use strict "vars";&#10;&#10;sub DateManipVersion {&#10;  print "DEBUG: DateManipVersion\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  return $VERSION;&#10;}&#10;&#10;sub Date_Init {&#10;  print "DEBUG: Date_Init\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  $Curr{"Debug"}="";&#10;&#10;  my(@args)=@_;&#10;  $Curr{"InitDone"}=1;&#10;  local($_)=();&#10;  my($internal,$firstday)=();&#10;  my($var,$val,$file,@tmp)=();&#10;&#10;  # InitFilesRead = 0    : no conf files read yet&#10;  #                 1    : global read, no personal read&#10;  #                 2    : personal read&#10;&#10;  $Cnf{"EraseHolidays"}=0;&#10;  foreach (@args) {&#10;    s/\s*$//;&#10;    s/^\s*//;&#10;    /^(\S+) \s* = \s* (.*)$/x;&#10;    ($var,$val)=($1,$2);&#10;    if ($var =~ /^GlobalCnf$/i) {&#10;      $Cnf{"GlobalCnf"}=$val;&#10;      if ($val) {&#10;        $Curr{"InitFilesRead"}=0;&#10;        EraseHolidays();&#10;      }&#10;    } elsif ($var =~ /^PathSep$/i) {&#10;      $Cnf{"PathSep"}=$val;&#10;    } elsif ($var =~ /^PersonalCnf$/i) {&#10;      $Cnf{"PersonalCnf"}=$val;&#10;      $Curr{"InitFilesRead"}=1  if ($Curr{"InitFilesRead"}==2);&#10;    } elsif ($var =~ /^PersonalCnfPath$/i) {&#10;      $Cnf{"PersonalCnfPath"}=$val;&#10;      $Curr{"InitFilesRead"}=1  if ($Curr{"InitFilesRead"}==2);&#10;    } elsif ($var =~ /^IgnoreGlobalCnf$/i) {&#10;      $Curr{"InitFilesRead"}=1  if ($Curr{"InitFilesRead"}==0);&#10;      $Cnf{"IgnoreGlobalCnf"}=1;&#10;    } elsif ($var =~ /^EraseHolidays$/i) {&#10;      EraseHolidays();&#10;    } else {&#10;      push(@tmp,$_);&#10;    }&#10;  }&#10;  @args=@tmp;&#10;&#10;  # Read global config file&#10;  if ($Curr{"InitFilesRead"}&lt;1  &amp;&amp;  ! $Cnf{"IgnoreGlobalCnf"}) {&#10;    $Curr{"InitFilesRead"}=1;&#10;&#10;    if ($Cnf{"GlobalCnf"}) {&#10;      $file=_ExpandTilde($Cnf{"GlobalCnf"});&#10;      _Date_InitFile($file)  if ($file);&#10;    }&#10;  }&#10;&#10;  # Read personal config file&#10;  if ($Curr{"InitFilesRead"}&lt;2) {&#10;    $Curr{"InitFilesRead"}=2;&#10;&#10;    if ($Cnf{"PersonalCnf"}  and  $Cnf{"PersonalCnfPath"}) {&#10;      $file=_SearchPath($Cnf{"PersonalCnf"},$Cnf{"PersonalCnfPath"},"r");&#10;      _Date_InitFile($file)  if ($file);&#10;    }&#10;  }&#10;&#10;  foreach (@args) {&#10;    s/\s*$//;&#10;    s/^\s*//;&#10;    /^(\S+) \s* = \s* (.*)$/x;&#10;    ($var,$val)=($1,$2);&#10;    $val=""  if (! defined $val);&#10;    _Date_SetConfigVariable($var,$val);&#10;  }&#10;&#10;  confess "ERROR: Unknown FirstDay in Date::Manip.\n"&#10;    if (! _IsInt($Cnf{"FirstDay"},1,7));&#10;  confess "ERROR: Unknown WorkWeekBeg in Date::Manip.\n"&#10;    if (! _IsInt($Cnf{"WorkWeekBeg"},1,7));&#10;  confess "ERROR: Unknown WorkWeekEnd in Date::Manip.\n"&#10;    if (! _IsInt($Cnf{"WorkWeekEnd"},1,7));&#10;  confess "ERROR: Invalid WorkWeek in Date::Manip.\n"&#10;    if ($Cnf{"WorkWeekEnd"} &lt;= $Cnf{"WorkWeekBeg"});&#10;&#10;  my(%lang,&#10;     $tmp,%tmp,$tmp2,@tmp2,&#10;     $i,$j,@tmp3,&#10;     $zonesrfc,@zones)=();&#10;&#10;  my($L)=$Cnf{"Language"};&#10;&#10;  if ($Curr{"InitLang"}) {&#10;    $Curr{"InitLang"}=0;&#10;&#10;    if ($L eq "English") {&#10;      _Date_Init_English(\%lang);&#10;&#10;    } elsif ($L eq "French") {&#10;      _Date_Init_French(\%lang);&#10;&#10;    } elsif ($L eq "Swedish") {&#10;      _Date_Init_Swedish(\%lang);&#10;&#10;    } elsif ($L eq "German") {&#10;      _Date_Init_German(\%lang);&#10;&#10;    } elsif ($L eq "Polish") {&#10;      _Date_Init_Polish(\%lang);&#10;&#10;    } elsif ($L eq "Dutch"  ||&#10;             $L eq "Nederlands") {&#10;      _Date_Init_Dutch(\%lang);&#10;&#10;    } elsif ($L eq "Spanish") {&#10;      _Date_Init_Spanish(\%lang);&#10;&#10;    } elsif ($L eq "Portuguese") {&#10;      _Date_Init_Portuguese(\%lang);&#10;&#10;    } elsif ($L eq "Romanian") {&#10;      _Date_Init_Romanian(\%lang);&#10;&#10;    } elsif ($L eq "Italian") {&#10;      _Date_Init_Italian(\%lang);&#10;&#10;    } elsif ($L eq "Russian") {&#10;      _Date_Init_Russian(\%lang);&#10;&#10;    } elsif ($L eq "Turkish") {&#10;      _Date_Init_Turkish(\%lang);&#10;&#10;    } elsif ($L eq "Danish") {&#10;      _Date_Init_Danish(\%lang);&#10;&#10;    } elsif ($L eq "Catalan") {&#10;      _Date_Init_Catalan(\%lang);&#10;&#10;    } else {&#10;      confess "ERROR: Unknown language in Date::Manip.\n";&#10;    }&#10;&#10;    #  variables for months&#10;    #   Month   = "(jan|january|feb|february ... )"&#10;    #   MonL    = [ "Jan","Feb",... ]&#10;    #   MonthL  = [ "January","February", ... ]&#10;    #   MonthH  = { "january"=&gt;1, "jan"=&gt;1, ... }&#10;&#10;    $Lang{$L}{"MonthH"}={};&#10;    $Lang{$L}{"MonthL"}=[];&#10;    $Lang{$L}{"MonL"}=[];&#10;    _Date_InitLists([$lang{"month_name"},&#10;                     $lang{"month_abb"}],&#10;                    \$Lang{$L}{"Month"},"lc,sort,back",&#10;                    [$Lang{$L}{"MonthL"},&#10;                     $Lang{$L}{"MonL"}],&#10;                    [$Lang{$L}{"MonthH"},1]);&#10;&#10;    #  variables for day of week&#10;    #   Week   = "(mon|monday|tue|tuesday ... )"&#10;    #   WL     = [ "M","T",... ]&#10;    #   WkL    = [ "Mon","Tue",... ]&#10;    #   WeekL  = [ "Monday","Tudesday",... ]&#10;    #   WeekH  = { "monday"=&gt;1,"mon"=&gt;1,"m"=&gt;1,... }&#10;&#10;    $Lang{$L}{"WeekH"}={};&#10;    $Lang{$L}{"WeekL"}=[];&#10;    $Lang{$L}{"WkL"}=[];&#10;    $Lang{$L}{"WL"}=[];&#10;    _Date_InitLists([$lang{"day_name"},&#10;                     $lang{"day_abb"}],&#10;                    \$Lang{$L}{"Week"},"lc,sort,back",&#10;                    [$Lang{$L}{"WeekL"},&#10;                     $Lang{$L}{"WkL"}],&#10;                    [$Lang{$L}{"WeekH"},1]);&#10;    _Date_InitLists([$lang{"day_char"}],&#10;                    "","lc",&#10;                    [$Lang{$L}{"WL"}],&#10;                    [\%tmp,1]);&#10;    %{ $Lang{$L}{"WeekH"} } =&#10;      (%{ $Lang{$L}{"WeekH"} },%tmp);&#10;&#10;    #  variables for last&#10;    #   Last      = "(last)"&#10;    #   LastL     = [ "last" ]&#10;    #   Each      = "(each)"&#10;    #   EachL     = [ "each" ]&#10;    #  variables for day of month&#10;    #   DoM       = "(1st|first ... 31st)"&#10;    #   DoML      = [ "1st","2nd",... "31st" ]&#10;    #   DoMH      = { "1st"=&gt;1,"first"=&gt;1, ... "31st"=&gt;31 }&#10;    #  variables for week of month&#10;    #   WoM       = "(1st|first| ... 5th|last)"&#10;    #   WoMH      = { "1st"=&gt;1, ... "5th"=&gt;5,"last"=&gt;-1 }&#10;&#10;    $Lang{$L}{"LastL"}=$lang{"last"};&#10;    _Date_InitStrings($lang{"last"},&#10;                      \$Lang{$L}{"Last"},"lc,sort");&#10;&#10;    $Lang{$L}{"EachL"}=$lang{"each"};&#10;    _Date_InitStrings($lang{"each"},&#10;                      \$Lang{$L}{"Each"},"lc,sort");&#10;&#10;    $Lang{$L}{"DoMH"}={};&#10;    $Lang{$L}{"DoML"}=[];&#10;    _Date_InitLists([$lang{"num_suff"},&#10;                     $lang{"num_word"}],&#10;                    \$Lang{$L}{"DoM"},"lc,sort,back,escape",&#10;                    [$Lang{$L}{"DoML"},&#10;                     \@tmp],&#10;                    [$Lang{$L}{"DoMH"},1]);&#10;&#10;    @tmp=();&#10;    foreach $tmp (keys %{ $Lang{$L}{"DoMH"} }) {&#10;      $tmp2=$Lang{$L}{"DoMH"}{$tmp};&#10;      if ($tmp2&lt;6) {&#10;        $Lang{$L}{"WoMH"}{$tmp} = $tmp2;&#10;        push(@tmp,$tmp);&#10;      }&#10;    }&#10;    foreach $tmp (@{ $Lang{$L}{"LastL"} }) {&#10;      $Lang{$L}{"WoMH"}{$tmp} = -1;&#10;      push(@tmp,$tmp);&#10;    }&#10;    _Date_InitStrings(\@tmp,\$Lang{$L}{"WoM"},&#10;                      "lc,sort,back,escape");&#10;&#10;    #  variables for AM or PM&#10;    #   AM      = "(am)"&#10;    #   PM      = "(pm)"&#10;    #   AmPm    = "(am|pm)"&#10;    #   AMstr   = "AM"&#10;    #   PMstr   = "PM"&#10;&#10;    _Date_InitStrings($lang{"am"},\$Lang{$L}{"AM"},"lc,sort,escape");&#10;    _Date_InitStrings($lang{"pm"},\$Lang{$L}{"PM"},"lc,sort,escape");&#10;    _Date_InitStrings([ @{$lang{"am"}},@{$lang{"pm"}} ],\$Lang{$L}{"AmPm"},&#10;                      "lc,back,sort,escape");&#10;    $Lang{$L}{"AMstr"}=$lang{"am"}[0];&#10;    $Lang{$L}{"PMstr"}=$lang{"pm"}[0];&#10;&#10;    #  variables for expressions used in parsing deltas&#10;    #    Yabb   = "(?:y|yr|year|years)"&#10;    #    Mabb   = similar for months&#10;    #    Wabb   = similar for weeks&#10;    #    Dabb   = similar for days&#10;    #    Habb   = similar for hours&#10;    #    MNabb  = similar for minutes&#10;    #    Sabb   = similar for seconds&#10;    #    Repl   = { "abb"=&gt;"replacement" }&#10;    # Whenever an abbreviation could potentially refer to two different&#10;    # strings (M standing for Minutes or Months), the abbreviation must&#10;    # be listed in Repl instead of in the appropriate Xabb values.  This&#10;    # only applies to abbreviations which are substrings of other values&#10;    # (so there is no confusion between Mn and Month).&#10;&#10;    _Date_InitStrings($lang{"years"}  ,\$Lang{$L}{"Yabb"}, "lc,sort");&#10;    _Date_InitStrings($lang{"months"} ,\$Lang{$L}{"Mabb"}, "lc,sort");&#10;    _Date_InitStrings($lang{"weeks"}  ,\$Lang{$L}{"Wabb"}, "lc,sort");&#10;    _Date_InitStrings($lang{"days"}   ,\$Lang{$L}{"Dabb"}, "lc,sort");&#10;    _Date_InitStrings($lang{"hours"}  ,\$Lang{$L}{"Habb"}, "lc,sort");&#10;    _Date_InitStrings($lang{"minutes"},\$Lang{$L}{"MNabb"},"lc,sort");&#10;    _Date_InitStrings($lang{"seconds"},\$Lang{$L}{"Sabb"}, "lc,sort");&#10;    $Lang{$L}{"Repl"}={};&#10;    _Date_InitHash($lang{"replace"},undef,"lc",$Lang{$L}{"Repl"});&#10;&#10;    #  variables for special dates that are offsets from now&#10;    #    Now      = "now"&#10;    #    Today    = "today"&#10;    #    Offset   = "(yesterday|tomorrow)"&#10;    #    OffsetH  = { "yesterday"=&gt;"-0:0:0:1:0:0:0",... ]&#10;    #    Times    = "(noon|midnight)"&#10;    #    TimesH   = { "noon"=&gt;"12:00:00","midnight"=&gt;"00:00:00" }&#10;    #    SepHM    = hour/minute separator&#10;    #    SepMS    = minute/second separator&#10;    #    SepSS    = second/fraction separator&#10;&#10;    $Lang{$L}{"TimesH"}={};&#10;    _Date_InitHash($lang{"times"},&#10;                   \$Lang{$L}{"Times"},"lc,sort,back",&#10;                   $Lang{$L}{"TimesH"});&#10;    _Date_InitStrings($lang{"now"},\$Lang{$L}{"Now"},"lc,sort");&#10;    _Date_InitStrings($lang{"today"},\$Lang{$L}{"Today"},"lc,sort");&#10;    $Lang{$L}{"OffsetH"}={};&#10;    _Date_InitHash($lang{"offset"},&#10;                   \$Lang{$L}{"Offset"},"lc,sort,back",&#10;                   $Lang{$L}{"OffsetH"});&#10;    $Lang{$L}{"SepHM"}=$lang{"sephm"};&#10;    $Lang{$L}{"SepMS"}=$lang{"sepms"};&#10;    $Lang{$L}{"SepSS"}=$lang{"sepss"};&#10;&#10;    #  variables for time zones&#10;    #    zones      = regular expression with all zone names (EST)&#10;    #    n2o        = a hash of all parsable zone names with their offsets&#10;    #    tzones     = reguar expression with all tzdata timezones (US/Eastern)&#10;    #    tz2z       = hash of all tzdata timezones to full timezone (EST#EDT)&#10;&#10;    $zonesrfc=&#10;      "idlw   -1200 ".  # International Date Line West&#10;      "nt     -1100 ".  # Nome&#10;      "hst    -1000 ".  # Hawaii Standard&#10;      "cat    -1000 ".  # Central Alaska&#10;      "ahst   -1000 ".  # Alaska-Hawaii Standard&#10;      "akst   -0900 ".  # Alaska Standard&#10;      "yst    -0900 ".  # Yukon Standard&#10;      "hdt    -0900 ".  # Hawaii Daylight&#10;      "akdt   -0800 ".  # Alaska Daylight&#10;      "ydt    -0800 ".  # Yukon Daylight&#10;      "pst    -0800 ".  # Pacific Standard&#10;      "pdt    -0700 ".  # Pacific Daylight&#10;      "mst    -0700 ".  # Mountain Standard&#10;      "mdt    -0600 ".  # Mountain Daylight&#10;      "cst    -0600 ".  # Central Standard&#10;      "cdt    -0500 ".  # Central Daylight&#10;      "est    -0500 ".  # Eastern Standard&#10;      "act    -0500 ".  # Brazil, Acre&#10;      "pet    -0500 ".  # Peruvian time&#10;      "vet    -0430 ".  # Venezuela&#10;      "sat    -0400 ".  # Chile&#10;      "clt    -0400 ".  # Chile Standard&#10;      "clst   -0400 ".  # Chile Standard&#10;      "bot    -0400 ".  # Bolivia&#10;      "amt    -0400 ".  # Brazil, Amazon&#10;      "acst   -0400 ".  # Brazil, Acre Daylight&#10;      "edt    -0400 ".  # Eastern Daylight&#10;      "ast    -0400 ".  # Atlantic Standard&#10;      #"nst   -0330 ".  # Newfoundland Standard      nst=North Sumatra    +0630&#10;      "nft    -0330 ".  # Newfoundland&#10;      #"gst   -0300 ".  # Greenland Standard         gst=Guam Standard    +1000&#10;      "cldt   -0300 ".  # Chile Daylight&#10;      #"bst   -0300 ".  # Brazil Standard            bst=British Summer   +0100&#10;      "brt    -0300 ".  # Brazil Standard (official time)&#10;      #"brst   -0300 ".  # Brazil Standard&#10;      "adt    -0300 ".  # Atlantic Daylight&#10;      "art    -0300 ".  # Argentina&#10;      "arst   -0200 ".  # Argentina, Daylight&#10;      "amst   -0300 ".  # Brazil, Amazon Daylight&#10;      "uyt    -0300 ".  # Uruguay&#10;      "ndt    -0230 ".  # Newfoundland Daylight&#10;      "brst   -0200 ".  # Brazil Daylight (official time)&#10;      "fnt    -0200 ".  # Brazil, Fernando de Noronha&#10;      "at     -0200 ".  # Azores&#10;      "uyst   -0200 ".  # Uruguay&#10;      "wat    -0100 ".  # West Africa&#10;      "fnst   -0100 ".  # Brazil, Fernando de Noronha Daylight&#10;      "gmt    +0000 ".  # Greenwich Mean&#10;      "ut     +0000 ".  # Universal&#10;      "utc    +0000 ".  # Universal (Coordinated)&#10;      "wet    +0000 ".  # Western European&#10;      "cet    +0100 ".  # Central European&#10;      "fwt    +0100 ".  # French Winter&#10;      "met    +0100 ".  # Middle European&#10;      "mez    +0100 ".  # Middle European&#10;      "mewt   +0100 ".  # Middle European Winter&#10;      "swt    +0100 ".  # Swedish Winter&#10;      "bst    +0100 ".  # British Summer             bst=Brazil standard  -0300&#10;      "gb     +0100 ".  # GMT with daylight savings&#10;      "west   +0100 ".  # Western European Daylight&#10;      "eet    +0200 ".  # Eastern Europe, USSR Zone 1&#10;      "cest   +0200 ".  # Central European Summer&#10;      "fst    +0200 ".  # French Summer&#10;      "ist    +0200 ".  # Israel standard&#10;      "mest   +0200 ".  # Middle European Summer&#10;      "mesz   +0200 ".  # Middle European Summer&#10;      "metdst +0200 ".  # An alias for mest used by HP-UX&#10;      "sast   +0200 ".  # South African Standard&#10;      "sst    +0200 ".  # Swedish Summer             sst=South Sumatra    +0700&#10;      "bt     +0300 ".  # Baghdad, USSR Zone 2&#10;      "eest   +0300 ".  # Eastern Europe Summer&#10;      "eetdst +0300 ".  # An alias for eest used by HP-UX&#10;      "eetedt +0300 ".  # Eastern Europe, USSR Zone 1&#10;      "idt    +0300 ".  # Israel Daylight&#10;      "msk    +0300 ".  # Moscow&#10;      "eat    +0300 ".  # East Africa&#10;      "it     +0330 ".  # Iran&#10;      "zp4    +0400 ".  # USSR Zone 3&#10;      "msd    +0400 ".  # Moscow Daylight&#10;      "zp5    +0500 ".  # USSR Zone 4&#10;      "yekt   +0500 ".  # Yeakaterinburg time zone, Russia&#10;      "yekst  +0500 ".  # Yeakaterinburg summer time zone, Russia&#10;      "ist    +0530 ".  # Indian Standard&#10;      "zp6    +0600 ".  # USSR Zone 5&#10;      "novt   +0600 ".  # Novosibirsk winter time zone, Russia&#10;      "omst   +0600 ".  # Omsk time zone, Russia&#10;      "nst    +0630 ".  # North Sumatra              nst=Newfoundland Std -0330&#10;      #"sst   +0700 ".  # South Sumatra, USSR Zone 6 sst=Swedish Summer   +0200&#10;      "javt   +0700 ".  # Java&#10;      "ict    +0700 ".  # Indo China Time&#10;      "novst  +0700 ".  # Novosibirsk summer time zone, Russia&#10;      "krat   +0700 ".  # Krasnoyarsk, Russia&#10;      "myt    +0800 ".  # Malaysia&#10;      "hkt    +0800 ".  # Hong Kong&#10;      "sgt    +0800 ".  # Singapore&#10;      "cct    +0800 ".  # China Coast, USSR Zone 7&#10;      "krast  +0800 ".  # Krasnoyarsk, Russia Daylight&#10;      "awst   +0800 ".  # Australian Western Standard&#10;      "wst    +0800 ".  # West Australian Standard&#10;      "pht    +0800 ".  # Asia Manila&#10;      "kst    +0900 ".  # Republic of Korea&#10;      "jst    +0900 ".  # Japan Standard, USSR Zone 8&#10;      "rok    +0900 ".  # Republic of Korea&#10;      "acst   +0930 ".  # Australian Central Standard&#10;      "cast   +0930 ".  # Central Australian Standard&#10;      "aest   +1000 ".  # Australian Eastern Standard&#10;      "east   +1000 ".  # Eastern Australian Standard&#10;      "gst    +1000 ".  # Guam Standard, USSR Zone 9 gst=Greenland Std    -0300&#10;      "chst   +1000 ".  # Guam Standard, USSR Zone 9 gst=Greenland Std    -0300&#10;      "acdt   +1030 ".  # Australian Central Daylight&#10;      "cadt   +1030 ".  # Central Australian Daylight&#10;      "aedt   +1100 ".  # Australian Eastern Daylight&#10;      "eadt   +1100 ".  # Eastern Australian Daylight&#10;      "idle   +1200 ".  # International Date Line East&#10;      "nzst   +1200 ".  # New Zealand Standard&#10;      "nzt    +1200 ".  # New Zealand&#10;      "nzdt   +1300 ".  # New Zealand Daylight&#10;      "z +0000 ".&#10;      "a +0100 b +0200 c +0300 d +0400 e +0500 f +0600 g +0700 h +0800 ".&#10;      "i +0900 k +1000 l +1100 m +1200 ".&#10;      "n -0100 o -0200 p -0300 q -0400 r -0500 s -0600 t -0700 u -0800 ".&#10;      "v -0900 w -1000 x -1100 y -1200";&#10;&#10;    $Zone{"n2o"} = {};&#10;    ($Zone{"zones"},%{ $Zone{"n2o"} })=&#10;      _Date_Regexp($zonesrfc,"sort,lc,under,back",&#10;                   "keys");&#10;&#10;    $tmp=&#10;      "US/Pacific  PST8PDT ".&#10;      "US/Mountain MST7MDT ".&#10;      "US/Central  CST6CDT ".&#10;      "US/Eastern  EST5EDT ".&#10;      "Canada/Pacific  PST8PDT ".&#10;      "Canada/Mountain MST7MDT ".&#10;      "Canada/Central  CST6CDT ".&#10;      "Canada/Eastern  EST5EDT";&#10;&#10;    $Zone{"tz2z"} = {};&#10;    ($Zone{"tzones"},%{ $Zone{"tz2z"} })=&#10;      _Date_Regexp($tmp,"lc,under,back","keys");&#10;    $Cnf{"TZ"}=Date_TimeZone();&#10;&#10;    #  misc. variables&#10;    #    At     = "(?:at)"&#10;    #    Of     = "(?:in|of)"&#10;    #    On     = "(?:on)"&#10;    #    Future = "(?:in)"&#10;    #    Later  = "(?:later)"&#10;    #    Past   = "(?:ago)"&#10;    #    Next   = "(?:next)"&#10;    #    Prev   = "(?:last|previous)"&#10;&#10;    _Date_InitStrings($lang{"at"},    \$Lang{$L}{"At"},     "lc,sort");&#10;    _Date_InitStrings($lang{"on"},    \$Lang{$L}{"On"},     "lc,sort");&#10;    _Date_InitStrings($lang{"future"},\$Lang{$L}{"Future"}, "lc,sort");&#10;    _Date_InitStrings($lang{"later"}, \$Lang{$L}{"Later"},  "lc,sort");&#10;    _Date_InitStrings($lang{"past"},  \$Lang{$L}{"Past"},   "lc,sort");&#10;    _Date_InitStrings($lang{"next"},  \$Lang{$L}{"Next"},   "lc,sort");&#10;    _Date_InitStrings($lang{"prev"},  \$Lang{$L}{"Prev"},   "lc,sort");&#10;    _Date_InitStrings($lang{"of"},    \$Lang{$L}{"Of"},     "lc,sort");&#10;&#10;    #  calc mode variables&#10;    #    Approx   = "(?:approximately)"&#10;    #    Exact    = "(?:exactly)"&#10;    #    Business = "(?:business)"&#10;&#10;    _Date_InitStrings($lang{"exact"},   \$Lang{$L}{"Exact"},   "lc,sort");&#10;    _Date_InitStrings($lang{"approx"},  \$Lang{$L}{"Approx"},  "lc,sort");&#10;    _Date_InitStrings($lang{"business"},\$Lang{$L}{"Business"},"lc,sort");&#10;&#10;    ############### END OF LANGUAGE INITIALIZATION&#10;  }&#10;&#10;  if ($Curr{"ResetWorkDay"}) {&#10;    my($h1,$m1,$h2,$m2)=();&#10;    if ($Cnf{"WorkDay24Hr"}) {&#10;      ($Curr{"WDBh"},$Curr{"WDBm"})=(0,0);&#10;      ($Curr{"WDEh"},$Curr{"WDEm"})=(24,0);&#10;      $Curr{"WDlen"}=24*60;&#10;      $Cnf{"WorkDayBeg"}="00:00";&#10;      $Cnf{"WorkDayEnd"}="23:59";&#10;&#10;    } else {&#10;      confess "ERROR: Invalid WorkDayBeg in Date::Manip.\n"&#10;        if (! (($h1,$m1)=_CheckTime($Cnf{"WorkDayBeg"})));&#10;      $Cnf{"WorkDayBeg"}="$h1:$m1";&#10;      confess "ERROR: Invalid WorkDayEnd in Date::Manip.\n"&#10;        if (! (($h2,$m2)=_CheckTime($Cnf{"WorkDayEnd"})));&#10;      $Cnf{"WorkDayEnd"}="$h2:$m2";&#10;&#10;      ($Curr{"WDBh"},$Curr{"WDBm"})=($h1,$m1);&#10;      ($Curr{"WDEh"},$Curr{"WDEm"})=($h2,$m2);&#10;&#10;      # Work day length = h1:m1  or  0:len (len minutes)&#10;      $h1=$h2-$h1;&#10;      $m1=$m2-$m1;&#10;      if ($m1&lt;0) {&#10;        $h1--;&#10;        $m1+=60;&#10;      }&#10;      $Curr{"WDlen"}=$h1*60+$m1;&#10;    }&#10;    $Curr{"ResetWorkDay"}=0;&#10;  }&#10;&#10;  # current time&#10;  my($s,$mn,$h,$d,$m,$y,$wday,$yday,$isdst,$ampm,$wk)=();&#10;  if ($Cnf{"ForceDate"}=~&#10;      /^(\d{4})-(\d{2})-(\d{2})-(\d{2}):(\d{2}):(\d{2})$/) {&#10;       ($y,$m,$d,$h,$mn,$s)=($1,$2,$3,$4,$5,$6);&#10;  } else {&#10;    ($s,$mn,$h,$d,$m,$y,$wday,$yday,$isdst)=localtime(time);&#10;    $y+=1900;&#10;    $m++;&#10;  }&#10;  _Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk);&#10;  $Curr{"Y"}=$y;&#10;  $Curr{"M"}=$m;&#10;  $Curr{"D"}=$d;&#10;  $Curr{"H"}=$h;&#10;  $Curr{"Mn"}=$mn;&#10;  $Curr{"S"}=$s;&#10;  $Curr{"AmPm"}=$ampm;&#10;  $Curr{"Now"}=_Date_Join($y,$m,$d,$h,$mn,$s);&#10;  if ($Cnf{"TodayIsMidnight"}) {&#10;    $Curr{"Today"}=_Date_Join($y,$m,$d,0,0,0);&#10;  } else {&#10;    $Curr{"Today"}=$Curr{"Now"};&#10;  }&#10;&#10;  $Curr{"Debug"}=$Curr{"DebugVal"};&#10;&#10;  # If we're in array context, let's return a list of config variables&#10;  # that could be passed to Date_Init to get the same state as we're&#10;  # currently in.&#10;  if (wantarray) {&#10;    # Some special variables that have to be in a specific order&#10;    my(@special)=qw(IgnoreGlobalCnf GlobalCnf PersonalCnf PersonalCnfPath);&#10;    my(%tmp)=map { $_,1 } @special;&#10;    my(@tmp,$key,$val);&#10;    foreach $key (@special) {&#10;      $val=$Cnf{$key};&#10;      push(@tmp,"$key=$val");&#10;    }&#10;    foreach $key (keys %Cnf) {&#10;      next  if (exists $tmp{$key});&#10;      $val=$Cnf{$key};&#10;      push(@tmp,"$key=$val");&#10;    }&#10;    return @tmp;&#10;  }&#10;  return ();&#10;}&#10;&#10;sub ParseDateString {&#10;  print "DEBUG: ParseDateString\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  local($_)=@_;&#10;  return ""  if (! $_);&#10;&#10;  my($y,$m,$d,$h,$mn,$s,$i,$wofm,$dofw,$wk,$tmp,$z,$num,$err,$iso,$ampm)=();&#10;  my($date,$z2,$delta,$from,$falsefrom,$to,$which,$midnight)=();&#10;&#10;  # We only need to reinitialize if we have to determine what NOW is.&#10;  Date_Init()  if (! $Curr{"InitDone"}  or  $Cnf{"UpdateCurrTZ"});&#10;&#10;  my($L)=$Cnf{"Language"};&#10;  my($type)=$Cnf{"DateFormat"};&#10;&#10;  # Mode is set in DateCalc.  ParseDate only overrides it if the string&#10;  # contains a mode.&#10;  if      ($Lang{$L}{"Exact"}  &amp;&amp;&#10;           s/$Lang{$L}{"Exact"}//) {&#10;    $Curr{"Mode"}=0;&#10;  } elsif ($Lang{$L}{"Approx"}  &amp;&amp;&#10;           s/$Lang{$L}{"Approx"}//) {&#10;    $Curr{"Mode"}=1;&#10;  } elsif ($Lang{$L}{"Business"}  &amp;&amp;&#10;           s/$Lang{$L}{"Business"}//) {&#10;    $Curr{"Mode"}=2;&#10;  } elsif (! exists $Curr{"Mode"}) {&#10;    $Curr{"Mode"}=0;&#10;  }&#10;&#10;  # Unfortunately, some deltas can be parsed as dates.  An example is&#10;  #    1 second  ==  1 2nd  ==  1 2&#10;  # But, some dates can be parsed as deltas.  The most important being:&#10;  #    1998010101:00:00&#10;  #&#10;  # We'll check to see if a "date" can be parsed as a delta.  If so, we'll&#10;  # assume that it is a delta (since they are much simpler, it is much&#10;  # less likely that we'll mistake a delta for a date than vice versa)&#10;  # unless it is an ISO-8601 date.&#10;  #&#10;  # This is important because we are using DateCalc to test whether a&#10;  # string is a date or a delta.  Dates are tested first, so we need to&#10;  # be able to pass a delta into this routine and have it correctly NOT&#10;  # interpreted as a date.&#10;  #&#10;  # We will insist that the string contain something other than digits and&#10;  # colons so that the following will get correctly interpreted as a date&#10;  # rather than a delta:&#10;  #     12:30&#10;  #     19980101&#10;&#10;  $delta="";&#10;  $delta=ParseDateDelta($_)  if (/[^:0-9]/);&#10;&#10;  # Put parse in a simple loop for an easy exit.&#10; PARSE: {&#10;    my(@tmp)=_Date_Split($_);&#10;    if (@tmp) {&#10;      ($y,$m,$d,$h,$mn,$s)=@tmp;&#10;      last PARSE;&#10;    }&#10;&#10;    # Fundamental regular expressions&#10;&#10;    my($month)=$Lang{$L}{"Month"};          # (jan|january|...)&#10;    my(%month)=%{ $Lang{$L}{"MonthH"} };    # { jan=&gt;1, ... }&#10;    my($week)=$Lang{$L}{"Week"};            # (mon|monday|...)&#10;    my(%week)=%{ $Lang{$L}{"WeekH"} };      # { mon=&gt;1, monday=&gt;1, ... }&#10;    my($wom)=$Lang{$L}{"WoM"};              # (1st|...|fifth|last)&#10;    my(%wom)=%{ $Lang{$L}{"WoMH"} };        # { 1st=&gt;1,... fifth=&gt;5,last=&gt;-1 }&#10;    my($dom)=$Lang{$L}{"DoM"};              # (1st|first|...31st)&#10;    my(%dom)=%{ $Lang{$L}{"DoMH"} };        # { 1st=&gt;1, first=&gt;1, ... }&#10;    my($ampmexp)=$Lang{$L}{"AmPm"};         # (am|pm)&#10;    my($timeexp)=$Lang{$L}{"Times"};        # (noon|midnight)&#10;    my($now)=$Lang{$L}{"Now"};              # now&#10;    my($today)=$Lang{$L}{"Today"};          # today&#10;    my($offset)=$Lang{$L}{"Offset"};        # (yesterday|tomorrow)&#10;    my($zone)=$Zone{"zones"};               # (edt|est|...)&#10;    my($day)='\s*'.$Lang{$L}{"Dabb"};       # \s*(?:d|day|days)&#10;    my($mabb)='\s*'.$Lang{$L}{"Mabb"};      # \s*(?:mon|month|months)&#10;    my($wkabb)='\s*'.$Lang{$L}{"Wabb"};     # \s*(?:w|wk|week|weeks)&#10;    my($next)='\s*'.$Lang{$L}{"Next"};      # \s*(?:next)&#10;    my($prev)='\s*'.$Lang{$L}{"Prev"};      # \s*(?:last|previous)&#10;    my($past)='\s*'.$Lang{$L}{"Past"};      # \s*(?:ago)&#10;    my($future)='\s*'.$Lang{$L}{"Future"};  # \s*(?:in)&#10;    my($later)='\s*'.$Lang{$L}{"Later"};    # \s*(?:later)&#10;    my($at)=$Lang{$L}{"At"};                # (?:at)&#10;    my($of)='\s*'.$Lang{$L}{"Of"};          # \s*(?:in|of)&#10;    my($on)='(?:\s*'.$Lang{$L}{"On"}.'\s*|\s+)';&#10;                                            # \s*(?:on)\s*    or  \s+&#10;    my($last)='\s*'.$Lang{$L}{"Last"};      # \s*(?:last)&#10;    my($hm)=$Lang{$L}{"SepHM"};             # :&#10;    my($ms)=$Lang{$L}{"SepMS"};             # :&#10;    my($ss)=$Lang{$L}{"SepSS"};             # .&#10;&#10;    # Other regular expressions&#10;&#10;    my($D4)='(\d{4})';            	    # 4 digits      (yr)&#10;    my($YY)='(\d{4}|\d{2})';      	    # 2 or 4 digits (yr)&#10;    my($DD)='(\d{2})';            	    # 2 digits      (mon/day/hr/min/sec)&#10;    my($D) ='(\d{1,2})';          	    # 1 or 2 digit  (mon/day/hr)&#10;    my($FS)="(?:$ss\\d+)?";       	    # fractional secs&#10;    my($sep)='[\/.-]';            	    # non-ISO8601 m/d/yy separators&#10;    # absolute time zone     +0700 (GMT)&#10;    my($hzone)='(?:[0-1][0-9]|2[0-3])';     # 00 - 23&#10;    my($mzone)='(?:[0-5][0-9])';            # 00 - 59&#10;    my($zone2)='(?:\s*([+-](?:'."$hzone$mzone|$hzone:$mzone|$hzone))".&#10;                                            # +0700 +07:00 -07&#10;      '(?:\s*\([^)]+\))?)';                 # (GMT)&#10;&#10;    # A regular expression for the time EXCEPT for the hour part&#10;    my($mnsec)="$hm$DD(?:$ms$DD$FS)?(?:\\s*$ampmexp)?";&#10;&#10;    # A special regular expression for /YYYY:HH:MN:SS used by Apache&#10;    my($apachetime)='(/\d{4}):' . "$DD$hm$DD$ms$DD";&#10;&#10;    my($time)="";&#10;    $ampm="";&#10;    $date="";&#10;&#10;    # Substitute all special time expressions.&#10;    if (/(^|[^a-z])$timeexp($|[^a-z])/i) {&#10;      $tmp=$2;&#10;      $tmp=$Lang{$L}{"TimesH"}{lc($tmp)};&#10;      s/(^|[^a-z])$timeexp($|[^a-z])/$1 $tmp $3/i;&#10;    }&#10;&#10;    # Remove some punctuation&#10;    s/[,]/ /g;&#10;&#10;    # When we have a digit followed immediately by a timezone (7EST), we&#10;    # will put a space between the digit, EXCEPT in the case of a single&#10;    # character military timezone.  If the single character is followed&#10;    # by anything, no space is added.&#10;    $tmp = "";&#10;    while ( s/^(.*?\d)$zone(\s|$|[0-9])/$3/i ) {&#10;      my($bef,$z,$aft) = ($1,$2,$3);&#10;      if (length($z) != 1  ||  length($aft) == 0) {&#10;        $tmp .= "$bef $z";&#10;      } else {&#10;        $tmp .= "$bef$z";&#10;      }&#10;    }&#10;    $_ = "$tmp$_";&#10;    $zone = '\s+' . $zone . '(?:\s+|$)';&#10;&#10;    # Remove the time&#10;    $iso=1;&#10;    $midnight=0;&#10;    $from="24${hm}00(?:${ms}00)?";&#10;    $falsefrom="${hm}24${ms}00";   # Don't trap XX:24:00&#10;    $to="00${hm}00${ms}00";&#10;    $midnight=1  if (!/$falsefrom/  &amp;&amp;  s/$from/$to/);&#10;&#10;    $h=$mn=$s=0;&#10;    if (/$D$mnsec/i || /$ampmexp/i) {&#10;      $iso=0;&#10;      $tmp=0;&#10;      $tmp=1  if (/$mnsec$zone2?\s*$/i  or /$mnsec$zone\s*$/i);&#10;      $tmp=0  if (/$ampmexp/i);&#10;      if (s/$apachetime$zone()/$1 /i                            ||&#10;          s/$apachetime$zone2?/$1 /i                            ||&#10;          s/(^|[^a-z])$at\s*$D$mnsec$zone()/$1 /i               ||&#10;          s/(^|[^a-z])$at\s*$D$mnsec$zone2?/$1 /i               ||&#10;          s/(^|[^0-9])(\d)$mnsec$zone()/$1 /i                   ||&#10;          s/(^|[^0-9])(\d)$mnsec$zone2?/$1 /i                   ||&#10;          (s/(t)$D$mnsec$zone()/$1 /i and (($iso=$tmp) || 1))   ||&#10;          (s/(t)$D$mnsec$zone2?/$1 /i and (($iso=$tmp) || 1))   ||&#10;          (s/()$DD$mnsec$zone()/ /i and (($iso=$tmp) || 1))     ||&#10;          (s/()$DD$mnsec$zone2?/ /i and (($iso=$tmp) || 1))     ||&#10;          s/(^|$at\s*|\s+)$D()()\s*$ampmexp$zone()/ /i          ||&#10;          s/(^|$at\s*|\s+)$D()()\s*$ampmexp$zone2?/ /i          ||&#10;          0&#10;         ) {&#10;        ($h,$mn,$s,$ampm,$z,$z2)=($2,$3,$4,$5,$6,$7);&#10;        if (defined ($z)) {&#10;          if ($z =~ /^[+-]\d{2}:\d{2}$/) {&#10;            $z=~ s/://;&#10;          } elsif ($z =~ /^[+-]\d{2}$/) {&#10;            $z .= "00";&#10;          }&#10;        }&#10;        $time=1;&#10;        _Date_TimeCheck(\$h,\$mn,\$s,\$ampm);&#10;        $y=$m=$d="";&#10;        # We're going to be calling TimeCheck again below (when we check the&#10;        # final date), so get rid of $ampm so that we don't have an error&#10;        # due to "15:30:00 PM".  It'll get reset below.&#10;        $ampm="";&#10;        if (/^\s*$/) {&#10;          Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;          last PARSE;&#10;        }&#10;      }&#10;    }&#10;    $time=0  if ($time ne "1");&#10;    s/\s+$//;&#10;    s/^\s+//;&#10;&#10;    # if a zone was found, get rid of the regexps&#10;    if ($z) {&#10;      $zone="";&#10;      $zone2="";&#10;    }&#10;&#10;    # dateTtime ISO 8601 formats&#10;    my($orig)=$_;&#10;&#10;    # Parse ISO 8601 dates now (which may still have a zone stuck to it).&#10;    if ( ($iso &amp;&amp; /^([0-9-]+(?:W[0-9-]+)?)$zone?$/i)   ||&#10;         ($iso &amp;&amp; /^([0-9-]+(?:W[0-9-]+)?)$zone2?$/i)  ||&#10;         ($iso &amp;&amp; /^([0-9-]+(?:T[0-9-]+)?)$zone?$/i)   ||&#10;         ($iso &amp;&amp; /^([0-9-]+(?:T[0-9-]+)?)$zone2?$/i)  ||&#10;         ($iso &amp;&amp; /^([0-9-]+)T$zone?$/i)   ||&#10;         ($iso &amp;&amp; /^([0-9-]+)T$zone2?$/i)  ||&#10;         0) {&#10;&#10;      # If we already got a timezone, don't get another one.&#10;      my(@z);&#10;      if ($z) {&#10;        @z=($z,$z2);&#10;        $z="";&#10;      }&#10;      ($_,$z,$z2) = ($1,$2,$3);&#10;      ($z,$z2)=@z  if (@z);&#10;&#10;      s,([0-9])\s*-,$1 ,g; # Change all ISO8601 seps to spaces&#10;      s/^\s+//;&#10;      s/\s+$//;&#10;&#10;      if (/^$D4\s*$DD\s*$DD\s*t?$DD(?:$DD(?:$DD(\d*))?)?$/i ||&#10;          /^$DD\s+$DD\s*$DD\s*t?$DD(?:$DD(?:$DD(\d*))?)?$/i ||&#10;          0&#10;         ) {&#10;        # ISO 8601 Dates with times&#10;        #    YYYYMMDDtHHMNSSFFFF...&#10;        #    YYYYMMDDtHHMNSS&#10;        #    YYYYMMDDtHHMN&#10;        #    YYYYMMDDtHH&#10;        #    YY MMDDtHHMNSSFFFF...&#10;        #    YY MMDDtHHMNSS&#10;        #    YY MMDDtHHMN&#10;        #    YY MMDDtHH&#10;        # The t is an optional letter "t".&#10;        ($y,$m,$d,$h,$mn,$s,$tmp)=($1,$2,$3,$4,$5,$6,$7);&#10;        if ($h==24 &amp;&amp; (! defined $mn || $mn==0) &amp;&amp; (! defined $s || $s==0)) {&#10;          $h=0;&#10;          $midnight=1;&#10;        }&#10;        $z = ""    if (! defined $h);&#10;        return ""  if ($time  &amp;&amp;  defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$D4(?:\s*$DD(?:\s*$DD)?)?$/  ||&#10;               /^$DD(?:\s+$DD(?:\s*$DD)?)?$/) {&#10;        # ISO 8601 Dates&#10;        #    YYYYMMDD&#10;        #    YYYYMM&#10;        #    YYYY&#10;        #    YY MMDD&#10;        #    YY MM&#10;        #    YY&#10;        ($y,$m,$d)=($1,$2,$3);&#10;        last PARSE;&#10;&#10;      } elsif (/^$YY\s+$D\s+$D/) {&#10;        # YY-M-D&#10;        ($y,$m,$d)=($1,$2,$3);&#10;        last PARSE;&#10;&#10;      } elsif (/^$YY\s*W$DD\s*(\d)?$/i) {&#10;        # YY-W##-D&#10;        ($y,$wofm,$dofw)=($1,$2,$3);&#10;        ($y,$m,$d)=_Date_NthWeekOfYear($y,$wofm,$dofw);&#10;        last PARSE;&#10;&#10;      } elsif (/^$D4\s*(\d{3})$/ ||&#10;               /^$DD\s*(\d{3})$/) {&#10;        # YYDOY&#10;        ($y,$which)=($1,$2);&#10;        ($y,$m,$d)=Date_NthDayOfYear($y,$which);&#10;        last PARSE;&#10;&#10;      } elsif ($iso&lt;0) {&#10;        # We confused something like 1999/August12:00:00&#10;        # with a dateTtime format&#10;        $_=$orig;&#10;&#10;      } else {&#10;        return "";&#10;      }&#10;    }&#10;&#10;    # All deltas that are not ISO-8601 dates are NOT dates.&#10;    return ""  if ($Curr{"InCalc"}  &amp;&amp;  $delta);&#10;    if ($delta) {&#10;      Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;      return _DateCalc_DateDelta($Curr{"Now"},$delta);&#10;    }&#10;&#10;    # Check for some special types of dates (next, prev)&#10;    foreach $from (keys %{ $Lang{$L}{"Repl"} }) {&#10;      $to=$Lang{$L}{"Repl"}{$from};&#10;      s/(^|[^a-z])$from($|[^a-z])/$1$to$2/i;&#10;    }&#10;    if (/$wom/i  ||  /$future/i  ||  /$later/i  ||  /$past/i  ||&#10;        /$next/i  ||  /$prev/i  ||  /^$week$/i  ||  /$wkabb/i) {&#10;      $tmp=0;&#10;&#10;      if (/^$wom\s*$week$of\s*$month\s*$YY?$/i) {&#10;        # last friday in October 95&#10;        ($wofm,$dofw,$m,$y)=($1,$2,$3,$4);&#10;        # fix $m, $y&#10;        return ""  if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;        $dofw=$week{lc($dofw)};&#10;        $wofm=$wom{lc($wofm)};&#10;        # Get the first day of the month&#10;        $date=_Date_Join($y,$m,1,$h,$mn,$s);&#10;        if ($wofm==-1) {&#10;          $date=_DateCalc_DateDelta($date,"+0:1:0:0:0:0:0",\$err,0);&#10;          $date=Date_GetPrev($date,$dofw,0);&#10;        } else {&#10;          for ($i=0; $i&lt;$wofm; $i++) {&#10;            if ($i==0) {&#10;              $date=Date_GetNext($date,$dofw,1);&#10;            } else {&#10;              $date=Date_GetNext($date,$dofw,0);&#10;            }&#10;          }&#10;        }&#10;        last PARSE;&#10;&#10;      } elsif (/^$last$day$of\s*$month(?:$of?\s*$YY)?/i) {&#10;        # last day in month&#10;        ($m,$y)=($1,$2);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $y=_Date_FixYear($y)  if (! defined $y  or  length($y)&lt;4);&#10;        $m=$month{lc($m)};&#10;        $d=Date_DaysInMonth($m,$y);&#10;        last PARSE;&#10;&#10;      } elsif (/^$week$/i) {&#10;        # friday&#10;        ($dofw)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=Date_GetPrev($Curr{"Now"},$Cnf{"FirstDay"},1);&#10;        $date=Date_GetNext($date,$dofw,1,$h,$mn,$s);&#10;        last PARSE;&#10;&#10;      } elsif (/^$next\s*$week$/i) {&#10;        # next friday&#10;        ($dofw)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=Date_GetNext($Curr{"Now"},$dofw,0,$h,$mn,$s);&#10;        last PARSE;&#10;&#10;      } elsif (/^$prev\s*$week$/i) {&#10;        # last friday&#10;        ($dofw)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=Date_GetPrev($Curr{"Now"},$dofw,0,$h,$mn,$s);&#10;        last PARSE;&#10;&#10;      } elsif (/^$next$wkabb$/i) {&#10;        # next week&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"+0:0:1:0:0:0:0",\$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;      } elsif (/^$prev$wkabb$/i) {&#10;        # last week&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"-0:0:1:0:0:0:0",\$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$next$mabb$/i) {&#10;        # next month&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"+0:1:0:0:0:0:0",\$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;      } elsif (/^$prev$mabb$/i) {&#10;        # last month&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"-0:1:0:0:0:0:0",\$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$future\s*(\d+)$day$/i  ||&#10;               /^(\d+)$day$later$/i) {&#10;        # in 2 days&#10;        # 2 days later&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"+0:0:0:$num:0:0:0",&#10;                                  \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;      } elsif (/^(\d+)$day$past$/i) {&#10;        # 2 days ago&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"-0:0:0:$num:0:0:0",&#10;                                 \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$future\s*(\d+)$wkabb$/i  ||&#10;               /^(\d+)$wkabb$later$/i) {&#10;        # in 2 weeks&#10;        # 2 weeks later&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"+0:0:$num:0:0:0:0",&#10;                                  \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;      } elsif (/^(\d+)$wkabb$past$/i) {&#10;        # 2 weeks ago&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"-0:0:$num:0:0:0:0",&#10;                                 \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$future\s*(\d+)$mabb$/i  ||&#10;               /^(\d+)$mabb$later$/i) {&#10;        # in 2 months&#10;        # 2 months later&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"+0:$num:0:0:0:0:0",&#10;                                  \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;      } elsif (/^(\d+)$mabb$past$/i) {&#10;        # 2 months ago&#10;        ($num)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},"-0:$num:0:0:0:0:0",&#10;                                  \$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if (defined $h);&#10;        last PARSE;&#10;&#10;      } elsif (/^$week$future\s*(\d+)$wkabb$/i  ||&#10;               /^$week\s*(\d+)$wkabb$later$/i) {&#10;        # friday in 2 weeks&#10;        # friday 2 weeks later&#10;        ($dofw,$num)=($1,$2);&#10;        $tmp="+";&#10;      } elsif (/^$week\s*(\d+)$wkabb$past$/i) {&#10;        # friday 2 weeks ago&#10;        ($dofw,$num)=($1,$2);&#10;        $tmp="-";&#10;      } elsif (/^$future\s*(\d+)$wkabb$on$week$/i  ||&#10;               /^(\d+)$wkabb$later$on$week$/i) {&#10;        # in 2 weeks on friday&#10;        # 2 weeks later on friday&#10;        ($num,$dofw)=($1,$2);&#10;        $tmp="+"&#10;      } elsif (/^(\d+)$wkabb$past$on$week$/i) {&#10;        # 2 weeks ago on friday&#10;        ($num,$dofw)=($1,$2);&#10;        $tmp="-";&#10;      } elsif (/^$week\s*$wkabb$/i) {&#10;        # monday week    (British date: in 1 week on monday)&#10;        $dofw=$1;&#10;        $num=1;&#10;        $tmp="+";&#10;      } elsif ( (/^$now\s*$wkabb$/i   &amp;&amp;  ($tmp="Now"))  ||&#10;                (/^$today\s*$wkabb$/i &amp;&amp;  ($tmp="Today")) ) {&#10;        # now week     (British date: 1 week from now)&#10;        # today week   (British date: 1 week from today)&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{$tmp},"+0:0:1:0:0:0:0",\$err,0);&#10;        $date=Date_SetTime($date,$h,$mn,$s)  if ($time);&#10;        last PARSE;&#10;      } elsif (/^$offset\s*$wkabb$/i) {&#10;        # tomorrow week  (British date: 1 week from tomorrow)&#10;        ($offset)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $offset=$Lang{$L}{"OffsetH"}{lc($offset)};&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},$offset,\$err,0);&#10;        $date=_DateCalc_DateDelta($date,"+0:0:1:0:0:0:0",\$err,0);&#10;        if ($time) {&#10;          return ""&#10;            if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;          $date=Date_SetTime($date,$h,$mn,$s);&#10;        }&#10;        last PARSE;&#10;      }&#10;&#10;      if ($tmp) {&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},&#10;                                  $tmp . "0:0:$num:0:0:0:0",\$err,0);&#10;        $date=Date_GetPrev($date,$Cnf{"FirstDay"},1);&#10;        $date=Date_GetNext($date,$dofw,1,$h,$mn,$s);&#10;        last PARSE;&#10;      }&#10;    }&#10;&#10;    # Change (2nd, second) to 2&#10;    $tmp=0;&#10;    if (/(^|[^a-z0-9])$dom($|[^a-z0-9])/i) {&#10;      if (/^\s*$dom\s*$/) {&#10;        ($d)=($1);&#10;        $d=$dom{lc($d)};&#10;        $m=$Curr{"M"};&#10;        last PARSE;&#10;      }&#10;      my $from = $2;&#10;      my $to   = $dom{ lc($from) };&#10;      s/(^|[^a-z])$from($|[^a-z])/$1 $to $2/i;&#10;      s/^\s+//;&#10;      s/\s+$//;&#10;    }&#10;&#10;    # Another set of special dates (Nth week)&#10;    if (/^$D\s*$week(?:$of?\s*$YY)?$/i) {&#10;      # 22nd sunday in 1996&#10;      ($which,$dofw,$y)=($1,$2,$3);&#10;      $y=$Curr{"Y"}  if (! $y);&#10;      $y--; # previous year&#10;      $tmp=Date_GetNext("$y-12-31",$dofw,0);&#10;      if ($which&gt;1) {&#10;        $tmp=_DateCalc_DateDelta($tmp,"+0:0:".($which-1).":0:0:0:0",\$err,0);&#10;      }&#10;      ($y,$m,$d)=(_Date_Split($tmp, 1))[0..2];&#10;      last PARSE;&#10;    } elsif (/^$week$wkabb\s*$D(?:$of?\s*$YY)?$/i  ||&#10;             /^$week\s*$D$wkabb(?:$of?\s*$YY)?$/i) {&#10;      # sunday week 22 in 1996&#10;      # sunday 22nd week in 1996&#10;      ($dofw,$which,$y)=($1,$2,$3);&#10;      ($y,$m,$d)=_Date_NthWeekOfYear($y,$which,$dofw);&#10;      last PARSE;&#10;    }&#10;&#10;    # Get rid of day of week&#10;    if (/(^|[^a-z])$week($|[^a-z])/i) {&#10;      $wk=$2;&#10;      (s/(^|[^a-z])$week,/$1 /i) ||&#10;        s/(^|[^a-z])$week($|[^a-z])/$1 $3/i;&#10;      s/^\s+//;&#10;      s/\s+$//;&#10;    }&#10;&#10;    {&#10;      # So that we can handle negative epoch times, let's convert&#10;      # things like "epoch -" to "epochNEGATIVE " before we strip out&#10;      # the $sep chars, which include '-'.&#10;      s,epoch\s*-,epochNEGATIVE ,g;&#10;&#10;      # Non-ISO8601 dates&#10;      s,\s*$sep\s*, ,g;     # change all non-ISO8601 seps to spaces&#10;      s,^\s*,,;             # remove leading/trailing space&#10;      s,\s*$,,;&#10;&#10;      if (/^$D\s+$D(?:\s+$YY)?$/) {&#10;        # MM DD YY (DD MM YY non-US)&#10;        ($m,$d,$y)=($1,$2,$3);&#10;        ($m,$d)=($d,$m)  if ($type ne "US");&#10;        last PARSE;&#10;&#10;      } elsif (/^$D4\s*$D\s*$D$/) {&#10;        # YYYY MM DD&#10;        ($y,$m,$d)=($1,$2,$3);&#10;        last PARSE;&#10;&#10;      } elsif (s/(^|[^a-z])$month($|[^a-z])/$1 $3/i) {&#10;        ($m)=($2);&#10;&#10;        if (/^\s*$D(?:\s+$YY)?\s*$/) {&#10;          # mmm DD YY&#10;          # DD mmm YY&#10;          # DD YY mmm&#10;          ($d,$y)=($1,$2);&#10;          last PARSE;&#10;&#10;        } elsif (/^\s*$D$D4\s*$/) {&#10;          # mmm DD YYYY&#10;          # DD mmm YYYY&#10;          # DD YYYY mmm&#10;          ($d,$y)=($1,$2);&#10;          last PARSE;&#10;&#10;        } elsif (/^\s*$D4\s*$D\s*$/) {&#10;          # mmm YYYY DD&#10;          # YYYY mmm DD&#10;          # YYYY DD mmm&#10;          ($y,$d)=($1,$2);&#10;          last PARSE;&#10;&#10;        } elsif (/^\s*$D4\s*$/) {&#10;          # mmm YYYY&#10;          # YYYY mmm&#10;          ($y,$d)=($1,1);&#10;          last PARSE;&#10;&#10;        } else {&#10;          return "";&#10;        }&#10;&#10;      } elsif (/^epochNEGATIVE (\d+)$/) {&#10;        $s=$1;&#10;        $date=DateCalc("1970-01-01 00:00 GMT","-0:0:$s");&#10;      } elsif (/^epoch\s*(\d+)$/i) {&#10;        $s=$1;&#10;        $date=DateCalc("1970-01-01 00:00 GMT","+0:0:$s");&#10;&#10;      } elsif ( (/^$now$/i   &amp;&amp;  ($tmp="Now"))  ||&#10;                (/^$today$/i &amp;&amp;  ($tmp="Today")) ) {&#10;        # now, today&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $date=$Curr{$tmp};&#10;        if ($time) {&#10;          return ""&#10;            if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;          $date=Date_SetTime($date,$h,$mn,$s);&#10;        }&#10;        last PARSE;&#10;&#10;      } elsif (/^$offset$/i) {&#10;        # yesterday, tomorrow&#10;        ($offset)=($1);&#10;        Date_Init()  if (! $Cnf{"UpdateCurrTZ"});&#10;        $offset=$Lang{$L}{"OffsetH"}{lc($offset)};&#10;        $date=_DateCalc_DateDelta($Curr{"Now"},$offset,\$err,0);&#10;        if ($time) {&#10;          return ""&#10;            if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;          $date=Date_SetTime($date,$h,$mn,$s);&#10;        }&#10;        last PARSE;&#10;&#10;      } else {&#10;        return "";&#10;      }&#10;    }&#10;  }&#10;&#10;  if (! $date) {&#10;    return ""  if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;    $date=_Date_Join($y,$m,$d,$h,$mn,$s);&#10;  }&#10;  $date=Date_ConvTZ($date,$z);&#10;  if ($midnight) {&#10;    $date=_DateCalc_DateDelta($date,"+0:0:0:1:0:0:0");&#10;  }&#10;  return $date;&#10;}&#10;&#10;sub ParseDate {&#10;  print "DEBUG: ParseDate\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  my($args,@args,@a,$ref,$date)=();&#10;  @a=@_;&#10;&#10;  # @a : is the list of args to ParseDate.  Currently, only one argument&#10;  #      is allowed and it must be a scalar (or a reference to a scalar)&#10;  #      or a reference to an array.&#10;&#10;  if ($#a!=0) {&#10;    print "ERROR:  Invalid number of arguments to ParseDate.\n";&#10;    return "";&#10;  }&#10;  $args=$a[0];&#10;  $ref=ref $args;&#10;  if (! $ref) {&#10;    return $args  if (_Date_Split($args));&#10;    @args=($args);&#10;  } elsif ($ref eq "ARRAY") {&#10;    @args=@$args;&#10;  } elsif ($ref eq "SCALAR") {&#10;    return $$args  if (_Date_Split($$args));&#10;    @args=($$args);&#10;  } else {&#10;    print "ERROR:  Invalid arguments to ParseDate.\n";&#10;    return "";&#10;  }&#10;  @a=@args;&#10;&#10;  # @args : a list containing all the arguments (dereferenced if appropriate)&#10;  # @a    : a list containing all the arguments currently being examined&#10;  # $ref  : nil, "SCALAR", or "ARRAY" depending on whether a scalar, a&#10;  #         reference to a scalar, or a reference to an array was passed in&#10;  # $args : the scalar or refererence passed in&#10;&#10; PARSE: while($#a&gt;=0) {&#10;    $date=join(" ",@a);&#10;    $date=ParseDateString($date);&#10;    last  if ($date);&#10;    pop(@a);&#10;  } # PARSE&#10;&#10;  splice(@args,0,$#a + 1);&#10;  @$args= @args  if (defined $ref  and  $ref eq "ARRAY");&#10;  $date;&#10;}&#10;&#10;sub Date_Cmp {&#10;  my($D1,$D2)=@_;&#10;  my($date1)=ParseDateString($D1);&#10;  my($date2)=ParseDateString($D2);&#10;  return $date1 cmp $date2;&#10;}&#10;&#10;# **NOTE**&#10;# The calc routines all call parse routines, so it is never necessary to&#10;# call Date_Init in the calc routines.&#10;sub DateCalc {&#10;  print "DEBUG: DateCalc\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($D1,$D2,@arg)=@_;&#10;  my($ref,$err,$errref,$mode)=();&#10;&#10;  ($errref,$mode) = (@arg);&#10;  $ref=0;&#10;&#10;  if (defined $errref) {&#10;    if (ref $errref) {&#10;      $ref=1;&#10;    } elsif (! defined $mode) {&#10;      $mode=$errref;&#10;      $errref="";&#10;    }&#10;  }&#10;&#10;  my(@date,@delta,$ret,$tmp,$oldincalc,$oldmode)=();&#10;&#10;  if (exists $Curr{"Mode"}) {&#10;    $oldmode = $Curr{"Mode"};&#10;  } else {&#10;    $oldmode = 0;&#10;  }&#10;&#10;  if (defined $mode  and  $mode&gt;=0  and  $mode&lt;=3) {&#10;    $Curr{"Mode"}=$mode;&#10;  } else {&#10;    $Curr{"Mode"}=0;&#10;  }&#10;&#10;  if (exists $Curr{"InCalc"}) {&#10;    $oldincalc = $Curr{"InCalc"};&#10;  } else {&#10;    $oldincalc = 0;&#10;  }&#10;  $Curr{"InCalc"}=1;&#10;&#10;  if ($tmp=ParseDateString($D1)) {&#10;    # If we've already parsed the date, we don't want to do it a second&#10;    # time (so we don't convert timezones twice).&#10;    if (_Date_Split($D1)) {&#10;      push(@date,$D1);&#10;    } else {&#10;      push(@date,$tmp);&#10;    }&#10;  } elsif ($tmp=ParseDateDelta($D1)) {&#10;    push(@delta,$tmp);&#10;  } else {&#10;    $$errref=1  if ($ref);&#10;    $Curr{"InCalc"} = $oldincalc;&#10;    $Curr{"Mode"}   = $oldmode;&#10;    return;&#10;  }&#10;&#10;  if ($tmp=ParseDateString($D2)) {&#10;    if (_Date_Split($D2)) {&#10;      push(@date,$D2);&#10;    } else {&#10;      push(@date,$tmp);&#10;    }&#10;  } elsif ($tmp=ParseDateDelta($D2)) {&#10;    push(@delta,$tmp);&#10;    $mode = $Curr{"Mode"};&#10;  } else {&#10;    $$errref=2  if ($ref);&#10;    $Curr{"InCalc"} = $oldincalc;&#10;    $Curr{"Mode"}   = $oldmode;&#10;    return;&#10;  }&#10;&#10;  $Curr{"InCalc"} = $oldincalc;&#10;  $Curr{"Mode"}   = $oldmode;&#10;&#10;  if ($#date==1) {&#10;    $ret=_DateCalc_DateDate(@date,$mode);&#10;  } elsif ($#date==0) {&#10;    $ret=_DateCalc_DateDelta(@date,@delta,\$err,$mode);&#10;    $$errref=$err  if ($ref);&#10;  } else {&#10;    $ret=_DateCalc_DeltaDelta(@delta,$mode);&#10;  }&#10;  $ret;&#10;}&#10;&#10;sub ParseDateDelta {&#10;  print "DEBUG: ParseDateDelta\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($args,@args,@a,$ref)=();&#10;  local($_)=();&#10;  @a=@_;&#10;&#10;  # @a : is the list of args to ParseDateDelta.  Currently, only one argument&#10;  #      is allowed and it must be a scalar (or a reference to a scalar)&#10;  #      or a reference to an array.&#10;&#10;  if ($#a!=0) {&#10;    print "ERROR:  Invalid number of arguments to ParseDateDelta.\n";&#10;    return "";&#10;  }&#10;  $args=$a[0];&#10;  $ref=ref $args;&#10;  if (! $ref) {&#10;    @args=($args);&#10;  } elsif ($ref eq "ARRAY") {&#10;    @args=@$args;&#10;  } elsif ($ref eq "SCALAR") {&#10;    @args=($$args);&#10;  } else {&#10;    print "ERROR:  Invalid arguments to ParseDateDelta.\n";&#10;    return "";&#10;  }&#10;  @a=@args;&#10;&#10;  # @args : a list containing all the arguments (dereferenced if appropriate)&#10;  # @a    : a list containing all the arguments currently being examined&#10;  # $ref  : nil, "SCALAR", or "ARRAY" depending on whether a scalar, a&#10;  #         reference to a scalar, or a reference to an array was passed in&#10;  # $args : the scalar or refererence passed in&#10;&#10;  my(@colon,@delta,$delta,$dir,$colon,$sign,$val)=();&#10;  my($len,$tmp,$tmp2,$tmpl)=();&#10;  my($from,$to)=();&#10;  my($workweek)=$Cnf{"WorkWeekEnd"}-$Cnf{"WorkWeekBeg"}+1;&#10;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  # A sign can be a sequence of zero or more + and - signs, this&#10;  # allows for deltas like '+ -2 days'.&#10;  my($signexp)='((?:[+-]\s*)*)';&#10;  my($numexp)='(\d+)';&#10;  my($exp1)="(?: \\s* $signexp \\s* $numexp \\s*)";&#10;  my($yexp,$mexp,$wexp,$dexp,$hexp,$mnexp,$sexp,$i)=();&#10;  $yexp=$mexp=$wexp=$dexp=$hexp=$mnexp=$sexp="()()";&#10;  $yexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Yabb"} .")?";&#10;  $mexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Mabb"} .")?";&#10;  $wexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Wabb"} .")?";&#10;  $dexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Dabb"} .")?";&#10;  $hexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Habb"} .")?";&#10;  $mnexp="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"MNabb"}.")?";&#10;  $sexp ="(?: $exp1 ". $Lang{$Cnf{"Language"}}{"Sabb"} ."?)?";&#10;  my($future)=$Lang{$Cnf{"Language"}}{"Future"};&#10;  my($later)=$Lang{$Cnf{"Language"}}{"Later"};&#10;  my($past)=$Lang{$Cnf{"Language"}}{"Past"};&#10;&#10;  $delta="";&#10; PARSE: while (@a) {&#10;    $_ = join(" ", grep {defined;} @a);&#10;    s/\s+$//;&#10;    last  if ($_ eq "");&#10;&#10;    # Mode is set in DateCalc.  ParseDateDelta only overrides it if the&#10;    # string contains a mode.&#10;    if      ($Lang{$Cnf{"Language"}}{"Exact"} &amp;&amp;&#10;             s/$Lang{$Cnf{"Language"}}{"Exact"}//) {&#10;      $Curr{"Mode"}=0;&#10;    } elsif ($Lang{$Cnf{"Language"}}{"Approx"} &amp;&amp;&#10;             s/$Lang{$Cnf{"Language"}}{"Approx"}//) {&#10;      $Curr{"Mode"}=1;&#10;    } elsif ($Lang{$Cnf{"Language"}}{"Business"} &amp;&amp;&#10;             s/$Lang{$Cnf{"Language"}}{"Business"}//) {&#10;      $Curr{"Mode"}=2;&#10;    } elsif (! exists $Curr{"Mode"}) {&#10;      $Curr{"Mode"}=0;&#10;    }&#10;    $workweek=7  if ($Curr{"Mode"} != 2);&#10;&#10;    foreach $from (keys %{ $Lang{$Cnf{"Language"}}{"Repl"} }) {&#10;      $to=$Lang{$Cnf{"Language"}}{"Repl"}{$from};&#10;      s/(^|[^a-z])$from($|[^a-z])/$1$to$2/i;&#10;    }&#10;&#10;    # in or ago&#10;    #&#10;    # We need to make sure that $later, $future, and $past don't contain each&#10;    # other... Romanian pointed this out where $past is "in urma" and $future&#10;    # is "in".  When they do, we have to take this into account.&#10;    #   $len  length of best match (greatest wins)&#10;    #   $tmp  string after best match&#10;    #   $dir  direction (prior, after) of best match&#10;    #&#10;    #   $tmp2 string before/after current match&#10;    #   $tmpl length of current match&#10;&#10;    $len=0;&#10;    $tmp=$_;&#10;    $dir=1;&#10;&#10;    $tmp2=$_;&#10;    if ($tmp2 =~ s/(^|[^a-z])($future)($|[^a-z])/$1 $3/i) {&#10;      $tmpl=length($2);&#10;      if ($tmpl&gt;$len) {&#10;        $tmp=$tmp2;&#10;        $dir=1;&#10;        $len=$tmpl;&#10;      }&#10;    }&#10;&#10;    $tmp2=$_;&#10;    if ($tmp2 =~ s/(^|[^a-z])($later)($|[^a-z])/$1 $3/i) {&#10;      $tmpl=length($2);&#10;      if ($tmpl&gt;$len) {&#10;        $tmp=$tmp2;&#10;        $dir=1;&#10;        $len=$tmpl;&#10;      }&#10;    }&#10;&#10;    $tmp2=$_;&#10;    if ($tmp2 =~ s/(^|[^a-z])($past)($|[^a-z])/$1 $3/i) {&#10;      $tmpl=length($2);&#10;      if ($tmpl&gt;$len) {&#10;        $tmp=$tmp2;&#10;        $dir=-1;&#10;        $len=$tmpl;&#10;      }&#10;    }&#10;&#10;    $_ = $tmp;&#10;    s/\s*$//;&#10;&#10;    # the colon part of the delta&#10;    $colon="";&#10;    if (s/($signexp?$numexp?(:($signexp?$numexp)?){1,6})$//) {&#10;      $colon=$1;&#10;      s/\s+$//;&#10;    }&#10;    @colon=split(/:/,$colon);&#10;&#10;    # the non-colon part of the delta&#10;    $sign="+";&#10;    @delta=();&#10;    $i=6;&#10;    foreach $exp1 ($yexp,$mexp,$wexp,$dexp,$hexp,$mnexp,$sexp) {&#10;      last  if ($#colon&gt;=$i--);&#10;      $val=0;&#10;      if (s/^$exp1//ix) {&#10;        $val=$2   if ($2);&#10;        $sign=$1  if ($1);&#10;      }&#10;&#10;      # Collapse a sign like '+ -' into a single character like '-',&#10;      # by counting the occurrences of '-'.&#10;      #&#10;      $sign =~ s/\s+//g;&#10;      $sign =~ tr/+//d;&#10;      my $count = ($sign =~ tr/-//d);&#10;      die "bad characters in sign: $sign" if length $sign;&#10;      $sign = $count % 2 ? '-' : '+';&#10;&#10;      push(@delta,"$sign$val");&#10;    }&#10;    if (! /^\s*$/) {&#10;      pop(@a);&#10;      next PARSE;&#10;    }&#10;&#10;    # make sure that the colon part has a sign&#10;    for ($i=0; $i&lt;=$#colon; $i++) {&#10;      $val=0;&#10;      if ($colon[$i] =~ /^$signexp$numexp?/) {&#10;        $val=$2   if ($2);&#10;        $sign=$1  if ($1);&#10;      }&#10;      $colon[$i] = "$sign$val";&#10;    }&#10;&#10;    # combine the two&#10;    push(@delta,@colon);&#10;    if ($dir&lt;0) {&#10;      for ($i=0; $i&lt;=$#delta; $i++) {&#10;        $delta[$i] =~ tr/-+/+-/;&#10;      }&#10;    }&#10;&#10;    # form the delta and shift off the valid part&#10;    $delta=join(":",@delta);&#10;    splice(@args,0,$#a+1);&#10;    @$args=@args  if (defined $ref  and  $ref eq "ARRAY");&#10;    last PARSE;&#10;  }&#10;&#10;  $delta=_Delta_Normalize($delta,$Curr{"Mode"});&#10;  return $delta;&#10;}&#10;&#10;sub UnixDate {&#10;  print "DEBUG: UnixDate\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,@format)=@_;&#10;  local($_)=();&#10;  my($format,%f,$out,@out,$c,$date1,$date2,$tmp)=();&#10;  my($scalar)=();&#10;  $date=ParseDateString($date);&#10;  return  if (! $date);&#10;&#10;  my($y,$m,$d,$h,$mn,$s)=($f{"Y"},$f{"m"},$f{"d"},$f{"H"},$f{"M"},$f{"S"})=&#10;    _Date_Split($date, 1);&#10;  $f{"y"}=substr $f{"Y"},2;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;&#10;  if (! wantarray) {&#10;    $format=join(" ",@format);&#10;    @format=($format);&#10;    $scalar=1;&#10;  }&#10;&#10;  # month, week&#10;  $_=$m;&#10;  s/^0//;&#10;  $f{"b"}=$f{"h"}=$Lang{$Cnf{"Language"}}{"MonL"}[$_-1];&#10;  $f{"B"}=$Lang{$Cnf{"Language"}}{"MonthL"}[$_-1];&#10;  $_=$m;&#10;  s/^0/ /;&#10;  $f{"f"}=$_;&#10;  $f{"U"}=Date_WeekOfYear($m,$d,$y,7);&#10;  $f{"W"}=Date_WeekOfYear($m,$d,$y,1);&#10;&#10;  # check week 52,53 and 0&#10;  $f{"G"}=$f{"L"}=$y;&#10;  if ($f{"W"}&gt;=52 || $f{"U"}&gt;=52) {&#10;    my($dd,$mm,$yy)=($d,$m,$y);&#10;    $dd+=7;&#10;    if ($dd&gt;31) {&#10;      $dd-=31;&#10;      $mm=1;&#10;      $yy++;&#10;      if (Date_WeekOfYear($mm,$dd,$yy,1)==2) {&#10;        $f{"G"}=$yy;&#10;        $f{"W"}=1;&#10;      }&#10;      if (Date_WeekOfYear($mm,$dd,$yy,7)==2) {&#10;        $f{"L"}=$yy;&#10;        $f{"U"}=1;&#10;      }&#10;    }&#10;  }&#10;  if ($f{"W"}==0) {&#10;    my($dd,$mm,$yy)=($d,$m,$y);&#10;    $dd-=7;&#10;    $dd+=31  if ($dd&lt;1);&#10;    $yy = sprintf "%04d", $yy-1;&#10;    $mm=12;&#10;    $f{"G"}=$yy;&#10;    $f{"W"}=Date_WeekOfYear($mm,$dd,$yy,1)+1;&#10;  }&#10;  if ($f{"U"}==0) {&#10;    my($dd,$mm,$yy)=($d,$m,$y);&#10;    $dd-=7;&#10;    $dd+=31  if ($dd&lt;1);&#10;    $yy = sprintf "%04d", $yy-1;&#10;    $mm=12;&#10;    $f{"L"}=$yy;&#10;    $f{"U"}=Date_WeekOfYear($mm,$dd,$yy,7)+1;&#10;  }&#10;&#10;  $f{"U"}="0".$f{"U"}  if (length $f{"U"} &lt; 2);&#10;  $f{"W"}="0".$f{"W"}  if (length $f{"W"} &lt; 2);&#10;&#10;  # day&#10;  $f{"j"}=Date_DayOfYear($m,$d,$y);&#10;  $f{"j"} = "0" . $f{"j"}   while (length($f{"j"})&lt;3);&#10;  $_=$d;&#10;  s/^0/ /;&#10;  $f{"e"}=$_;&#10;  $f{"w"}=Date_DayOfWeek($m,$d,$y);&#10;  $f{"v"}=$Lang{$Cnf{"Language"}}{"WL"}[$f{"w"}-1];&#10;  $f{"v"}=" ".$f{"v"}  if (length $f{"v"} &lt; 2);&#10;  $f{"a"}=$Lang{$Cnf{"Language"}}{"WkL"}[$f{"w"}-1];&#10;  $f{"A"}=$Lang{$Cnf{"Language"}}{"WeekL"}[$f{"w"}-1];&#10;  $f{"E"}=Date_DaySuffix($f{"e"});&#10;&#10;  # hour&#10;  $_=$h;&#10;  s/^0/ /;&#10;  $f{"k"}=$_;&#10;  $f{"i"}=$f{"k"}+1;&#10;  $f{"i"}=$f{"k"};&#10;  $f{"i"}=12          if ($f{"k"}==0);&#10;  $f{"i"}=$f{"k"}-12  if ($f{"k"}&gt;12);&#10;  $f{"i"}=$f{"i"}-12  if ($f{"i"}&gt;12);&#10;  $f{"i"}=" ".$f{"i"} if (length($f{"i"})&lt;2);&#10;  $f{"I"}=$f{"i"};&#10;  $f{"I"}=~ s/^ /0/;&#10;  $f{"p"}=$Lang{$Cnf{"Language"}}{"AMstr"};&#10;  $f{"p"}=$Lang{$Cnf{"Language"}}{"PMstr"}  if ($f{"k"}&gt;11);&#10;&#10;  # minute, second, timezone&#10;  $f{"o"}=Date_SecsSince1970($m,$d,$y,$h,$mn,$s);&#10;  $f{"s"}=Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);&#10;  $f{"Z"}=($Cnf{"ConvTZ"} eq "IGNORE" or $Cnf{"ConvTZ"} eq "") ?&#10;           $Cnf{"TZ"} : $Cnf{"ConvTZ"};&#10;  $f{"z"}=($f{"Z"}=~/^[+-]\d{4}/) ? $f{"Z"} : ($Zone{"n2o"}{lc $f{"Z"}} || "");&#10;&#10;  # date, time&#10;  $f{"c"}=qq|$f{"a"} $f{"b"} $f{"e"} $h:$mn:$s $y|;&#10;  $f{"C"}=$f{"u"}=&#10;    qq|$f{"a"} $f{"b"} $f{"e"} $h:$mn:$s $f{"z"} $y|;&#10;  $f{"g"}=qq|$f{"a"}, $d $f{"b"} $y $h:$mn:$s $f{"z"}|;&#10;  $f{"D"}=$f{"x"}=qq|$m/$d/$f{"y"}|;&#10;  $f{"x"}=qq|$d/$m/$f{"y"}|  if ($Cnf{"DateFormat"} ne "US");&#10;  $f{"r"}=qq|$f{"I"}:$mn:$s $f{"p"}|;&#10;  $f{"R"}=qq|$h:$mn|;&#10;  $f{"T"}=$f{"X"}=qq|$h:$mn:$s|;&#10;  $f{"V"}=qq|$m$d$h$mn$f{"y"}|;&#10;  $f{"Q"}="$y$m$d";&#10;  $f{"q"}=qq|$y$m$d$h$mn$s|;&#10;  $f{"P"}=qq|$y$m$d$h:$mn:$s|;&#10;  $f{"O"}=qq|$y-$m-${d}T$h:$mn:$s|;&#10;  $f{"F"}=qq|$f{"A"}, $f{"B"} $f{"e"}, $f{"Y"}|;&#10;  if ($f{"W"}==0) {&#10;    $y--;&#10;    $tmp=Date_WeekOfYear(12,31,$y,1);&#10;    $tmp="0$tmp"  if (length($tmp) &lt; 2);&#10;    $f{"J"}=qq|$y-W$tmp-$f{"w"}|;&#10;  } else {&#10;    $f{"J"}=qq|$f{"G"}-W$f{"W"}-$f{"w"}|;&#10;  }&#10;  $f{"K"}=qq|$y-$f{"j"}|;&#10;  # %l is a special case.  Since it requires the use of the calculator&#10;  # which requires this routine, an infinite recursion results.  To get&#10;  # around this, %l is NOT determined every time this is called so the&#10;  # recursion breaks.&#10;&#10;  # other formats&#10;  $f{"n"}="\n";&#10;  $f{"t"}="\t";&#10;  $f{"%"}="%";&#10;  $f{"+"}="+";&#10;&#10;  foreach $format (@format) {&#10;    $format=reverse($format);&#10;    $out="";&#10;    while ($format ne "") {&#10;      $c=chop($format);&#10;      if ($c eq "%") {&#10;        $c=chop($format);&#10;        if ($c eq "l") {&#10;          Date_Init();&#10;          $date1=_DateCalc_DateDelta($Curr{"Now"},"-0:6:0:0:0:0:0");&#10;          $date2=_DateCalc_DateDelta($Curr{"Now"},"+0:6:0:0:0:0:0");&#10;          if (Date_Cmp($date,$date1)&gt;=0  &amp;&amp;  Date_Cmp($date,$date2)&lt;=0) {&#10;            $f{"l"}=qq|$f{"b"} $f{"e"} $h:$mn|;&#10;          } else {&#10;            $f{"l"}=qq|$f{"b"} $f{"e"}  $f{"Y"}|;&#10;          }&#10;          $out .= $f{"$c"};&#10;        } elsif (exists $f{"$c"}) {&#10;          $out .= $f{"$c"};&#10;        } else {&#10;          $out .= $c;&#10;        }&#10;      } else {&#10;        $out .= $c;&#10;      }&#10;    }&#10;    push(@out,$out);&#10;  }&#10;  if ($scalar) {&#10;    return $out[0];&#10;  } else {&#10;    return (@out);&#10;  }&#10;}&#10;&#10;# Can't be in "use integer" because we're doing decimal arithmatic&#10;no integer;&#10;sub Delta_Format {&#10;  print "DEBUG: Delta_Format\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($delta,@arg)=@_;&#10;  my($mode);&#10;  if (lc($arg[0]) eq "approx") {&#10;    $mode = "approx";&#10;    shift(@arg);&#10;  } else {&#10;    $mode = "exact";&#10;  }&#10;  my($dec,@format) = @arg;&#10;&#10;  $delta=ParseDateDelta($delta);&#10;  return ""  if (! $delta);&#10;  my(@out,%f,$out,$c1,$c2,$scalar,$format)=();&#10;  local($_)=$delta;&#10;  my($y,$M,$w,$d,$h,$m,$s)=_Delta_Split($delta);&#10;  # Get rid of positive signs.&#10;  ($y,$M,$w,$d,$h,$m,$s)=map { 1*$_; }($y,$M,$w,$d,$h,$m,$s);&#10;&#10;  if (defined $dec  &amp;&amp;  $dec&gt;0) {&#10;    $dec="%." . ($dec*1) . "f";&#10;  } else {&#10;    $dec="%f";&#10;  }&#10;&#10;  if (! wantarray) {&#10;    $format=join(" ",@format);&#10;    @format=($format);&#10;    $scalar=1;&#10;  }&#10;&#10;  # Length of each unit in seconds&#10;  my($sl,$ml,$hl,$dl,$wl,$Ml,$yl)=();&#10;  $sl = 1;&#10;  $ml = $sl*60;&#10;  $hl = $ml*60;&#10;  $dl = $hl*24;&#10;  $wl = $dl*7;&#10;  $yl = $dl*365.25;&#10;  $Ml = $yl/12;&#10;&#10;  # The decimal amount of each unit contained in all smaller units&#10;  my($yd,$Md,$sd,$md,$hd,$dd,$wd)=();&#10;  if ($mode eq "exact") {&#10;    $yd = $M/12;&#10;    $Md = 0;&#10;  } else {&#10;    $yd = ($M*$Ml + $w*$wl + $d*$dl + $h*$hl + $m*$ml + $s*$sl)/$yl;&#10;    $Md =          ($w*$wl + $d*$dl + $h*$hl + $m*$ml + $s*$sl)/$Ml;&#10;  }&#10;&#10;  $wd = ($d*$dl + $h*$hl + $m*$ml + $s*$sl)/$wl;&#10;  $dd =          ($h*$hl + $m*$ml + $s*$sl)/$dl;&#10;  $hd =                   ($m*$ml + $s*$sl)/$hl;&#10;  $md =                            ($s*$sl)/$ml;&#10;  $sd = 0;&#10;&#10;  # The amount of each unit contained in higher units.&#10;  my($yh,$Mh,$sh,$mh,$hh,$dh,$wh)=();&#10;  $yh = 0;&#10;  $Mh = ($yh+$y)*12;&#10;&#10;  if ($mode eq "exact") {&#10;    $wh = 0;&#10;    $dh = ($wh+$w)*7;&#10;  } else {&#10;    $wh = ($yh+$y+$M/12)*365.25/7;&#10;    $dh = ($wh+$w)*7;&#10;  }&#10;&#10;  $hh = ($dh+$d)*24;&#10;  $mh = ($hh+$h)*60;&#10;  $sh = ($mh+$m)*60;&#10;&#10;  # Set up the formats&#10;&#10;  $f{"yv"} = $y;&#10;  $f{"Mv"} = $M;&#10;  $f{"wv"} = $w;&#10;  $f{"dv"} = $d;&#10;  $f{"hv"} = $h;&#10;  $f{"mv"} = $m;&#10;  $f{"sv"} = $s;&#10;&#10;  $f{"yh"} = $y+$yh;&#10;  $f{"Mh"} = $M+$Mh;&#10;  $f{"wh"} = $w+$wh;&#10;  $f{"dh"} = $d+$dh;&#10;  $f{"hh"} = $h+$hh;&#10;  $f{"mh"} = $m+$mh;&#10;  $f{"sh"} = $s+$sh;&#10;&#10;  $f{"yd"} = sprintf($dec,$y+$yd);&#10;  $f{"Md"} = sprintf($dec,$M+$Md);&#10;  $f{"wd"} = sprintf($dec,$w+$wd);&#10;  $f{"dd"} = sprintf($dec,$d+$dd);&#10;  $f{"hd"} = sprintf($dec,$h+$hd);&#10;  $f{"md"} = sprintf($dec,$m+$md);&#10;  $f{"sd"} = sprintf($dec,$s+$sd);&#10;&#10;  $f{"yt"} = sprintf($dec,$yh+$y+$yd);&#10;  $f{"Mt"} = sprintf($dec,$Mh+$M+$Md);&#10;  $f{"wt"} = sprintf($dec,$wh+$w+$wd);&#10;  $f{"dt"} = sprintf($dec,$dh+$d+$dd);&#10;  $f{"ht"} = sprintf($dec,$hh+$h+$hd);&#10;  $f{"mt"} = sprintf($dec,$mh+$m+$md);&#10;  $f{"st"} = sprintf($dec,$sh+$s+$sd);&#10;&#10;  $f{"%"}  = "%";&#10;&#10;  foreach $format (@format) {&#10;    $format=reverse($format);&#10;    $out="";&#10;  PARSE: while ($format) {&#10;      $c1=chop($format);&#10;      if ($c1 eq "%") {&#10;        $c1=chop($format);&#10;        if (exists($f{$c1})) {&#10;          $out .= $f{$c1};&#10;          next PARSE;&#10;        }&#10;        $c2=chop($format);&#10;        if (exists($f{"$c1$c2"})) {&#10;          $out .= $f{"$c1$c2"};&#10;          next PARSE;&#10;        }&#10;        $out .= $c1;&#10;        $format .= $c2;&#10;      } else {&#10;        $out .= $c1;&#10;      }&#10;    }&#10;    push(@out,$out);&#10;  }&#10;  if ($scalar) {&#10;    return $out[0];&#10;  } else {&#10;    return (@out);&#10;  }&#10;}&#10;use integer;&#10;&#10;sub ParseRecur {&#10;  print "DEBUG: ParseRecur\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;&#10;  my($recur,$dateb,$date0,$date1,$flag)=@_;&#10;  local($_)=$recur;&#10;&#10;  my($recur_0,$recur_1,@recur0,@recur1)=();&#10;  my(@tmp,$tmp,$each,$num,$y,$m,$d,$w,$h,$mn,$s,$delta,$y0,$y1,$yb)=();&#10;  my($yy,$n,$dd,@d,@tmp2,$date,@date,@w,@tmp3,@m,@y,$tmp2,$d2,@flags)=();&#10;&#10;  # $date0, $date1, $dateb, $flag : passed in (these are always the final say&#10;  #                                 in determining whether a date matches a&#10;  #                                 recurrence IF they are present.&#10;  # $date_b, $date_0, $date_1     : if a value can be determined from the&#10;  # $flag_t                         recurrence, they are stored here.&#10;  #&#10;  # If values can be determined from the recurrence AND are passed in, the&#10;  # following are used:&#10;  #    max($date0,$date_0)    i.e. the later of the two dates&#10;  #    min($date1,$date_1)    i.e. the earlier of the two dates&#10;  #&#10;  # The base date that is used is the first one defined from&#10;  #    $dateb $date_b&#10;  # The base date is only used if necessary (as determined by the recur).&#10;  # For example, "every other friday" requires a base date, but "2nd&#10;  # friday of every month" doesn't.&#10;&#10;  my($date_b,$date_0,$date_1,$flag_t);&#10;&#10;  #&#10;  # Check the arguments passed in.&#10;  #&#10;&#10;  $date0=""  if (! defined $date0);&#10;  $date1=""  if (! defined $date1);&#10;  $dateb=""  if (! defined $dateb);&#10;  $flag =""  if (! defined $flag);&#10;&#10;  if ($dateb) {&#10;    $dateb=ParseDateString($dateb);&#10;    return ""  if (! $dateb);&#10;  }&#10;  if ($date0) {&#10;    $date0=ParseDateString($date0);&#10;    return ""  if (! $date0);&#10;  }&#10;  if ($date1) {&#10;    $date1=ParseDateString($date1);&#10;    return ""  if (! $date1);&#10;  }&#10;&#10;  #&#10;  # Parse the recur.  $date_b, $date_0, and $date_e are values obtained&#10;  # from the recur.&#10;  #&#10;&#10;  @tmp=_Recur_Split($_);&#10;&#10;  if (@tmp) {&#10;    ($recur_0,$recur_1,$flag_t,$date_b,$date_0,$date_1)=@tmp;&#10;    $recur_0 = ""  if (! defined $recur_0);&#10;    $recur_1 = ""  if (! defined $recur_1);&#10;    $flag_t  = ""  if (! defined $flag_t);&#10;    $date_b  = ""  if (! defined $date_b);&#10;    $date_0  = ""  if (! defined $date_0);&#10;    $date_1  = ""  if (! defined $date_1);&#10;&#10;    @recur0 = split(/:/,$recur_0);&#10;    @recur1 = split(/:/,$recur_1);&#10;    return ""  if ($#recur0 + $#recur1 + 2 != 7);&#10;&#10;    if ($date_b) {&#10;      $date_b=ParseDateString($date_b);&#10;      return ""  if (! $date_b);&#10;    }&#10;    if ($date_0) {&#10;      $date_0=ParseDateString($date_0);&#10;      return ""  if (! $date_0);&#10;    }&#10;    if ($date_1) {&#10;      $date_1=ParseDateString($date_1);&#10;      return ""  if (! $date_1);&#10;    }&#10;&#10;  } else {&#10;&#10;    my($mmm)='\s*'.$Lang{$Cnf{"Language"}}{"Month"};  # \s*(jan|january|...)&#10;    my(%mmm)=%{ $Lang{$Cnf{"Language"}}{"MonthH"} };  # { jan=&gt;1, ... }&#10;    my($wkexp)='\s*'.$Lang{$Cnf{"Language"}}{"Week"}; # \s*(mon|monday|...)&#10;    my(%week)=%{ $Lang{$Cnf{"Language"}}{"WeekH"} };  # { monday=&gt;1, ... }&#10;    my($day)='\s*'.$Lang{$Cnf{"Language"}}{"Dabb"};   # \s*(?:d|day|days)&#10;    my($month)='\s*'.$Lang{$Cnf{"Language"}}{"Mabb"}; # \s*(?:mon|month|months)&#10;    my($week)='\s*'.$Lang{$Cnf{"Language"}}{"Wabb"};  # \s*(?:w|wk|week|weeks)&#10;    my($daysexp)=$Lang{$Cnf{"Language"}}{"DoM"};      # (1st|first|...31st)&#10;    my(%dayshash)=%{ $Lang{$Cnf{"Language"}}{"DoMH"} };&#10;                                                      # { 1st=&gt;1,first=&gt;1,...}&#10;    my($of)='\s*'.$Lang{$Cnf{"Language"}}{"Of"};      # \s*(?:in|of)&#10;    my($lastexp)=$Lang{$Cnf{"Language"}}{"Last"};     # (?:last)&#10;    my($each)=$Lang{$Cnf{"Language"}}{"Each"};        # (?:each|every)&#10;&#10;    my($D)='\s*(\d+)';&#10;    my($Y)='\s*(\d{4}|\d{2})';&#10;&#10;    # Change 1st to 1&#10;    if (/(^|[^a-z])$daysexp($|[^a-z])/i) {&#10;      $tmp=lc($2);&#10;      $tmp=$dayshash{"$tmp"};&#10;      s/(^|[^a-z])$daysexp($|[^a-z])/$1 $tmp $3/i;&#10;    }&#10;    s/\s*$//;&#10;&#10;    # Get rid of "each"&#10;    if (/(^|[^a-z])$each($|[^a-z])/i) {&#10;      s/(^|[^a-z])$each($|[^a-z])/$1 $2/i;&#10;      $each=1;&#10;    } else {&#10;      $each=0;&#10;    }&#10;&#10;    if ($each) {&#10;&#10;      if (/^$D?$day(?:$of$mmm?$Y)?$/i ||&#10;          /^$D?$day(?:$of$mmm())?$/i) {&#10;        # every [2nd] day in [june] 1997&#10;        # every [2nd] day [in june]&#10;        ($num,$m,$y)=($1,$2,$3);&#10;        $num=1 if (! defined $num);&#10;        $m=""  if (! defined $m);&#10;        $y=""  if (! defined $y);&#10;&#10;        $y=$Curr{"Y"}  if (! $y);&#10;        if ($m) {&#10;          $m=$mmm{lc($m)};&#10;          $date_0=_Date_Join($y,$m,1,0,0,0);&#10;          $date_1=_DateCalc_DateDelta($date_0,"+0:1:0:0:0:0:0",0);&#10;        } else {&#10;          $date_0=_Date_Join($y,  1,1,0,0,0);&#10;          $date_1=_Date_Join($y+1,1,1,0,0,0);&#10;        }&#10;        $date_b=DateCalc($date_0,"-0:0:0:1:0:0:0",0);&#10;        @recur0=(0,0,0,$num,0,0,0);&#10;        @recur1=();&#10;&#10;      } elsif (/^$D$day?$of$month(?:$of?$Y)?$/) {&#10;        # 2nd [day] of every month [in 1997]&#10;        ($num,$y)=($1,$2);&#10;        $y=$Curr{"Y"}  if (! $y);&#10;&#10;        $date_0=_Date_Join($y,  1,1,0,0,0);&#10;        $date_1=_Date_Join($y+1,1,1,0,0,0);&#10;        $date_b=$date_0;&#10;&#10;        @recur0=(0,1,0);&#10;        @recur1=($num,0,0,0);&#10;&#10;      } elsif (/^$D$wkexp$of$month(?:$of?$Y)?$/ ||&#10;               /^($lastexp)$wkexp$of$month(?:$of?$Y)?$/) {&#10;        # 2nd tuesday of every month [in 1997]&#10;        # last tuesday of every month [in 1997]&#10;        ($num,$d,$y)=($1,$2,$3);&#10;        $y=$Curr{"Y"}  if (! $y);&#10;        $d=$week{lc($d)};&#10;        $num=-1  if ($num !~ /^$D$/);&#10;&#10;        $date_0=_Date_Join($y,1,1,0,0,0);&#10;        $date_1=_Date_Join($y+1,1,1,0,0,0);&#10;        $date_b=$date_0;&#10;&#10;        @recur0=(0,1);&#10;        @recur1=($num,$d,0,0,0);&#10;&#10;      } elsif (/^$D?$wkexp(?:$of$mmm?$Y)?$/i ||&#10;               /^$D?$wkexp(?:$of$mmm())?$/i) {&#10;        # every tuesday in june 1997&#10;        # every 2nd tuesday in june 1997&#10;        ($num,$d,$m,$y)=($1,$2,$3,$4);&#10;        $y=$Curr{"Y"}  if (! $y);&#10;        $num=1 if (! defined $num);&#10;        $m=""  if (! defined $m);&#10;        $d=$week{lc($d)};&#10;&#10;        if ($m) {&#10;          $m=$mmm{lc($m)};&#10;          $date_0=_Date_Join($y,$m,1,0,0,0);&#10;          $date_1=_DateCalc_DateDelta($date_0,"+0:1:0:0:0:0:0",0);&#10;        } else {&#10;          $date_0=_Date_Join($y,1,1,0,0,0);&#10;          $date_1=_Date_Join($y+1,1,1,0,0,0);&#10;        }&#10;        $date_b=DateCalc($date_0,"-0:0:0:1:0:0:0",0);&#10;&#10;        @recur0=(0,0,$num);&#10;        @recur1=($d,0,0,0);&#10;&#10;      } else {&#10;        return "";&#10;      }&#10;&#10;      $date_0=""  if ($date0);&#10;      $date_1=""  if ($date1);&#10;    } else {&#10;      return "";&#10;    }&#10;  }&#10;&#10;  #&#10;  # Override with any values passed in&#10;  #&#10;&#10;  $date0 = $date_0  if (! $date0);&#10;  $date1 = $date_1  if (! $date1);&#10;  $dateb = $date_b  if (! $dateb);&#10;  if ($flag =~ s/^\+//) {&#10;    $flag = "$flag_t,$flag"  if ($flag_t);&#10;  }&#10;  $flag = $flag_t  if (! $flag);&#10;  $flag = ""  if (! $flag);&#10;&#10;  if (! wantarray) {&#10;    $tmp  = join(":",@recur0);&#10;    $tmp .= "*" . join(":",@recur1)  if (@recur1);&#10;    $tmp .= "*$flag*$dateb*$date0*$date1";&#10;    return $tmp;&#10;  }&#10;  if (@recur0) {&#10;    return ()  if (! $date0  ||  ! $date1); # dateb is NOT required in all case&#10;  }&#10;&#10;  #&#10;  # Some flags affect parsing.&#10;  #&#10;&#10;  @flags   = split(/,/,$flag);&#10;  my($f);&#10;  foreach $f (@flags) {&#10;    if ($f =~ /^EASTER$/i) {&#10;      ($y,$m,$w,$d,$h,$mn,$s)=(@recur0,@recur1);&#10;      # We want something that will return Jan 1 for the given years.&#10;      if ($#recur0==-1) {&#10;        @recur1=($y,1,0,1,$h,$mn,$s);&#10;      } elsif ($#recur0&lt;=3) {&#10;        @recur0=($y,0,0,0);&#10;        @recur1=($h,$mn,$s);&#10;      } elsif ($#recur0==4) {&#10;        @recur0=($y,0,0,0,0);&#10;        @recur1=($mn,$s);&#10;      } elsif ($#recur0==5) {&#10;        @recur0=($y,0,0,0,0,0);&#10;        @recur1=($s);&#10;      } else {&#10;        @recur0=($y,0,0,0,0,0,0);&#10;      }&#10;    }&#10;  }&#10;&#10;  #&#10;  # Determine the dates referenced by the recur.  Also, fix the base date&#10;  # as necessary for the recurrences which require it.&#10;  #&#10;&#10;  ($y,$m,$w,$d,$h,$mn,$s)=(@recur0,@recur1);&#10;  @y=@m=@w=@d=();&#10;  my(@time)=($h,$mn,$s);&#10;&#10; RECUR: while (1) {&#10;&#10;    if ($#recur0==-1) {&#10;      # * 0-M-W-D-H-MN-S   =&gt; 0 * M-W-D-H-MN-S&#10;&#10;      if ($y eq "0") {&#10;        push(@recur0,1);&#10;        shift(@recur1);&#10;        next RECUR;&#10;      }&#10;&#10;      # Y-M-W-D-H-MN-S&#10;&#10;      @y=_ReturnList($y);&#10;      foreach $y (@y) {&#10;        $y=_Date_FixYear($y)  if (length($y)==2);&#10;        return ()  if (length($y)!=4  ||  ! _IsInt($y));&#10;      }&#10;&#10;      $date0=ParseDate("0000-01-01")          if (! $date0);&#10;      $date1=ParseDate("9999-12-31 23:59:59") if (! $date1);&#10;&#10;      if ($m eq "0"  and  $w eq "0") {&#10;&#10;        # * Y-0-0-0-H-MN-S&#10;        # * Y-0-0-DOY-H-MN-S&#10;&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;          return ()  if (! @d);&#10;          foreach $d (@d) {&#10;            return ()  if (! _IsInt($d,-366,366)  ||  $d==0);&#10;          }&#10;        }&#10;&#10;        @date=();&#10;        foreach $yy (@y) {&#10;          my $diy = Date_DaysInYear($yy);&#10;          foreach $d (@d) {&#10;            my $tmpd = $d;&#10;            $tmpd += ($diy+1)  if ($tmpd &lt; 0);&#10;            next  if (! _IsInt($tmpd,1,$diy));&#10;            ($y,$m,$dd)=Date_NthDayOfYear($yy,$tmpd);&#10;            push(@date, _Date_Join($y,$m,$dd,0,0,0));&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } elsif ($w eq "0") {&#10;&#10;        # * Y-M-0-0-H-MN-S&#10;        # * Y-M-0-DOM-H-MN-S&#10;&#10;        @m=_ReturnList($m);&#10;        return ()  if (! @m);&#10;        foreach $m (@m) {&#10;          return ()  if (! _IsInt($m,1,12));&#10;        }&#10;&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;          return ()  if (! @d);&#10;          foreach $d (@d) {&#10;            return ()  if (! _IsInt($d,-31,31)  ||  $d==0);&#10;          }&#10;        }&#10;&#10;        @date=();&#10;        foreach $y (@y) {&#10;          foreach $m (@m) {&#10;            my $dim = Date_DaysInMonth($m,$y);&#10;            foreach $d (@d) {&#10;              my $tmpd = $d;&#10;              $tmpd += ($dim+1)  if ($d&lt;0);&#10;              next  if (! _IsInt($tmpd,1,$dim));&#10;              $date=_Date_Join($y,$m,$tmpd,0,0,0);&#10;              push(@date,$date);&#10;            }&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } elsif ($m eq "0") {&#10;&#10;        # * Y-0-WOY-DOW-H-MN-S&#10;        # * Y-0-WOY-0-H-MN-S&#10;&#10;        @w=_ReturnList($w);&#10;        return ()  if (! @w);&#10;        foreach $w (@w) {&#10;          return ()  if (! _IsInt($w,-53,53)  ||  $w==0);&#10;        }&#10;&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;          return ()  if (! @d);&#10;          foreach $d (@d) {&#10;            $d += 8  if ($d&lt;0);&#10;            return ()  if (! _IsInt($d,1,7));&#10;          }&#10;        }&#10;&#10;        @date=();&#10;        foreach $y (@y) {&#10;          foreach $w (@w) {&#10;            foreach $d (@d) {&#10;              my($tmpw,$del);&#10;              if ($w&lt;0) {&#10;                $date="$y-12-31-00:00:00";&#10;                $tmpw = (-$w)-1;&#10;                $del="-0:0:$tmpw:0:0:0:0";&#10;                $date=Date_GetPrev($date,$d,1);&#10;              } else {&#10;                $date="$y-01-01-00:00:00";&#10;                $tmpw = ($w)-1;&#10;                $del="0:0:$tmpw:0:0:0:0";&#10;                $date=Date_GetNext($date,$d,1);&#10;              }&#10;              $date=_DateCalc_DateDelta($date,$del);&#10;              push(@date,$date)  if ( (_Date_Split($date))[0] == $y);&#10;            }&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } else {&#10;&#10;        # * Y-M-WOM-DOW-H-MN-S&#10;        # * Y-M-WOM-0-H-MN-S&#10;&#10;        @m=_ReturnList($m);&#10;        return ()  if (! @m);&#10;        @w=_ReturnList($w);&#10;        return ()  if (! @w);&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;        }&#10;&#10;        @date=_Date_Recur_WoM(\@y,\@m,\@w,\@d);&#10;        last RECUR;&#10;      }&#10;    }&#10;&#10;    if ($#recur0==0) {&#10;&#10;      # Y * M-W-D-H-MN-S&#10;      $n=$y;&#10;      $n=1  if ($n==0);&#10;&#10;      if ($m eq "0") {&#10;&#10;        # Y * 0-W-D-H-MN-S    =&gt; Y-0 * W-D-H-MN-S&#10;        push(@recur0,0);&#10;        shift(@recur1);&#10;&#10;      } elsif ($w eq "0") {&#10;&#10;        # Y * M-0-DOM-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  $y != 1);&#10;&#10;        @m=_ReturnList($m);&#10;        return ()  if (! @m);&#10;        foreach $m (@m) {&#10;          return ()  if (! _IsInt($m,1,12));&#10;        }&#10;&#10;        if ($d eq "0") {&#10;          @d = (1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;          return ()  if (! @d);&#10;          foreach $d (@d) {&#10;            return ()  if (! _IsInt($d,-31,31)  ||  $d==0);&#10;          }&#10;        }&#10;&#10;        # We need to find years that are a multiple of $n from $y(base)&#10;        ($y0)=( _Date_Split($date0, 1) )[0];&#10;        ($y1)=( _Date_Split($date1, 1) )[0];&#10;        if ($dateb) {&#10;          ($yb)=( _Date_Split($dateb, 1) )[0];&#10;        } else {&#10;          # If $y=1, there is no base year&#10;          $yb=0;&#10;        }&#10;&#10;        @date=();&#10;        for ($yy=$y0; $yy&lt;=$y1; $yy++) {&#10;          if (($yy-$yb)%$n == 0) {&#10;            foreach $m (@m) {&#10;              foreach $d (@d) {&#10;                my $dim  = Date_DaysInMonth($m,$yy);&#10;                my $tmpd = $d;&#10;                if ($tmpd &lt; 0) {&#10;                  $tmpd += ($dim+1);&#10;                }&#10;                next  if (! _IsInt($tmpd,1,$dim));&#10;                $date=_Date_Join($yy,$m,$tmpd,0,0,0);&#10;                push(@date,$date);&#10;              }&#10;            }&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } else {&#10;&#10;        # Y * M-WOM-DOW-H-MN-S&#10;        # Y * M-WOM-0-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  $y != 1);&#10;&#10;        @m=_ReturnList($m);&#10;        return ()  if (! @m);&#10;        @w=_ReturnList($w);&#10;        return ()  if (! @w);&#10;&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;        }&#10;&#10;        ($y0)=( _Date_Split($date0, 1) )[0];&#10;        ($y1)=( _Date_Split($date1, 1) )[0];&#10;        if ($dateb) {&#10;          ($yb)=( _Date_Split($dateb, 1) )[0];&#10;        } else {&#10;          # If $y=1, there is no base year&#10;          $yb=0;&#10;        }&#10;        @y=();&#10;        for ($yy=$y0; $yy&lt;=$y1; $yy++) {&#10;          if (($yy-$yb)%$n == 0) {&#10;            push(@y,$yy);&#10;          }&#10;        }&#10;&#10;        @date=_Date_Recur_WoM(\@y,\@m,\@w,\@d);&#10;        last RECUR;&#10;      }&#10;    }&#10;&#10;    if ($#recur0==1) {&#10;&#10;      # Y-M * W-D-H-MN-S&#10;&#10;      if ($w eq "0") {&#10;        # Y-M * 0-D-H-MN-S   =&gt; Y-M-0 * D-H-MN-S&#10;        push(@recur0,0);&#10;        shift(@recur1);&#10;&#10;      } elsif ($m==0) {&#10;&#10;        # Y-0 * WOY-0-H-MN-S&#10;        # Y-0 * WOY-DOW-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  $y != 1);&#10;        $n=$y;&#10;        $n=1  if ($n==0);&#10;&#10;        @w=_ReturnList($w);&#10;        return ()  if (! @w);&#10;        foreach $w (@w) {&#10;          return ()  if ($w==0  ||  ! _IsInt($w,-53,53));&#10;        }&#10;&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;          return ()  if (! @d);&#10;          foreach $d (@d) {&#10;            $d += 8  if ($d&lt;0);&#10;            return ()  if (! _IsInt($d,1,7));&#10;          }&#10;        }&#10;&#10;        # We need to find years that are a multiple of $n from $y(base)&#10;        ($y0)=( _Date_Split($date0, 1) )[0];&#10;        ($y1)=( _Date_Split($date1, 1) )[0];&#10;        if ($dateb) {&#10;          ($yb)=( _Date_Split($dateb, 1) )[0];&#10;        } else {&#10;          # If $y=1, there is no base year&#10;          $yb=0;&#10;        }&#10;&#10;        @date=();&#10;        for ($yy=$y0; $yy&lt;=$y1; $yy++) {&#10;          if (($yy-$yb)%$n == 0) {&#10;            foreach $w (@w) {&#10;              foreach $d (@d) {&#10;                my($tmpw,$del);&#10;                if ($w&lt;0) {&#10;                  $date="$yy-12-31-00:00:00";&#10;                  $tmpw = (-$w)-1;&#10;                  $del="-0:0:$tmpw:0:0:0:0";&#10;                  $date=Date_GetPrev($date,$d,1);&#10;                } else {&#10;                  $date="$yy-01-01-00:00:00";&#10;                  $tmpw = ($w)-1;&#10;                  $del="0:0:$tmpw:0:0:0:0";&#10;                  $date=Date_GetNext($date,$d,1);&#10;                }&#10;                $date=DateCalc($date,$del);&#10;                next  if ((_Date_Split($date))[0] != $yy);&#10;                push(@date,$date);&#10;              }&#10;            }&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } else {&#10;&#10;        # Y-M * WOM-0-H-MN-S&#10;        # Y-M * WOM-DOW-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  ($y != 0  ||  $m != 1));&#10;        @tmp=(@recur0);&#10;        push(@tmp,0)  while ($#tmp&lt;6);&#10;        $delta=join(":",@tmp);&#10;        $dateb=$date0  if (! $dateb);&#10;        @tmp=_Date_Recur($date0,$date1,$dateb,$delta);&#10;&#10;        @w=_ReturnList($w);&#10;        @m=();&#10;        if ($d eq "0") {&#10;          @d=(1);&#10;        } else {&#10;          @d=_ReturnList($d);&#10;        }&#10;&#10;        @date=_Date_Recur_WoM(\@tmp,\@m,\@w,\@d);&#10;        last RECUR;&#10;      }&#10;    }&#10;&#10;    if ($#recur0==2) {&#10;      # Y-M-W * D-H-MN-S&#10;&#10;      if ($d eq "0") {&#10;&#10;        # Y-M-W * 0-H-MN-S&#10;        return ()  if (! $dateb);&#10;        $y=1  if ($y==0 &amp;&amp; $m==0 &amp;&amp; $w==0);&#10;        $delta="$y:$m:$w:0:0:0:0";&#10;        @date=_Date_Recur($date0,$date1,$dateb,$delta);&#10;        last RECUR;&#10;&#10;      } elsif ($m==0 &amp;&amp; $w==0) {&#10;&#10;        # Y-0-0 * DOY-H-MN-S&#10;        $y=1  if ($y==0);&#10;        $n=$y;&#10;        return ()  if (! $dateb  &amp;&amp;  $y!=1);&#10;&#10;        @d=_ReturnList($d);&#10;        return ()  if (! @d);&#10;        foreach $d (@d) {&#10;          return ()  if (! _IsInt($d,-366,366)  ||  $d==0);&#10;        }&#10;&#10;        # We need to find years that are a multiple of $n from $y(base)&#10;        ($y0)=( _Date_Split($date0, 1) )[0];&#10;        ($y1)=( _Date_Split($date1, 1) )[0];&#10;        if ($dateb) {&#10;          ($yb)=( _Date_Split($dateb, 1) )[0];&#10;        } else {&#10;          # If $y=1, there is no base year&#10;          $yb=0;&#10;        }&#10;        @date=();&#10;        for ($yy=$y0; $yy&lt;=$y1; $yy++) {&#10;          my $diy = Date_DaysInYear($yy);&#10;          if (($yy-$yb)%$n == 0) {&#10;            foreach $d (@d) {&#10;              my $tmpd = $d;&#10;              $tmpd += ($diy+1)  if ($tmpd&lt;0);&#10;              next  if (! _IsInt($tmpd,1,$diy));&#10;              ($y,$m,$dd)=Date_NthDayOfYear($yy,$tmpd);&#10;              push(@date, _Date_Join($y,$m,$dd,0,0,0));&#10;            }&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } elsif ($w&gt;0) {&#10;&#10;        # Y-M-W * DOW-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  ($y != 0  &amp;&amp;  $m != 0  &amp;&amp;  $w != 1));&#10;        @tmp=(@recur0);&#10;        push(@tmp,0)  while ($#tmp&lt;6);&#10;        $delta=join(":",@tmp);&#10;&#10;        @d=_ReturnList($d);&#10;        return ()  if (! @d);&#10;        foreach $d (@d) {&#10;          $d += 8  if ($d&lt;0);&#10;          return ()  if (! _IsInt($d,1,7));&#10;        }&#10;&#10;        # Find out what DofW the basedate is.&#10;        $dateb = $date0  if (! $dateb);&#10;        @tmp2=_Date_Split($dateb, 1);&#10;        $tmp=Date_DayOfWeek($tmp2[1],$tmp2[2],$tmp2[0]);&#10;&#10;        @date=();&#10;        foreach $d (@d) {&#10;          $date_b=$dateb;&#10;          # Move basedate to DOW in the same week&#10;          if ($d != $tmp) {&#10;            if (($tmp&gt;=$Cnf{"FirstDay"} &amp;&amp; $d&lt;$Cnf{"FirstDay"}) ||&#10;                ($tmp&gt;=$Cnf{"FirstDay"} &amp;&amp; $d&gt;$tmp) ||&#10;                ($tmp&lt;$d &amp;&amp; $d&lt;$Cnf{"FirstDay"})) {&#10;              $date_b=Date_GetNext($date_b,$d);&#10;            } else {&#10;              $date_b=Date_GetPrev($date_b,$d);&#10;            }&#10;          }&#10;          push(@date,_Date_Recur($date0,$date1,$date_b,$delta));&#10;        }&#10;        last RECUR;&#10;&#10;      } elsif ($m&gt;0) {&#10;&#10;        # Y-M-0 * DOM-H-MN-S&#10;        return ()  if (! $dateb  &amp;&amp;  ($y != 0  &amp;&amp;  $m != 1));&#10;        @tmp=(@recur0);&#10;        push(@tmp,0)  while ($#tmp&lt;6);&#10;        $delta=join(":",@tmp);&#10;&#10;        @d=_ReturnList($d);&#10;        return ()  if (! @d);&#10;        foreach $d (@d) {&#10;          return ()  if ($d==0  ||  ! _IsInt($d,-31,31));&#10;        }&#10;        $dateb = $date0  if (! $dateb);&#10;&#10;        @tmp2=_Date_Recur($date0,$date1,$dateb,$delta);&#10;        @date=();&#10;        foreach $date (@tmp2) {&#10;          ($y,$m)=( _Date_Split($date, 1) )[0..1];&#10;          my $dim=Date_DaysInMonth($m,$y);&#10;          foreach $d (@d) {&#10;            my $tmpd = $d;&#10;            $tmpd += ($dim+1)  if ($tmpd&lt;0);&#10;            next  if (! _IsInt($tmpd,1,$dim));&#10;            push(@date,_Date_Join($y,$m,$tmpd,0,0,0));&#10;          }&#10;        }&#10;        last RECUR;&#10;&#10;      } else {&#10;        return ();&#10;      }&#10;    }&#10;&#10;    if ($#recur0&gt;2) {&#10;&#10;      # Y-M-W-D * H-MN-S&#10;      # Y-M-W-D-H * MN-S&#10;      # Y-M-W-D-H-MN * S&#10;      # Y-M-W-D-H-S&#10;      if (($#recur0 == 3  &amp;&amp;&#10;           ($y == 0  &amp;&amp;  $m == 0  &amp;&amp;  $w == 0  &amp;&amp;  $d == 1)) ||&#10;          ($#recur0 == 4  &amp;&amp;&#10;           ($y == 0  &amp;&amp;  $m == 0  &amp;&amp;  $w == 0  &amp;&amp;  $d == 0  &amp;&amp;  $h == 1)) ||&#10;          ($#recur0 == 5  &amp;&amp;&#10;           ($y == 0  &amp;&amp;  $m == 0  &amp;&amp;  $w == 0  &amp;&amp;  $d == 0  &amp;&amp;  $h == 0  &amp;&amp;&#10;            $mn == 1))) {&#10;         $dateb = $date0;&#10;      }&#10;      return ()  if (! $dateb);&#10;      @tmp=(@recur0);&#10;      push(@tmp,0)  while ($#tmp&lt;6);&#10;      $delta=join(":",@tmp);&#10;      return ()  if ($delta !~ /[1-9]/); # return if "0:0:0:0:0:0:0"&#10;      @date=_Date_Recur($date0,$date1,$dateb,$delta);&#10;      if (@recur1) {&#10;        unshift(@recur1,-1)  while ($#recur1&lt;2);&#10;        @time=@recur1;&#10;      } else {&#10;        shift(@date);&#10;        pop(@date);&#10;        @time=();&#10;      }&#10;    }&#10;&#10;    last RECUR;&#10;  }&#10;  @date=_Date_RecurSetTime($date0,$date1,\@date,@time)  if (@time);&#10;&#10;  #&#10;  # We've got a list of dates.  Operate on them with the flags.&#10;  #&#10;&#10;  my($sign,$forw,$today,$df,$db,$work,$i);&#10;  if (@flags) {&#10;  FLAG: foreach $f (@flags) {&#10;      $f = uc($f);&#10;&#10;      if ($f =~ /^(P|N)(D|T)([1-7])$/) {&#10;        @tmp=($1,$2,$3);&#10;        $forw =($tmp[0] eq "P" ? 0 : 1);&#10;        $today=($tmp[1] eq "D" ? 0 : 1);&#10;        $d=$tmp[2];&#10;        @tmp=();&#10;        foreach $date (@date) {&#10;          if ($forw) {&#10;            push(@tmp, Date_GetNext($date,$d,$today));&#10;          } else {&#10;            push(@tmp, Date_GetPrev($date,$d,$today));&#10;          }&#10;        }&#10;        @date=@tmp;&#10;        next FLAG;&#10;      }&#10;&#10;      # We want to go forward exact amounts of time instead of&#10;      # business mode calculations so that we don't change the time&#10;      # (which may have been set in the recur).&#10;      if ($f =~ /^(F|B)(D|W)(\d+)$/) {&#10;        @tmp=($1,$2,$3);&#10;        $sign="+";&#10;        $sign="-"  if ($tmp[0] eq "B");&#10;        $work=0;&#10;        $work=1    if ($tmp[1] eq "W");&#10;        $n=$tmp[2];&#10;        @tmp=();&#10;        foreach $date (@date) {&#10;          for ($i=1; $i&lt;=$n; $i++) {&#10;            while (1) {&#10;              $date=DateCalc($date,"${sign}0:0:0:1:0:0:0");&#10;              last if (! $work  ||  Date_IsWorkDay($date,0));&#10;            }&#10;          }&#10;          push(@tmp,$date);&#10;        }&#10;        @date=@tmp;&#10;        next FLAG;&#10;      }&#10;&#10;      if ($f =~ /^CW(N|P|D)$/ || $f =~ /^(N|P|D)W(D)$/) {&#10;        $tmp=$1;&#10;        my $noalt = $2 ? 1 : 0;&#10;        if ($tmp eq "N"  ||  ($tmp eq "D" &amp;&amp; $Cnf{"TomorrowFirst"})) {&#10;          $forw=1;&#10;        } else {&#10;          $forw=0;&#10;        }&#10;&#10;        @tmp=();&#10;      DATE: foreach $date (@date) {&#10;          $df=$db=$date;&#10;          if (Date_IsWorkDay($date)) {&#10;            push(@tmp,$date);&#10;            next DATE;&#10;          }&#10;          while (1) {&#10;            if ($forw) {&#10;              $d=$df=DateCalc($df,"+0:0:0:1:0:0:0");&#10;            } else {&#10;              $d=$db=DateCalc($db,"-0:0:0:1:0:0:0");&#10;            }&#10;            if (Date_IsWorkDay($d)) {&#10;              push(@tmp,$d);&#10;              next DATE;&#10;            }&#10;            $forw=1-$forw  if (! $noalt);&#10;          }&#10;        }&#10;        @date=@tmp;&#10;        next FLAG;&#10;      }&#10;&#10;      if ($f eq "EASTER") {&#10;        @tmp=();&#10;        foreach $date (@date) {&#10;          ($y,$m,$d,$h,$mn,$s)=_Date_Split($date, 1);&#10;          ($m,$d)=_Date_Easter($y);&#10;          $date=_Date_Join($y,$m,$d,$h,$mn,$s);&#10;          next  if (Date_Cmp($date,$date0)&lt;0  ||&#10;                    Date_Cmp($date,$date1)&gt;0);&#10;          push(@tmp,$date);&#10;        }&#10;        @date=@tmp;&#10;      }&#10;    }&#10;  }&#10;&#10;  @date = sort { Date_Cmp($a,$b) } @date;&#10;  return @date;&#10;}&#10;&#10;sub Date_GetPrev {&#10;  print "DEBUG: Date_GetPrev\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$dow,$today,$hr,$min,$sec)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  my($y,$m,$d,$h,$mn,$s,$err,$curr_dow,%dow,$num,$delta,$th,$tm,$ts,&#10;     $adjust,$curr)=();&#10;  $hr="00"   if (defined $hr   &amp;&amp;  $hr eq "0");&#10;  $min="00"  if (defined $min  &amp;&amp;  $min eq "0");&#10;  $sec="00"  if (defined $sec  &amp;&amp;  $sec eq "0");&#10;&#10;  if (! _Date_Split($date)) {&#10;    $date=ParseDateString($date);&#10;    return ""  if (! $date);&#10;  }&#10;  $curr=$date;&#10;  ($y,$m,$d)=( _Date_Split($date, 1) )[0..2];&#10;&#10;  if ($dow) {&#10;    $curr_dow=Date_DayOfWeek($m,$d,$y);&#10;    %dow=%{ $Lang{$Cnf{"Language"}}{"WeekH"} };&#10;    if (_IsInt($dow)) {&#10;      return ""  if ($dow&lt;1  ||  $dow&gt;7);&#10;    } else {&#10;      return ""  if (! exists $dow{lc($dow)});&#10;      $dow=$dow{lc($dow)};&#10;    }&#10;    if ($dow == $curr_dow) {&#10;      $date=_DateCalc_DateDelta($date,"-0:0:1:0:0:0:0",\$err,0)  if (! $today);&#10;      $adjust=1  if ($today==2);&#10;    } else {&#10;      $dow -= 7  if ($dow&gt;$curr_dow); # make sure previous day is less&#10;      $num = $curr_dow - $dow;&#10;      $date=_DateCalc_DateDelta($date,"-0:0:0:$num:0:0:0",\$err,0);&#10;    }&#10;    $date=Date_SetTime($date,$hr,$min,$sec)  if (defined $hr);&#10;    $date=_DateCalc_DateDelta($date,"-0:0:1:0:0:0:0",\$err,0)&#10;      if ($adjust  &amp;&amp;  Date_Cmp($date,$curr)&gt;0);&#10;&#10;  } else {&#10;    ($h,$mn,$s)=( _Date_Split($date, 1) )[3..5];&#10;    ($th,$tm,$ts)=_Date_ParseTime($hr,$min,$sec);&#10;    if ($hr) {&#10;      ($hr,$min,$sec)=($th,$tm,$ts);&#10;      $delta="-0:0:0:1:0:0:0";&#10;    } elsif ($min) {&#10;      ($hr,$min,$sec)=($h,$tm,$ts);&#10;      $delta="-0:0:0:0:1:0:0";&#10;    } elsif ($sec) {&#10;      ($hr,$min,$sec)=($h,$mn,$ts);&#10;      $delta="-0:0:0:0:0:1:0";&#10;    } else {&#10;      confess "ERROR: invalid arguments in Date_GetPrev.\n";&#10;    }&#10;&#10;    $d=Date_SetTime($date,$hr,$min,$sec);&#10;    if ($today) {&#10;      $d=_DateCalc_DateDelta($d,$delta,\$err,0)  if (Date_Cmp($d,$date)&gt;0);&#10;    } else {&#10;      $d=_DateCalc_DateDelta($d,$delta,\$err,0)  if (Date_Cmp($d,$date)&gt;=0);&#10;    }&#10;    $date=$d;&#10;  }&#10;  return $date;&#10;}&#10;&#10;sub Date_GetNext {&#10;  print "DEBUG: Date_GetNext\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$dow,$today,$hr,$min,$sec)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  my($y,$m,$d,$h,$mn,$s,$err,$curr_dow,%dow,$num,$delta,$th,$tm,$ts,&#10;     $adjust,$curr)=();&#10;  $hr="00"   if (defined $hr   &amp;&amp;  $hr eq "0");&#10;  $min="00"  if (defined $min  &amp;&amp;  $min eq "0");&#10;  $sec="00"  if (defined $sec  &amp;&amp;  $sec eq "0");&#10;&#10;  if (! _Date_Split($date)) {&#10;    $date=ParseDateString($date);&#10;    return ""  if (! $date);&#10;  }&#10;  $curr=$date;&#10;  ($y,$m,$d)=( _Date_Split($date, 1) )[0..2];&#10;&#10;  if ($dow) {&#10;    $curr_dow=Date_DayOfWeek($m,$d,$y);&#10;    %dow=%{ $Lang{$Cnf{"Language"}}{"WeekH"} };&#10;    if (_IsInt($dow)) {&#10;      return ""  if ($dow&lt;1  ||  $dow&gt;7);&#10;    } else {&#10;      return ""  if (! exists $dow{lc($dow)});&#10;      $dow=$dow{lc($dow)};&#10;    }&#10;    if ($dow == $curr_dow) {&#10;      $date=_DateCalc_DateDelta($date,"+0:0:1:0:0:0:0",\$err,0)  if (! $today);&#10;      $adjust=1  if ($today==2);&#10;    } else {&#10;      $curr_dow -= 7  if ($curr_dow&gt;$dow); # make sure next date is greater&#10;      $num = $dow - $curr_dow;&#10;      $date=_DateCalc_DateDelta($date,"+0:0:0:$num:0:0:0",\$err,0);&#10;    }&#10;    $date=Date_SetTime($date,$hr,$min,$sec)  if (defined $hr);&#10;    $date=_DateCalc_DateDelta($date,"+0:0:1:0:0:0:0",\$err,0)&#10;      if ($adjust  &amp;&amp;  Date_Cmp($date,$curr)&lt;0);&#10;&#10;  } else {&#10;    ($h,$mn,$s)=( _Date_Split($date, 1) )[3..5];&#10;    ($th,$tm,$ts)=_Date_ParseTime($hr,$min,$sec);&#10;    if ($hr) {&#10;      ($hr,$min,$sec)=($th,$tm,$ts);&#10;      $delta="+0:0:0:1:0:0:0";&#10;    } elsif ($min) {&#10;      ($hr,$min,$sec)=($h,$tm,$ts);&#10;      $delta="+0:0:0:0:1:0:0";&#10;    } elsif ($sec) {&#10;      ($hr,$min,$sec)=($h,$mn,$ts);&#10;      $delta="+0:0:0:0:0:1:0";&#10;    } else {&#10;      confess "ERROR: invalid arguments in Date_GetNext.\n";&#10;    }&#10;&#10;    $d=Date_SetTime($date,$hr,$min,$sec);&#10;    if ($today) {&#10;      $d=_DateCalc_DateDelta($d,$delta,\$err,0)  if (Date_Cmp($d,$date)&lt;0);&#10;    } else {&#10;      $d=_DateCalc_DateDelta($d,$delta,\$err,0)  if (Date_Cmp($d,$date)&lt;1);&#10;    }&#10;    $date=$d;&#10;  }&#10;&#10;  return $date;&#10;}&#10;&#10;sub Date_IsHoliday {&#10;  print "DEBUG: Date_IsHoliday\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $date=ParseDateString($date);&#10;  return undef  if (! $date);&#10;  $date=Date_SetTime($date,0,0,0);&#10;  my($y)=(_Date_Split($date, 1))[0];&#10;  _Date_UpdateHolidays($y)  if (! exists $Holiday{"dates"}{$y});&#10;  return undef  if (! exists $Holiday{"dates"}{$y}{$date});&#10;  my($name)=$Holiday{"dates"}{$y}{$date};&#10;  return ""   if (! $name);&#10;  $name;&#10;}&#10;&#10;sub Events_List {&#10;  print "DEBUG: Events_List\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my(@args)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  _Events_ParseRaw();&#10;&#10;  my($tmp,$date0,$date1,$flag);&#10;  $date0=ParseDateString($args[0]);&#10;  warn "Invalid date $args[0]", return undef  if (! $date0);&#10;&#10;  if ($#args == 0) {&#10;    return _Events_Calc($date0);&#10;  }&#10;&#10;  if ($args[1]) {&#10;    $date1=ParseDateString($args[1]);&#10;    warn "Invalid date $args[1]\n", return undef  if (! $date1);&#10;    if (Date_Cmp($date0,$date1)&gt;0) {&#10;      $tmp=$date1;&#10;      $date1=$date0;&#10;      $date0=$tmp;&#10;    }&#10;  } else {&#10;    $date0=Date_SetTime($date0,"00:00:00");&#10;    $date1=_DateCalc_DateDelta($date0,"+0:0:0:1:0:0:0");&#10;  }&#10;&#10;  $tmp=_Events_Calc($date0,$date1);&#10;&#10;  $flag=$args[2];&#10;  return $tmp  if (! $flag);&#10;&#10;  my(@tmp,%ret,$delta)=();&#10;  @tmp=@$tmp;&#10;  push(@tmp,$date1);&#10;&#10;  if ($flag==1) {&#10;    while ($#tmp&gt;0) {&#10;      ($date0,$tmp)=splice(@tmp,0,2);&#10;      $date1=$tmp[0];&#10;      $delta=_DateCalc_DateDate($date0,$date1);&#10;      foreach $flag (@$tmp) {&#10;        if (exists $ret{$flag}) {&#10;          $ret{$flag}=_DateCalc_DeltaDelta($ret{$flag},$delta);&#10;        } else {&#10;          $ret{$flag}=$delta;&#10;        }&#10;      }&#10;    }&#10;    return \%ret;&#10;&#10;  } elsif ($flag==2) {&#10;    while ($#tmp&gt;0) {&#10;      ($date0,$tmp)=splice(@tmp,0,2);&#10;      $date1=$tmp[0];&#10;      $delta=_DateCalc_DateDate($date0,$date1);&#10;      $flag=join("+",sort { Date_Cmp($a,$b) } @$tmp);&#10;      next  if (! $flag);&#10;      if (exists $ret{$flag}) {&#10;        $ret{$flag}=_DateCalc_DeltaDelta($ret{$flag},$delta);&#10;      } else {&#10;        $ret{$flag}=$delta;&#10;      }&#10;    }&#10;    return \%ret;&#10;  }&#10;&#10;  warn "Invalid flag $flag\n";&#10;  return undef;&#10;}&#10;&#10;###&#10;# NOTE: The following routines may be called in the routines below with very&#10;#       little time penalty.&#10;###&#10;sub Date_SetTime {&#10;  print "DEBUG: Date_SetTime\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$h,$mn,$s)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  my($y,$m,$d)=();&#10;&#10;  if (! _Date_Split($date)) {&#10;    $date=ParseDateString($date);&#10;    return ""  if (! $date);&#10;  }&#10;&#10;  ($y,$m,$d)=( _Date_Split($date, 1) )[0..2];&#10;  ($h,$mn,$s)=_Date_ParseTime($h,$mn,$s);&#10;&#10;  my($ampm,$wk);&#10;  return ""  if (_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk));&#10;  _Date_Join($y,$m,$d,$h,$mn,$s);&#10;}&#10;&#10;sub Date_SetDateField {&#10;  print "DEBUG: Date_SetDateField\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$field,$val,$nocheck)=@_;&#10;  my($y,$m,$d,$h,$mn,$s)=();&#10;  $nocheck=0  if (! defined $nocheck);&#10;&#10;  ($y,$m,$d,$h,$mn,$s)=_Date_Split($date);&#10;&#10;  if (! $y) {&#10;    $date=ParseDateString($date);&#10;    return "" if (! $date);&#10;    ($y,$m,$d,$h,$mn,$s)=_Date_Split($date, 1);&#10;  }&#10;&#10;  if      (lc($field) eq "y") {&#10;    $y=$val;&#10;  } elsif (lc($field) eq "m") {&#10;    $m=$val;&#10;  } elsif (lc($field) eq "d") {&#10;    $d=$val;&#10;  } elsif (lc($field) eq "h") {&#10;    $h=$val;&#10;  } elsif (lc($field) eq "mn") {&#10;    $mn=$val;&#10;  } elsif (lc($field) eq "s") {&#10;    $s=$val;&#10;  } else {&#10;    confess "ERROR: Date_SetDateField: invalid field: $field\n";&#10;  }&#10;&#10;  $date=_Date_Join($y,$m,$d,$h,$mn,$s);&#10;  return $date  if ($nocheck  ||  _Date_Split($date));&#10;  return "";&#10;}&#10;&#10;########################################################################&#10;# OTHER SUBROUTINES&#10;########################################################################&#10;# NOTE: These routines should not call any of the routines above as&#10;#       there will be a severe time penalty (and the possibility of&#10;#       infinite recursion).  The last couple routines above are&#10;#       exceptions.&#10;# NOTE: Date_Init is a special case.  It should be called (conditionally)&#10;#       in every routine that uses any variable from the Date::Manip&#10;#       namespace.&#10;########################################################################&#10;&#10;sub Date_DaysInMonth {&#10;  print "DEBUG: Date_DaysInMonth\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  my(@d_in_m)=(0,31,28,31,30,31,30,31,31,30,31,30,31);&#10;  $d_in_m[2]=29  if (Date_LeapYear($y));&#10;  return $d_in_m[$m];&#10;}&#10;&#10;sub Date_DayOfWeek {&#10;  print "DEBUG: Date_DayOfWeek\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  my($dayofweek,$dec31)=();&#10;&#10;  $dec31=5;                     # Dec 31, 1BC was Friday&#10;  $dayofweek=(Date_DaysSince1BC($m,$d,$y)+$dec31) % 7;&#10;  $dayofweek=7  if ($dayofweek==0);&#10;  return $dayofweek;&#10;}&#10;&#10;# Can't be in "use integer" because the numbers are too big.&#10;no integer;&#10;sub Date_SecsSince1970 {&#10;  print "DEBUG: Date_SecsSince1970\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y,$h,$mn,$s)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  my($sec_now,$sec_70)=();&#10;  $sec_now=(Date_DaysSince1BC($m,$d,$y)-1)*24*3600 + $h*3600 + $mn*60 + $s;&#10;# $sec_70 =(Date_DaysSince1BC(1,1,1970)-1)*24*3600;&#10;  $sec_70 =62167219200;&#10;  return ($sec_now-$sec_70);&#10;}&#10;&#10;sub Date_SecsSince1970GMT {&#10;  print "DEBUG: Date_SecsSince1970GMT\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y,$h,$mn,$s)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;&#10;  my($sec)=Date_SecsSince1970($m,$d,$y,$h,$mn,$s);&#10;  return $sec   if ($Cnf{"ConvTZ"} eq "IGNORE");&#10;&#10;  my($tz)=$Cnf{"ConvTZ"};&#10;  $tz=$Cnf{"TZ"}  if (! $tz);&#10;  $tz=$Zone{"n2o"}{lc($tz)}  if ($tz !~ /^[+-]\d{4}$/);&#10;&#10;  my($tzs)=1;&#10;  $tzs=-1 if ($tz&lt;0);&#10;  $tz=~/.(..)(..)/;&#10;  my($tzh,$tzm)=($1,$2);&#10;  $sec - $tzs*($tzh*3600+$tzm*60);&#10;}&#10;use integer;&#10;&#10;sub Date_DaysSince1BC {&#10;  print "DEBUG: Date_DaysSince1BC\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  my($Ny,$N4,$N100,$N400,$dayofyear,$days)=();&#10;  my($cc,$yy)=();&#10;&#10;  $y=~ /(\d{2})(\d{2})/;&#10;  ($cc,$yy)=($1,$2);&#10;&#10;  # Number of full years since Dec 31, 1BC (counting the year 0000).&#10;  $Ny=$y;&#10;&#10;  # Number of full 4th years (incl. 0000) since Dec 31, 1BC&#10;  $N4=($Ny-1)/4 + 1;&#10;  $N4=0         if ($y==0);&#10;&#10;  # Number of full 100th years (incl. 0000)&#10;  $N100=$cc + 1;&#10;  $N100--       if ($yy==0);&#10;  $N100=0       if ($y==0);&#10;&#10;  # Number of full 400th years (incl. 0000)&#10;  $N400=($N100-1)/4 + 1;&#10;  $N400=0       if ($y==0);&#10;&#10;  $dayofyear=Date_DayOfYear($m,$d,$y);&#10;  $days= $Ny*365 + $N4 - $N100 + $N400 + $dayofyear;&#10;&#10;  return $days;&#10;}&#10;&#10;sub Date_DayOfYear {&#10;  print "DEBUG: Date_DayOfYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  # DinM    = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)&#10;  my(@days) = ( 0, 31, 59, 90,120,151,181,212,243,273,304,334,365);&#10;  my($ly)=0;&#10;  $ly=1  if ($m&gt;2 &amp;&amp; Date_LeapYear($y));&#10;  return ($days[$m-1]+$d+$ly);&#10;}&#10;&#10;sub Date_DaysInYear {&#10;  print "DEBUG: Date_DaysInYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  return 366  if (Date_LeapYear($y));&#10;  return 365;&#10;}&#10;&#10;sub Date_WeekOfYear {&#10;  print "DEBUG: Date_WeekOfYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($m,$d,$y,$f)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;&#10;  my($day,$dow,$doy)=();&#10;  $doy=Date_DayOfYear($m,$d,$y);&#10;&#10;  # The current DayOfYear and DayOfWeek&#10;  if ($Cnf{"Jan1Week1"}) {&#10;    $day=1;&#10;  } else {&#10;    $day=4;&#10;  }&#10;  $dow=Date_DayOfWeek(1,$day,$y);&#10;&#10;  # Move back to the first day of week 1.&#10;  $f-=7  if ($f&gt;$dow);&#10;  $day-= ($dow-$f);&#10;&#10;  return 0  if ($day&gt;$doy);      # Day is in last week of previous year&#10;  return (($doy-$day)/7 + 1);&#10;}&#10;&#10;sub Date_LeapYear {&#10;  print "DEBUG: Date_LeapYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)!=4);&#10;  return 0 unless $y % 4 == 0;&#10;  return 1 unless $y % 100 == 0;&#10;  return 0 unless $y % 400 == 0;&#10;  return 1;&#10;}&#10;&#10;sub Date_DaySuffix {&#10;  print "DEBUG: Date_DaySuffix\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  return $Lang{$Cnf{"Language"}}{"DoML"}[$d-1];&#10;}&#10;&#10;sub Date_ConvTZ {&#10;  print "DEBUG: Date_ConvTZ\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$from,$to,$level)=@_;&#10;  if (not _Date_Split($date)) {&#10;    my $err = "date passed in ('$date') is not a Date::Manip object";&#10;    if (! $level) {&#10;      croak $err;&#10;    } elsif ($level==1) {&#10;      carp $err;&#10;    }&#10;    return "";&#10;  }&#10;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  my($gmt)=();&#10;&#10;  if (! $from) {&#10;&#10;    if (! $to) {&#10;      # TZ -&gt; ConvTZ&#10;      return $date  if ($Cnf{"ConvTZ"} eq "IGNORE" or ! $Cnf{"ConvTZ"});&#10;      $from=$Cnf{"TZ"};&#10;      $to=$Cnf{"ConvTZ"};&#10;&#10;    } else {&#10;      # ConvTZ,TZ -&gt; $to&#10;      $from=$Cnf{"ConvTZ"};&#10;      $from=$Cnf{"TZ"}  if (! $from);&#10;    }&#10;&#10;  } else {&#10;&#10;    if (! $to) {&#10;      # $from -&gt; ConvTZ,TZ&#10;      return $date  if ($Cnf{"ConvTZ"} eq "IGNORE");&#10;      $to=$Cnf{"ConvTZ"};&#10;      $to=$Cnf{"TZ"}  if (! $to);&#10;&#10;    } else {&#10;      # $from -&gt; $to&#10;    }&#10;  }&#10;&#10;  $to=$Zone{"n2o"}{lc($to)}&#10;    if (exists $Zone{"n2o"}{lc($to)});&#10;  $from=$Zone{"n2o"}{lc($from)}&#10;    if (exists $Zone{"n2o"}{lc($from)});&#10;  $gmt=$Zone{"n2o"}{"gmt"};&#10;&#10;  return $date  if ($from !~ /^[+-]\d{4}$/ or $to !~ /^[+-]\d{4}$/);&#10;  return $date  if ($from eq $to);&#10;&#10;  my($s1,$h1,$m1,$s2,$h2,$m2,$d,$h,$m,$sign,$delta,$err,$yr,$mon,$sec)=();&#10;  # We're going to try to do the calculation without calling DateCalc.&#10;  ($yr,$mon,$d,$h,$m,$sec)=_Date_Split($date, 1);&#10;&#10;  # Convert $date from $from to GMT&#10;  $from=~/([+-])(\d{2})(\d{2})/;&#10;  ($s1,$h1,$m1)=($1,$2,$3);&#10;  $s1= ($s1 eq "-" ? "+" : "-");   # switch sign&#10;  $sign=$s1 . "1";     # + or - 1&#10;&#10;  # and from GMT to $to&#10;  $to=~/([+-])(\d{2})(\d{2})/;&#10;  ($s2,$h2,$m2)=($1,$2,$3);&#10;&#10;  if ($s1 eq $s2) {&#10;    # Both the same sign&#10;    $m+= $sign*($m1+$m2);&#10;    $h+= $sign*($h1+$h2);&#10;  } else {&#10;    $sign=($s2 eq "-" ? +1 : -1)  if ($h1&lt;$h2  ||  ($h1==$h2 &amp;&amp; $m1&lt;$m2));&#10;    $m+= $sign*($m1-$m2);&#10;    $h+= $sign*($h1-$h2);&#10;  }&#10;&#10;  if ($m&gt;59) {&#10;    $h+= $m/60;&#10;    $m-= ($m/60)*60;&#10;  } elsif ($m&lt;0) {&#10;    $h+= ($m/60 - 1);&#10;    $m-= ($m/60 - 1)*60;&#10;  }&#10;&#10;  if ($h&gt;23) {&#10;    $delta=$h/24;&#10;    $h -= $delta*24;&#10;    if (($d + $delta) &gt; 28) {&#10;      $date=_Date_Join($yr,$mon,$d,$h,$m,$sec);&#10;      return _DateCalc_DateDelta($date,"+0:0:0:$delta:0:0:0",\$err,0);&#10;    }&#10;    $d+= $delta;&#10;  } elsif ($h&lt;0) {&#10;    $delta=-$h/24 + 1;&#10;    $h += $delta*24;&#10;    if (($d - $delta) &lt; 1) {&#10;      $date=_Date_Join($yr,$mon,$d,$h,$m,$sec);&#10;      return _DateCalc_DateDelta($date,"-0:0:0:$delta:0:0:0",\$err,0);&#10;    }&#10;    $d-= $delta;&#10;  }&#10;  return _Date_Join($yr,$mon,$d,$h,$m,$sec);&#10;}&#10;&#10;sub Date_TimeZone {&#10;  print "DEBUG: Date_TimeZone\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($null,$tz,@tz,$std,$dst,$time,$isdst,$tmp,$in)=();&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;&#10;  # Get timezones from all of the relevant places&#10;&#10;  push(@tz,$Cnf{"TZ"})  if (defined $Cnf{"TZ"});  # TZ config var&#10;  push(@tz,$ENV{"TZ"})  if (defined $ENV{"TZ"});  # TZ environ var&#10;  push(@tz,$ENV{'SYS$TIMEZONE_RULE'})&#10;    if defined $ENV{'SYS$TIMEZONE_RULE'};         # VMS TZ environ var&#10;  push(@tz,$ENV{'SYS$TIMEZONE_NAME'})&#10;    if defined $ENV{'SYS$TIMEZONE_NAME'};         # VMS TZ name environ var&#10;  push(@tz,$ENV{'UCX$TZ'})&#10;    if defined $ENV{'UCX$TZ'};                    # VMS TZ environ var&#10;  push(@tz,$ENV{'TCPIP$TZ'})&#10;    if defined $ENV{'TCPIP$TZ'};                  # VMS TZ environ var&#10;&#10;  # The `date` command... if we're doing taint checking, we need to&#10;  # always call it with a full path... otherwise, use the user's path.&#10;  #&#10;  # Microsoft operating systems don't have a date command built in.  Try&#10;  # to trap all the various ways of knowing we are on one of these systems.&#10;  #&#10;  # We'll try `date +%Z` first, and if that fails, we'll take just the&#10;  # `date` program and assume the output is of the format:&#10;  # Thu Aug 31 14:57:46 EDT 2000&#10;&#10;  unless (($^O ne 'cygwin' &amp;&amp; $^X =~ /perl\.exe$/i) or&#10;          ($OS eq "Windows") or&#10;          ($OS eq "Netware") or&#10;          ($OS eq "VMS")) {&#10;    if ($Date::Manip::NoTaint) {&#10;      if ($OS eq "VMS") {&#10;        $tz=$ENV{'SYS$TIMEZONE_NAME'};&#10;        if (! $tz) {&#10;          $tz=$ENV{'MULTINET_TIMEZONE'};&#10;          if (! $tz) {&#10;            $tz=$ENV{'SYS$TIMEZONE_DIFFERENTIAL'}/3600.; # e.g. '-4' for EDT&#10;          }&#10;        }&#10;      } else {&#10;        $tz=`date +%Z 2&gt; /dev/null`;&#10;        chomp($tz);&#10;        if (! $tz) {&#10;          $tz=`date 2&gt; /dev/null`;&#10;          chomp($tz);&#10;          $tz=(split(/\s+/,$tz))[4];&#10;        }&#10;      }&#10;      push(@tz,$tz)  if (defined $tz);&#10;    } else {&#10;      # We need to satisfy taint checking, but also look in all the&#10;      # directories in @DatePath.&#10;      #&#10;      local $ENV{PATH} = join(':', @Date::Manip::DatePath);&#10;      local $ENV{BASH_ENV} = '';&#10;      $tz=`date +%Z 2&gt; /dev/null`;&#10;      chomp($tz);&#10;      if (! $tz) {&#10;	$tz=`date 2&gt; /dev/null`;&#10;	chomp($tz);&#10;	$tz=(split(/\s+/,$tz))[4];&#10;      }&#10;      push(@tz,$tz)  if (defined $tz);&#10;    }&#10;  }&#10;&#10;  push(@tz,$main::TZ)         if (defined $main::TZ);         # $main::TZ&#10;&#10;  if (-s "/etc/TIMEZONE") {                                   # /etc/TIMEZONE&#10;    $in=new IO::File;&#10;    $in-&gt;open("/etc/TIMEZONE","r");&#10;    while (! eof($in)) {&#10;      $tmp=&lt;$in&gt;;&#10;      if ($tmp =~ /^TZ\s*=\s*(.*?)\s*$/) {&#10;        push(@tz,$1);&#10;        last;&#10;      }&#10;    }&#10;    $in-&gt;close;&#10;  }&#10;&#10;  if (-s "/etc/timezone") {                                   # /etc/timezone&#10;    $in=new IO::File;&#10;    $in-&gt;open("/etc/timezone","r");&#10;    while (! eof($in)) {&#10;      $tmp=&lt;$in&gt;;&#10;      next  if ($tmp =~ /^\s*\043/);&#10;      chomp($tmp);&#10;      if ($tmp =~ /^\s*(.*?)\s*$/) {&#10;        push(@tz,$1);&#10;        last;&#10;      }&#10;    }&#10;    $in-&gt;close;&#10;  }&#10;&#10;  # Now parse each one to find the first valid one.&#10;  foreach $tz (@tz) {&#10;    $tz =~ s/\s*$//;&#10;    $tz =~ s/^\s*//;&#10;    $tz =~ s/^://;&#10;    next  if ($tz eq "");&#10;&#10;    return uc($tz)&#10;      if (defined $Zone{"n2o"}{lc($tz)});&#10;&#10;    if ($tz =~ /^[+-]\d{4}$/) {&#10;      return $tz;&#10;    } elsif ($tz =~ /^([+-]\d{2})(?::(\d{2}))?$/) {&#10;      my($h,$m)=($1,$2);&#10;      $m="00"  if (! $m);&#10;      return "$h$m";&#10;    }&#10;&#10;    # Handle US/Eastern format&#10;    if ($tz =~ /^$Zone{"tzones"}$/i) {&#10;      $tmp=lc $1;&#10;      $tz=$Zone{"tz2z"}{$tmp};&#10;    }&#10;&#10;    # Handle STD#DST# format (and STD-#DST-# formats)&#10;    if ($tz =~ /^([a-z]+)-?\d([a-z]+)-?\d?$/i) {&#10;      ($std,$dst)=($1,$2);&#10;      next  if (! defined $Zone{"n2o"}{lc($std)} or&#10;                ! defined $Zone{"n2o"}{lc($dst)});&#10;      $time = time();&#10;      ($null,$null,$null,$null,$null,$null,$null,$null,$isdst) =&#10;        localtime($time);&#10;      return uc($dst)  if ($isdst);&#10;      return uc($std);&#10;    }&#10;  }&#10;&#10;  confess "ERROR: Date::Manip unable to determine Time Zone.\n";&#10;}&#10;&#10;# Returns 1 if $date is a work day.  If $time is non-zero, the time is&#10;# also checked to see if it falls within work hours.  Returns "" if&#10;# an invalid date is passed in.&#10;sub Date_IsWorkDay {&#10;  print "DEBUG: Date_IsWorkDay\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$time)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $date=ParseDateString($date);&#10;  return ""  if (! $date);&#10;  my($d)=$date;&#10;  $d=Date_SetTime($date,$Cnf{"WorkDayBeg"})  if (! $time);&#10;&#10;  my($y,$mon,$day,$h,$m,$s,$dow)=();&#10;  ($y,$mon,$day,$h,$m,$s)=_Date_Split($d, 1);&#10;  $dow=Date_DayOfWeek($mon,$day,$y);&#10;&#10;  return 0  if ($dow&lt;$Cnf{"WorkWeekBeg"} or&#10;                $dow&gt;$Cnf{"WorkWeekEnd"} or&#10;                "$h:$m" lt $Cnf{"WorkDayBeg"} or&#10;                "$h:$m" ge $Cnf{"WorkDayEnd"});&#10;&#10;  if (! exists $Holiday{"dates"}{$y}) {&#10;    # There will be recursion problems if we ever end up here twice.&#10;    $Holiday{"dates"}{$y}={};&#10;    _Date_UpdateHolidays($y)&#10;  }&#10;  $d=Date_SetTime($date,"00:00:00");&#10;  return 0  if (exists $Holiday{"dates"}{$y}{$d});&#10;  1;&#10;}&#10;&#10;# Finds the day $off work days from now.  If $time is passed in, we must&#10;# also take into account the time of day.&#10;#&#10;# If $time is not passed in, day 0 is today (if today is a workday) or the&#10;# next work day if it isn't.  In any case, the time of day is unaffected.&#10;#&#10;# If $time is passed in, day 0 is now (if now is part of a workday) or the&#10;# start of the very next work day.&#10;sub Date_NextWorkDay {&#10;  print "DEBUG: Date_NextWorkDay\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$off,$time)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $date=ParseDateString($date);&#10;  my($err)=();&#10;&#10;  if (! Date_IsWorkDay($date,$time)) {&#10;    if ($time) {&#10;      while (1) {&#10;        $date=Date_GetNext($date,undef,0,$Cnf{"WorkDayBeg"});&#10;        last  if (Date_IsWorkDay($date,$time));&#10;      }&#10;    } else {&#10;      while (1) {&#10;        $date=_DateCalc_DateDelta($date,"+0:0:0:1:0:0:0",\$err,0);&#10;        last  if (Date_IsWorkDay($date,$time));&#10;      }&#10;    }&#10;  }&#10;&#10;  while ($off&gt;0) {&#10;    while (1) {&#10;      $date=_DateCalc_DateDelta($date,"+0:0:0:1:0:0:0",\$err,0);&#10;      last  if (Date_IsWorkDay($date,$time));&#10;    }&#10;    $off--;&#10;  }&#10;&#10;  return $date;&#10;}&#10;&#10;# Finds the day $off work days before now.  If $time is passed in, we must&#10;# also take into account the time of day.&#10;#&#10;# If $time is not passed in, day 0 is today (if today is a workday) or the&#10;# previous work day if it isn't.  In any case, the time of day is unaffected.&#10;#&#10;# If $time is passed in, day 0 is now (if now is part of a workday) or the&#10;# end of the previous work period.  Note that since the end of a work day&#10;# will automatically be turned into the start of the next one, this time&#10;# may actually be treated as AFTER the current time.&#10;sub Date_PrevWorkDay {&#10;  print "DEBUG: Date_PrevWorkDay\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$off,$time)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $date=ParseDateString($date);&#10;  my($err)=();&#10;&#10;  if (! Date_IsWorkDay($date,$time)) {&#10;    if ($time) {&#10;      while (1) {&#10;        $date=Date_GetPrev($date,undef,0,$Cnf{"WorkDayEnd"});&#10;        last  if (Date_IsWorkDay($date,$time));&#10;      }&#10;      while (1) {&#10;        $date=Date_GetNext($date,undef,0,$Cnf{"WorkDayBeg"});&#10;        last  if (Date_IsWorkDay($date,$time));&#10;      }&#10;    } else {&#10;      while (1) {&#10;        $date=_DateCalc_DateDelta($date,"-0:0:0:1:0:0:0",\$err,0);&#10;        last  if (Date_IsWorkDay($date,$time));&#10;      }&#10;    }&#10;  }&#10;&#10;  while ($off&gt;0) {&#10;    while (1) {&#10;      $date=_DateCalc_DateDelta($date,"-0:0:0:1:0:0:0",\$err,0);&#10;      last  if (Date_IsWorkDay($date,$time));&#10;    }&#10;    $off--;&#10;  }&#10;&#10;  return $date;&#10;}&#10;&#10;# This finds the nearest workday to $date.  If $date is a workday, it&#10;# is returned.&#10;sub Date_NearestWorkDay {&#10;  print "DEBUG: Date_NearestWorkDay\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date,$tomorrow)=@_;&#10;  Date_Init()  if (! $Curr{"InitDone"});&#10;  $date=ParseDateString($date);&#10;  my($a,$b,$dela,$delb,$err)=();&#10;  $tomorrow=$Cnf{"TomorrowFirst"}  if (! defined $tomorrow);&#10;&#10;  return $date  if (Date_IsWorkDay($date));&#10;&#10;  # Find the nearest one.&#10;  if ($tomorrow) {&#10;    $dela="+0:0:0:1:0:0:0";&#10;    $delb="-0:0:0:1:0:0:0";&#10;  } else {&#10;    $dela="-0:0:0:1:0:0:0";&#10;    $delb="+0:0:0:1:0:0:0";&#10;  }&#10;  $a=$b=$date;&#10;&#10;  while (1) {&#10;    $a=_DateCalc_DateDelta($a,$dela,\$err);&#10;    return $a  if (Date_IsWorkDay($a));&#10;    $b=_DateCalc_DateDelta($b,$delb,\$err);&#10;    return $b  if (Date_IsWorkDay($b));&#10;  }&#10;}&#10;&#10;# Date_NthDayOfYear($y,$n);&#10;#   Returns a list of (YYYY,MM,DD,HH,MM,SS) for the Nth day of the year.&#10;sub Date_NthDayOfYear {&#10;  no integer;&#10;  print "DEBUG: Date_NthDayOfYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y,$n)=@_;&#10;  $y=$Curr{"Y"}  if (! $y);&#10;  $n=1       if (! defined $n  or  $n eq "");&#10;  $n+=0;     # to turn 023 into 23&#10;  $y=_Date_FixYear($y)  if (length($y)&lt;4);&#10;  my $leap=Date_LeapYear($y);&#10;  return ()  if ($n&lt;1);&#10;  return ()  if ($n &gt;= ($leap ? 367 : 366));&#10;&#10;  my(@d_in_m)=(31,28,31,30,31,30,31,31,30,31,30,31);&#10;  $d_in_m[1]=29  if ($leap);&#10;&#10;  # Calculate the hours, minutes, and seconds into the day.&#10;  my $remain=($n - int($n))*24;&#10;  my $h=int($remain);&#10;  $remain=($remain - $h)*60;&#10;  my $mn=int($remain);&#10;  $remain=($remain - $mn)*60;&#10;  my $s=$remain;&#10;&#10;  # Calculate the month and the day.&#10;  my($m,$d)=(0,0);&#10;  $n=int($n);&#10;  while ($n&gt;0) {&#10;    $m++;&#10;    if ($n&lt;=$d_in_m[0]) {&#10;      $d=int($n);&#10;      $n=0;&#10;    } else {&#10;      $n-= $d_in_m[0];&#10;      shift(@d_in_m);&#10;    }&#10;  }&#10;&#10;  ($y,$m,$d,$h,$mn,$s);&#10;}&#10;&#10;########################################################################&#10;# NOT FOR EXPORT&#10;########################################################################&#10;&#10;# This is used in Date_Init to fill in a hash based on international&#10;# data.  It takes a list of keys and values and returns both a hash&#10;# with these values and a regular expression of keys.&#10;#&#10;# IN:&#10;#   $data   = [ key1 val1 key2 val2 ... ]&#10;#   $opts   = lc     : lowercase the keys in the regexp&#10;#             sort   : sort (by length) the keys in the regexp&#10;#             back   : create a regexp with a back reference&#10;#             escape : escape all strings in the regexp&#10;#&#10;# OUT:&#10;#   $regexp = '(?:key1|key2|...)'&#10;#   $hash   = { key1=&gt;val1 key2=&gt;val2 ... }&#10;&#10;sub _Date_InitHash {&#10;  print "DEBUG: _Date_InitHash\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($data,$regexp,$opts,$hash)=@_;&#10;  my(@data)=@$data;&#10;  my($key,$val,@list)=();&#10;&#10;  # Parse the options&#10;  my($lc,$sort,$back,$escape)=(0,0,0,0);&#10;  $lc=1     if ($opts =~ /lc/i);&#10;  $sort=1   if ($opts =~ /sort/i);&#10;  $back=1   if ($opts =~ /back/i);&#10;  $escape=1 if ($opts =~ /escape/i);&#10;&#10;  # Create the hash&#10;  while (@data) {&#10;    ($key,$val,@data)=@data;&#10;    $key=lc($key)  if ($lc);&#10;    $$hash{$key}=$val;&#10;  }&#10;&#10;  # Create the regular expression&#10;  if ($regexp) {&#10;    @list=keys(%$hash);&#10;    @list=sort _sortByLength(@list)  if ($sort);&#10;    if ($escape) {&#10;      foreach $val (@list) {&#10;        $val="\Q$val\E";&#10;      }&#10;    }&#10;    if ($back) {&#10;      $$regexp="(" . join("|",@list) . ")";&#10;    } else {&#10;      $$regexp="(?:" . join("|",@list) . ")";&#10;    }&#10;  }&#10;}&#10;&#10;# This is used in Date_Init to fill in regular expressions, lists, and&#10;# hashes based on international data.  It takes a list of lists which have&#10;# to be stored as regular expressions (to find any element in the list),&#10;# lists, and hashes (indicating the location in the lists).&#10;#&#10;# IN:&#10;#   $data   = [ [ [ valA1 valA2 ... ][ valA1' valA2' ... ] ... ]&#10;#               [ [ valB1 valB2 ... ][ valB1' valB2' ... ] ... ]&#10;#               ...&#10;#               [ [ valZ1 valZ2 ... ] [valZ1' valZ1' ... ] ... ] ]&#10;#   $lists  = [ \@listA \@listB ... \@listZ ]&#10;#   $opts   = lc     : lowercase the values in the regexp&#10;#             sort   : sort (by length) the values in the regexp&#10;#             back   : create a regexp with a back reference&#10;#             escape : escape all strings in the regexp&#10;#   $hash   = [ \%hash, TYPE ]&#10;#             TYPE 0 : $hash{ valBn=&gt;n-1 }&#10;#             TYPE 1 : $hash{ valBn=&gt;n }&#10;#&#10;# OUT:&#10;#   $regexp = '(?:valA1|valA2|...|valB1|...)'&#10;#   $lists  = [ [ valA1 valA2 ... ]         # only the 1st list (or&#10;#               [ valB1 valB2 ... ] ... ]   # 2nd for int. characters)&#10;#   $hash&#10;&#10;sub _Date_InitLists {&#10;  print "DEBUG: _Date_InitLists\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($data,$regexp,$opts,$lists,$hash)=@_;&#10;  my(@data)=@$data;&#10;  my(@lists)=@$lists;&#10;  my($i,@ele,$ele,@list,$j,$tmp)=();&#10;&#10;  # Parse the options&#10;  my($lc,$sort,$back,$escape)=(0,0,0,0);&#10;  $lc=1     if ($opts =~ /lc/i);&#10;  $sort=1   if ($opts =~ /sort/i);&#10;  $back=1   if ($opts =~ /back/i);&#10;  $escape=1 if ($opts =~ /escape/i);&#10;&#10;  # Set each of the lists&#10;  if (@lists) {&#10;    confess "ERROR: _Date_InitLists: lists must be 1 per data\n"&#10;      if ($#lists != $#data);&#10;    for ($i=0; $i&lt;=$#data; $i++) {&#10;      @ele=@{ $data[$i] };&#10;      if ($Cnf{"IntCharSet"} &amp;&amp; $#ele&gt;0) {&#10;        @{ $lists[$i] } = @{ $ele[1] };&#10;      } else {&#10;        @{ $lists[$i] } = @{ $ele[0] };&#10;      }&#10;    }&#10;  }&#10;&#10;  # Create the hash&#10;  my($hashtype,$hashsave,%hash)=();&#10;  if (@$hash) {&#10;    ($hash,$hashtype)=@$hash;&#10;    $hashsave=1;&#10;  } else {&#10;    $hashtype=0;&#10;    $hashsave=0;&#10;  }&#10;  for ($i=0; $i&lt;=$#data; $i++) {&#10;    @ele=@{ $data[$i] };&#10;    foreach $ele (@ele) {&#10;      @list = @{ $ele };&#10;      for ($j=0; $j&lt;=$#list; $j++) {&#10;        $tmp=$list[$j];&#10;        next  if (! $tmp);&#10;        $tmp=lc($tmp)  if ($lc);&#10;        $hash{$tmp}= $j+$hashtype;&#10;      }&#10;    }&#10;  }&#10;  %$hash = %hash  if ($hashsave);&#10;&#10;  # Create the regular expression&#10;  if ($regexp) {&#10;    @list=keys(%hash);&#10;    @list=sort _sortByLength(@list)  if ($sort);&#10;    if ($escape) {&#10;      foreach $ele (@list) {&#10;        $ele="\Q$ele\E";&#10;      }&#10;    }&#10;    if ($back) {&#10;      $$regexp="(" . join("|",@list) . ")";&#10;    } else {&#10;      $$regexp="(?:" . join("|",@list) . ")";&#10;    }&#10;  }&#10;}&#10;&#10;# This is used in Date_Init to fill in regular expressions and lists based&#10;# on international data.  This takes a list of strings and returns a regular&#10;# expression (to find any one of them).&#10;#&#10;# IN:&#10;#   $data   = [ string1 string2 ... ]&#10;#   $opts   = lc     : lowercase the values in the regexp&#10;#             sort   : sort (by length) the values in the regexp&#10;#             back   : create a regexp with a back reference&#10;#             escape : escape all strings in the regexp&#10;#&#10;# OUT:&#10;#   $regexp = '(string1|string2|...)'&#10;&#10;sub _Date_InitStrings {&#10;  print "DEBUG: _Date_InitStrings\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($data,$regexp,$opts)=@_;&#10;  my(@list)=@{ $data };&#10;&#10;  # Parse the options&#10;  my($lc,$sort,$back,$escape)=(0,0,0,0);&#10;  $lc=1     if ($opts =~ /lc/i);&#10;  $sort=1   if ($opts =~ /sort/i);&#10;  $back=1   if ($opts =~ /back/i);&#10;  $escape=1 if ($opts =~ /escape/i);&#10;&#10;  # Create the regular expression&#10;  my($ele)=();&#10;  @list=sort _sortByLength(@list)  if ($sort);&#10;  if ($escape) {&#10;    foreach $ele (@list) {&#10;      $ele="\Q$ele\E";&#10;    }&#10;  }&#10;  if ($back) {&#10;    $$regexp="(" . join("|",@list) . ")";&#10;  } else {&#10;    $$regexp="(?:" . join("|",@list) . ")";&#10;  }&#10;  $$regexp=lc($$regexp)  if ($lc);&#10;}&#10;&#10;# items is passed in (either as a space separated string, or a reference to&#10;# a list) and a regular expression which matches any one of the items is&#10;# prepared.  The regular expression will be of one of the forms:&#10;#   "(a|b)"       @list not empty, back option included&#10;#   "(?:a|b)"     @list not empty&#10;#   "()"          @list empty,     back option included&#10;#   ""            @list empty&#10;# $options is a string which contains any of the following strings:&#10;#   back     : the regular expression has a backreference&#10;#   opt      : the regular expression is optional and a "?" is appended in&#10;#              the first two forms&#10;#   optws    : the regular expression is optional and may be replaced by&#10;#              whitespace&#10;#   optWs    : the regular expression is optional, but if not present, must&#10;#              be replaced by whitespace&#10;#   sort     : the items in the list are sorted by length (longest first)&#10;#   lc       : the string is lowercased&#10;#   under    : any underscores are converted to spaces&#10;#   pre      : it may be preceded by whitespace&#10;#   Pre      : it must be preceded by whitespace&#10;#   PRE      : it must be preceded by whitespace or the start&#10;#   post     : it may be followed by whitespace&#10;#   Post     : it must be followed by whitespace&#10;#   POST     : it must be followed by whitespace or the end&#10;# Spaces due to pre/post options will not be included in the back reference.&#10;#&#10;# If $array is included, then the elements will also be returned as a list.&#10;# $array is a string which may contain any of the following:&#10;#   keys     : treat the list as a hash and only the keys go into the regexp&#10;#   key0     : treat the list as the values of a hash with keys 0 .. N-1&#10;#   key1     : treat the list as the values of a hash with keys 1 .. N&#10;#   val0     : treat the list as the keys of a hash with values 0 .. N-1&#10;#   val1     : treat the list as the keys of a hash with values 1 .. N&#10;&#10;#    _Date_InitLists([$lang{"month_name"},$lang{"month_abb"}],&#10;#             [\$Month,"lc,sort,back"],&#10;#             [\@Month,\@Mon],&#10;#             [\%Month,1]);&#10;&#10;# This is used in Date_Init to prepare regular expressions.  A list of&#10;# items is passed in (either as a space separated string, or a reference to&#10;# a list) and a regular expression which matches any one of the items is&#10;# prepared.  The regular expression will be of one of the forms:&#10;#   "(a|b)"       @list not empty, back option included&#10;#   "(?:a|b)"     @list not empty&#10;#   "()"          @list empty,     back option included&#10;#   ""            @list empty&#10;# $options is a string which contains any of the following strings:&#10;#   back     : the regular expression has a backreference&#10;#   opt      : the regular expression is optional and a "?" is appended in&#10;#              the first two forms&#10;#   optws    : the regular expression is optional and may be replaced by&#10;#              whitespace&#10;#   optWs    : the regular expression is optional, but if not present, must&#10;#              be replaced by whitespace&#10;#   sort     : the items in the list are sorted by length (longest first)&#10;#   lc       : the string is lowercased&#10;#   under    : any underscores are converted to spaces&#10;#   pre      : it may be preceded by whitespace&#10;#   Pre      : it must be preceded by whitespace&#10;#   PRE      : it must be preceded by whitespace or the start&#10;#   post     : it may be followed by whitespace&#10;#   Post     : it must be followed by whitespace&#10;#   POST     : it must be followed by whitespace or the end&#10;# Spaces due to pre/post options will not be included in the back reference.&#10;#&#10;# If $array is included, then the elements will also be returned as a list.&#10;# $array is a string which may contain any of the following:&#10;#   keys     : treat the list as a hash and only the keys go into the regexp&#10;#   key0     : treat the list as the values of a hash with keys 0 .. N-1&#10;#   key1     : treat the list as the values of a hash with keys 1 .. N&#10;#   val0     : treat the list as the keys of a hash with values 0 .. N-1&#10;#   val1     : treat the list as the keys of a hash with values 1 .. N&#10;sub _Date_Regexp {&#10;  print "DEBUG: _Date_Regexp\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($list,$options,$array)=@_;&#10;  my(@list,$ret,%hash,$i)=();&#10;  local($_)=();&#10;  $options=""  if (! defined $options);&#10;  $array=""    if (! defined $array);&#10;&#10;  my($sort,$lc,$under)=(0,0,0);&#10;  $sort =1  if ($options =~ /sort/i);&#10;  $lc   =1  if ($options =~ /lc/i);&#10;  $under=1  if ($options =~ /under/i);&#10;  my($back,$opt,$pre,$post,$ws)=("?:","","","","");&#10;  $back =""          if ($options =~ /back/i);&#10;  $opt  ="?"         if ($options =~ /opt/i);&#10;  $pre  ='\s*'       if ($options =~ /pre/);&#10;  $pre  ='\s+'       if ($options =~ /Pre/);&#10;  $pre  ='(?:\s+|^)' if ($options =~ /PRE/);&#10;  $post ='\s*'       if ($options =~ /post/);&#10;  $post ='\s+'       if ($options =~ /Post/);&#10;  $post ='(?:$|\s+)' if ($options =~ /POST/);&#10;  $ws   ='\s*'       if ($options =~ /optws/);&#10;  $ws   ='\s+'       if ($options =~ /optws/);&#10;&#10;  my($hash,$keys,$key0,$key1,$val0,$val1)=(0,0,0,0,0,0);&#10;  $keys =1     if ($array =~ /keys/i);&#10;  $key0 =1     if ($array =~ /key0/i);&#10;  $key1 =1     if ($array =~ /key1/i);&#10;  $val0 =1     if ($array =~ /val0/i);&#10;  $val1 =1     if ($array =~ /val1/i);&#10;  $hash =1     if ($keys or $key0 or $key1 or $val0 or $val1);&#10;&#10;  my($ref)=ref $list;&#10;  if (! $ref) {&#10;    $list =~ s/\s*$//;&#10;    $list =~ s/^\s*//;&#10;    $list =~ s/\s+/&amp;&amp;&amp;/g;&#10;  } elsif ($ref eq "ARRAY") {&#10;    $list = join("&amp;&amp;&amp;",@$list);&#10;  } else {&#10;    confess "ERROR: _Date_Regexp.\n";&#10;  }&#10;&#10;  if (! $list) {&#10;    if ($back eq "") {&#10;      return "()";&#10;    } else {&#10;      return "";&#10;    }&#10;  }&#10;&#10;  $list=lc($list)  if ($lc);&#10;  $list=~ s/_/ /g  if ($under);&#10;  @list=split(/&amp;&amp;&amp;/,$list);&#10;  if ($keys) {&#10;    %hash=@list;&#10;    @list=keys %hash;&#10;  } elsif ($key0 or $key1 or $val0 or $val1) {&#10;    $i=0;&#10;    $i=1  if ($key1 or $val1);&#10;    if ($key0 or $key1) {&#10;      %hash= map { $_,$i++ } @list;&#10;    } else {&#10;      %hash= map { $i++,$_ } @list;&#10;    }&#10;  }&#10;  @list=sort _sortByLength(@list)  if ($sort);&#10;&#10;  $ret="($back" . join("|",@list) . ")";&#10;  $ret="(?:$pre$ret$post)"  if ($pre or $post);&#10;  $ret.=$opt;&#10;  $ret="(?:$ret|$ws)"  if ($ws);&#10;&#10;  if ($array and $hash) {&#10;    return ($ret,%hash);&#10;  } elsif ($array) {&#10;    return ($ret,@list);&#10;  } else {&#10;    return $ret;&#10;  }&#10;}&#10;&#10;# This will produce a delta with the correct number of signs.  At most two&#10;# signs will be in it normally (one before the year, and one in front of&#10;# the day), but if appropriate, signs will be in front of all elements.&#10;# Also, as many of the signs will be equivalent as possible.&#10;sub _Delta_Normalize {&#10;  print "DEBUG: _Delta_Normalize\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($delta,$mode)=@_;&#10;  return "" if (! $delta);&#10;  return "+0:+0:+0:+0:+0:+0:+0"&#10;    if ($delta =~ /^([+-]?0+:){6}[+-]?0+$/ and $Cnf{"DeltaSigns"});&#10;  return "+0:0:0:0:0:0:0" if ($delta =~ /^([+-]?0+:){6}[+-]?0+$/);&#10;&#10;  my($tmp,$sign1,$sign2,$len)=();&#10;&#10;  # Calculate the length of the day in minutes&#10;  $len=24*60;&#10;  $len=$Curr{"WDlen"}  if ($mode==2 || $mode==3);&#10;&#10;  # We have to get the sign of every component explicitely so that a "-0"&#10;  # or "+0" doesn't get lost by treating it numerically (i.e. "-0:0:2" must&#10;  # be a negative delta).&#10;&#10;  my($y,$mon,$w,$d,$h,$m,$s)=_Delta_Split($delta);&#10;&#10;  # We need to make sure that the signs of all parts of a delta are the&#10;  # same.  The easiest way to do this is to convert all of the large&#10;  # components to the smallest ones, then convert the smaller components&#10;  # back to the larger ones.&#10;&#10;  # Do the year/month part&#10;&#10;  $mon += $y*12;                         # convert y to m&#10;  $sign1="+";&#10;  if ($mon&lt;0) {&#10;    $mon *= -1;&#10;    $sign1="-";&#10;  }&#10;&#10;  $y    = $mon/12;                       # convert m to y&#10;  $mon -= $y*12;&#10;&#10;  $y=0    if ($y eq "-0");               # get around silly -0 problem&#10;  $mon=0  if ($mon eq "-0");&#10;&#10;  # Do the wk/day/hour/min/sec part&#10;&#10;  {&#10;    # Unfortunately, $s is overflowing for dates more than ~70 years&#10;    # apart.&#10;    no integer;&#10;&#10;    if ($mode==3 || $mode==2) {&#10;      $s += $d*$len*60 + $h*3600 + $m*60;        # convert d/h/m to s&#10;    } else {&#10;      $s += ($d+7*$w)*$len*60 + $h*3600 + $m*60; # convert w/d/h/m to s&#10;    }&#10;    $sign2="+";&#10;    if ($s&lt;0) {&#10;      $s*=-1;&#10;      $sign2="-";&#10;    }&#10;&#10;    $m  = int($s/60);                    # convert s to m&#10;    $s -= $m*60;&#10;    $d  = int($m/$len);                  # convert m to d&#10;    $m -= $d*$len;&#10;&#10;    # The rest should be fine.&#10;  }&#10;  $h  = $m/60;                           # convert m to h&#10;  $m -= $h*60;&#10;  if ($mode == 3 || $mode == 2) {&#10;    $w  = $w*1;                          # get around +0 problem&#10;  } else {&#10;    $w  = $d/7;                          # convert d to w&#10;    $d -= $w*7;&#10;  }&#10;&#10;  $w=0    if ($w eq "-0");               # get around silly -0 problem&#10;  $d=0    if ($d eq "-0");&#10;  $h=0    if ($h eq "-0");&#10;  $m=0    if ($m eq "-0");&#10;  $s=0    if ($s eq "-0");&#10;&#10;  # Only include two signs if necessary&#10;  $sign1=$sign2  if ($y==0 and $mon==0);&#10;  $sign2=$sign1  if ($w==0 and $d==0 and $h==0 and $m==0 and $s==0);&#10;  $sign2=""  if ($sign1 eq $sign2  and  ! $Cnf{"DeltaSigns"});&#10;&#10;  if ($Cnf{"DeltaSigns"}) {&#10;    return "$sign1$y:$sign1$mon:$sign2$w:$sign2$d:$sign2$h:$sign2$m:$sign2$s";&#10;  } else {&#10;    return "$sign1$y:$mon:$sign2$w:$d:$h:$m:$s";&#10;  }&#10;}&#10;&#10;# This checks a delta to make sure it is valid.  If it is, it splits&#10;# it and returns the elements with a sign on each.  The 2nd argument&#10;# specifies the default sign.  Blank elements are set to 0.  If the&#10;# third element is non-nil, exactly 7 elements must be included.&#10;sub _Delta_Split {&#10;  print "DEBUG: _Delta_Split\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($delta,$sign,$exact)=@_;&#10;  my(@delta)=split(/:/,$delta);&#10;  return ()  if ($exact  and $#delta != 6);&#10;  my($i)=();&#10;  $sign="+"  if (! defined $sign);&#10;  for ($i=0; $i&lt;=$#delta; $i++) {&#10;    $delta[$i]="0"  if (! $delta[$i]);&#10;    return ()  if ($delta[$i] !~ /^[+-]?\d+$/);&#10;    $sign = ($delta[$i] =~ s/^([+-])// ? $1 : $sign);&#10;    $delta[$i] = $sign.$delta[$i];&#10;  }&#10;  @delta;&#10;}&#10;&#10;# Reads up to 3 arguments.  $h may contain the time in any international&#10;# format.  Any empty elements are set to 0.&#10;sub _Date_ParseTime {&#10;  print "DEBUG: _Date_ParseTime\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($h,$m,$s)=@_;&#10;  my($t)=_CheckTime("one");&#10;&#10;  if (defined $h  and  $h =~ /$t/) {&#10;    $h=$1;&#10;    $m=$2;&#10;    $s=$3   if (defined $3);&#10;  }&#10;  $h="00"  if (! defined $h);&#10;  $m="00"  if (! defined $m);&#10;  $s="00"  if (! defined $s);&#10;&#10;  ($h,$m,$s);&#10;}&#10;&#10;# Forms a date with the 6 elements passed in (all of which must be defined).&#10;# No check as to validity is made.&#10;sub _Date_Join {&#10;  print "DEBUG: _Date_Join\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  foreach (0 .. $#_) {&#10;      croak "undefined arg $_ to _Date_Join()" if not defined $_[$_];&#10;  }&#10;  my($y,$m,$d,$h,$mn,$s)=@_;&#10;  my($ym,$md,$dh,$hmn,$mns)=();&#10;&#10;  if      ($Cnf{"Internal"} == 0) {&#10;    $ym=$md=$dh="";&#10;    $hmn=$mns=":";&#10;&#10;  } elsif ($Cnf{"Internal"} == 1) {&#10;    $ym=$md=$dh=$hmn=$mns="";&#10;&#10;  } elsif ($Cnf{"Internal"} == 2) {&#10;    $ym=$md="-";&#10;    $dh=" ";&#10;    $hmn=$mns=":";&#10;&#10;  } else {&#10;    confess "ERROR: Invalid internal format in _Date_Join.\n";&#10;  }&#10;  $m="0$m"    if (length($m)==1);&#10;  $d="0$d"    if (length($d)==1);&#10;  $h="0$h"    if (length($h)==1);&#10;  $mn="0$mn"  if (length($mn)==1);&#10;  $s="0$s"    if (length($s)==1);&#10;  "$y$ym$m$md$d$dh$h$hmn$mn$mns$s";&#10;}&#10;&#10;# This checks a time.  If it is valid, it splits it and returns 3 elements.&#10;# If "one" or "two" is passed in, a regexp with 1/2 or 2 digit hours is&#10;# returned.&#10;sub _CheckTime {&#10;  print "DEBUG: _CheckTime\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($time)=@_;&#10;  my($h)='(?:0?[0-9]|1[0-9]|2[0-3])';&#10;  my($h2)='(?:0[0-9]|1[0-9]|2[0-3])';&#10;  my($m)='[0-5][0-9]';&#10;  my($s)=$m;&#10;  my($hm)="(?:". $Lang{$Cnf{"Language"}}{"SepHM"} ."|:)";&#10;  my($ms)="(?:". $Lang{$Cnf{"Language"}}{"SepMS"} ."|:)";&#10;  my($ss)=$Lang{$Cnf{"Language"}}{"SepSS"};&#10;  my($t)="^($h)$hm($m)(?:$ms($s)(?:$ss\\d+)?)?\$";&#10;  if ($time eq "one") {&#10;    return $t;&#10;  } elsif ($time eq "two") {&#10;    $t="^($h2)$hm($m)(?:$ms($s)(?:$ss\\d+)?)?\$";&#10;    return $t;&#10;  }&#10;&#10;  if ($time =~ /$t/i) {&#10;    ($h,$m,$s)=($1,$2,$3);&#10;    $h="0$h" if (length($h)&lt;2);&#10;    $m="0$m" if (length($m)&lt;2);&#10;    $s="00"  if (! defined $s);&#10;    return ($h,$m,$s);&#10;  } else {&#10;    return ();&#10;  }&#10;}&#10;&#10;# This checks a recurrence.  If it is valid, it splits it and returns the&#10;# elements.  Otherwise, it returns an empty list.&#10;#    ($recur0,$recur1,$flags,$dateb,$date0,$date1)=_Recur_Split($recur);&#10;sub _Recur_Split {&#10;  print "DEBUG: _Recur_Split\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($recur)=@_;&#10;  my(@ret,@tmp);&#10;&#10;  my($R)  = '(\*?(?:[-,0-9]+[:\*]){6}[-,0-9]+)';&#10;  my($F)  = '(?:\*([^*]*))';&#10;  my($DB,$D0,$D1);&#10;  $DB=$D0=$D1=$F;&#10;&#10;  if ($recur =~ /^$R$F?$DB?$D0?$D1?$/) {&#10;    @ret=($1,$2,$3,$4,$5);&#10;    @tmp=split(/\*/,shift(@ret));&#10;    return ()  if ($#tmp&gt;1);&#10;    return (@tmp,"",@ret)  if ($#tmp==0);&#10;    return (@tmp,@ret);&#10;  }&#10;  return ();&#10;}&#10;&#10;# This checks a date.  If it is valid, it splits it and returns the elements.&#10;#&#10;# The optional second argument says 'I really expect this to be a&#10;# valid Date::Manip object, please throw an exception if it is not'.&#10;# Otherwise, if the date passed in is undef or '', a regular&#10;# expression for the date is returned; if the string is nonempty but&#10;# still not valid, () is returned.&#10;#&#10;sub _Date_Split {&#10;  print "DEBUG: _Date_Split\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($date, $definitely_valid)=@_;&#10;  $definitely_valid = 0 if not defined $definitely_valid;&#10;  my($ym,$md,$dh,$hmn,$mns)=();&#10;  my($y)='(\d{4})';&#10;  my($m)='(0[1-9]|1[0-2])';&#10;  my($d)='(0[1-9]|[1-2][0-9]|3[0-1])';&#10;  my($h)='([0-1][0-9]|2[0-3])';&#10;  my($mn)='([0-5][0-9])';&#10;  my($s)=$mn;&#10;&#10;  if      ($Cnf{"Internal"} == 0) {&#10;    $ym=$md=$dh="";&#10;    $hmn=$mns=":";&#10;&#10;  } elsif ($Cnf{"Internal"} == 1) {&#10;    $ym=$md=$dh=$hmn=$mns="";&#10;&#10;  } elsif ($Cnf{"Internal"} == 2) {&#10;    $ym=$md="-";&#10;    $dh=" ";&#10;    $hmn=$mns=":";&#10;&#10;  } else {&#10;    confess "ERROR: Invalid internal format in _Date_Split.\n";&#10;  }&#10;&#10;  my($t)="^$y$ym$m$md$d$dh$h$hmn$mn$mns$s\$";&#10;&#10;  if (not defined $date or $date eq '') {&#10;      if ($definitely_valid) {&#10;	  die "bad date '$date'";&#10;      } else {&#10;	  return $t;&#10;      }&#10;  }&#10;&#10;  if ($date =~ /$t/) {&#10;    ($y,$m,$d,$h,$mn,$s)=($1,$2,$3,$4,$5,$6);&#10;    my(@d_in_m)=(0,31,28,31,30,31,30,31,31,30,31,30,31);&#10;    $d_in_m[2]=29  if (Date_LeapYear($y));&#10;    if ($d&gt;$d_in_m[$m]) {&#10;	my $msg = "invalid date $date: day $d of month $m, but only $d_in_m[$m] days in that month";&#10;	if ($definitely_valid) {&#10;	    die $msg;&#10;	}&#10;	else {&#10;	    warn $msg;&#10;	    return ();&#10;	}&#10;    }&#10;    return ($y,$m,$d,$h,$mn,$s);&#10;  }&#10;&#10;  if ($definitely_valid) {&#10;      die "invalid date $date: doesn't match regexp $t";&#10;  }&#10;  return ();&#10;}&#10;&#10;# This returns the date easter occurs on for a given year as ($month,$day).&#10;# This is from the Calendar FAQ.&#10;sub _Date_Easter {&#10;  my($y)=@_;&#10;  $y=_Date_FixYear($y)  if (length($y)==2);&#10;&#10;  my($c) = $y/100;&#10;  my($g) = $y % 19;&#10;  my($k) = ($c-17)/25;&#10;  my($i) = ($c - $c/4 - ($c-$k)/3 + 19*$g + 15) % 30;&#10;  $i     = $i - ($i/28)*(1 - ($i/28)*(29/($i+1))*((21-$g)/11));&#10;  my($j) = ($y + $y/4 + $i + 2 - $c + $c/4) % 7;&#10;  my($l) = $i-$j;&#10;  my($m) = 3 + ($l+40)/44;&#10;  my($d) = $l + 28 - 31*($m/4);&#10;  return ($m,$d);&#10;}&#10;&#10;# This takes a list of years, months, WeekOfMonth's, and DayOfWeek's, and&#10;# returns a list of dates.  Optionally, a list of dates can be passed in as&#10;# the 1st argument (with the 2nd argument the null list) and the year/month&#10;# of these will be used.&#10;sub _Date_Recur_WoM {&#10;  my($y,$m,$w,$d)=@_;&#10;  my(@y)=@$y;&#10;  my(@m)=@$m;&#10;  my(@w)=@$w;&#10;  my(@d)=@$d;&#10;  my($date0,$date1,@tmp,@date,$d0,$d1,@tmp2)=();&#10;&#10;  if (@m) {&#10;    foreach $m (@m) {&#10;      return ()  if (! _IsInt($m,1,12));&#10;    }&#10;&#10;    @tmp=@tmp2=();&#10;    foreach $y (@y) {&#10;      foreach $m (@m) {&#10;        push(@tmp,$y);&#10;        push(@tmp2,$m);&#10;      }&#10;    }&#10;&#10;    @y=@tmp;&#10;    @m=@tmp2;&#10;&#10;  } else {&#10;    foreach $d0 (@y) {&#10;      @tmp=_Date_Split($d0);&#10;      return ()  if (! @tmp);&#10;      push(@tmp2,$tmp[0]);&#10;      push(@m,$tmp[1]);&#10;    }&#10;    @y=@tmp2;&#10;  }&#10;&#10;  return ()  if (! @w);&#10;  foreach $w (@w) {&#10;    return ()  if ($w==0  ||  ! _IsInt($w,-5,5));&#10;  }&#10;&#10;  if (@d) {&#10;    foreach $d (@d) {&#10;      return ()  if ($d==0  ||  ! _IsInt($d,-7,7));&#10;      $d += 8  if ($d &lt; 0);&#10;    }&#10;  }&#10;&#10;  @date=();&#10;  foreach $y (@y) {&#10;    $m=shift(@m);&#10;&#10;    # Find 1st day of this month and next month&#10;    $date0=_Date_Join($y,$m,1,0,0,0);&#10;    $date1=_DateCalc_DateDelta($date0,"+0:1:0:0:0:0:0");&#10;&#10;    foreach $d (@d) {&#10;      # Find 1st occurence of DOW (in both months)&#10;      $d0=Date_GetNext($date0,$d,1);&#10;      $d1=Date_GetNext($date1,$d,1);&#10;&#10;      @tmp=();&#10;      while (Date_Cmp($d0,$d1)&lt;0) {&#10;        push(@tmp,$d0);&#10;        $d0=_DateCalc_DateDelta($d0,"+0:0:1:0:0:0:0");&#10;      }&#10;&#10;      @tmp2=();&#10;      foreach $w (@w) {&#10;        if ($w&gt;0) {&#10;          next  if ($w &gt; $#tmp+1);&#10;          push(@tmp2,$tmp[$w-1]);&#10;        } else {&#10;          next  if (-$w &gt; $#tmp+1);&#10;          push(@tmp2,$tmp[$#tmp+1+$w]);&#10;        }&#10;      }&#10;      @tmp2=sort { Date_Cmp($a,$b) } @tmp2;&#10;      push(@date,@tmp2);&#10;    }&#10;  }&#10;&#10;  @date;&#10;}&#10;&#10;# This returns a sorted list of dates formed by adding/subtracting&#10;# $delta to $dateb in the range $date0&lt;=$d&lt;$dateb.  The first date in&#10;# the list is actually the first date&lt;$date0 and the last date in the&#10;# list is the first date&gt;=$date1 (because sometimes the set part will&#10;# move the date back into the range).&#10;sub _Date_Recur {&#10;  my($date0,$date1,$dateb,$delta)=@_;&#10;  my(@ret,$d)=();&#10;&#10;  while (Date_Cmp($dateb,$date0)&lt;0) {&#10;    $dateb=_DateCalc_DateDelta($dateb,$delta);&#10;  }&#10;  while (Date_Cmp($dateb,$date1)&gt;=0) {&#10;    $dateb=_DateCalc_DateDelta($dateb,"-$delta");&#10;  }&#10;&#10;  # Add the dates $date0..$dateb&#10;  $d=$dateb;&#10;  while (Date_Cmp($d,$date0)&gt;=0) {&#10;    unshift(@ret,$d);&#10;    $d=_DateCalc_DateDelta($d,"-$delta");&#10;  }&#10;  # Add the first date earler than the range&#10;  unshift(@ret,$d);&#10;&#10;  # Add the dates $dateb..$date1&#10;  $d=_DateCalc_DateDelta($dateb,$delta);&#10;  while (Date_Cmp($d,$date1)&lt;0) {&#10;    push(@ret,$d);&#10;    $d=_DateCalc_DateDelta($d,$delta);&#10;  }&#10;  # Add the first date later than the range&#10;  push(@ret,$d);&#10;&#10;  @ret;&#10;}&#10;&#10;# This sets the values in each date of a recurrence.&#10;#&#10;# $h,$m,$s can each be values or lists "1-2,4".  If any are equal to "-1",&#10;# they are not set (and none of the larger elements are set).&#10;sub _Date_RecurSetTime {&#10;  my($date0,$date1,$dates,$h,$m,$s)=@_;&#10;  my(@dates)=@$dates;&#10;  my(@h,@m,@s,$date,@tmp)=();&#10;&#10;  $m="-1"  if ($s eq "-1");&#10;  $h="-1"  if ($m eq "-1");&#10;&#10;  if ($h ne "-1") {&#10;    @h=_ReturnList($h);&#10;    return ()  if ! (@h);&#10;    @h=sort { $a&lt;=&gt;$b } (@h);&#10;&#10;    @tmp=();&#10;    foreach $date (@dates) {&#10;      foreach $h (@h) {&#10;        push(@tmp,Date_SetDateField($date,"h",$h,1));&#10;      }&#10;    }&#10;    @dates=@tmp;&#10;  }&#10;&#10;  if ($m ne "-1") {&#10;    @m=_ReturnList($m);&#10;    return ()  if ! (@m);&#10;    @m=sort { $a&lt;=&gt;$b } (@m);&#10;&#10;    @tmp=();&#10;    foreach $date (@dates) {&#10;      foreach $m (@m) {&#10;        push(@tmp,Date_SetDateField($date,"mn",$m,1));&#10;      }&#10;    }&#10;    @dates=@tmp;&#10;  }&#10;&#10;  if ($s ne "-1") {&#10;    @s=_ReturnList($s);&#10;    return ()  if ! (@s);&#10;    @s=sort { $a&lt;=&gt;$b } (@s);&#10;&#10;    @tmp=();&#10;    foreach $date (@dates) {&#10;      foreach $s (@s) {&#10;        push(@tmp,Date_SetDateField($date,"s",$s,1));&#10;      }&#10;    }&#10;    @dates=@tmp;&#10;  }&#10;&#10;  @tmp=();&#10;  foreach $date (@dates) {&#10;    push(@tmp,$date)  if (Date_Cmp($date,$date0)&gt;=0  &amp;&amp;&#10;                          Date_Cmp($date,$date1)&lt;0  &amp;&amp;&#10;                          _Date_Split($date));&#10;  }&#10;&#10;  @tmp;&#10;}&#10;&#10;sub _DateCalc_DateDate {&#10;  print "DEBUG: _DateCalc_DateDate\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($D1,$D2,$mode)=@_;&#10;  my(@d_in_m)=(0,31,28,31,30,31,30,31,31,30,31,30,31);&#10;  $mode=0  if (! defined $mode);&#10;&#10;  # Exact mode&#10;  if ($mode==0) {&#10;    my($y1,$m1,$d1,$h1,$mn1,$s1)=_Date_Split($D1, 1);&#10;    my($y2,$m2,$d2,$h2,$mn2,$s2)=_Date_Split($D2, 1);&#10;    my($i,@delta,$d,$delta,$y)=();&#10;&#10;    # form the delta for hour/min/sec&#10;    $delta[4]=$h2-$h1;&#10;    $delta[5]=$mn2-$mn1;&#10;    $delta[6]=$s2-$s1;&#10;&#10;    # form the delta for yr/mon/day&#10;    $delta[0]=$delta[1]=0;&#10;    $d=0;&#10;    if ($y2&gt;$y1) {&#10;      $d=Date_DaysInYear($y1) - Date_DayOfYear($m1,$d1,$y1);&#10;      $d+=Date_DayOfYear($m2,$d2,$y2);&#10;      for ($y=$y1+1; $y&lt;$y2; $y++) {&#10;        $d+= Date_DaysInYear($y);&#10;      }&#10;    } elsif ($y2&lt;$y1) {&#10;      $d=Date_DaysInYear($y2) - Date_DayOfYear($m2,$d2,$y2);&#10;      $d+=Date_DayOfYear($m1,$d1,$y1);&#10;      for ($y=$y2+1; $y&lt;$y1; $y++) {&#10;        $d+= Date_DaysInYear($y);&#10;      }&#10;      $d *= -1;&#10;    } else {&#10;      $d=Date_DayOfYear($m2,$d2,$y2) - Date_DayOfYear($m1,$d1,$y1);&#10;    }&#10;    $delta[2]=0;&#10;    $delta[3]=$d;&#10;&#10;    for ($i=0; $i&lt;7; $i++) {&#10;      $delta[$i]="+".$delta[$i]  if ($delta[$i]&gt;=0);&#10;    }&#10;&#10;    $delta=join(":",@delta);&#10;    $delta=_Delta_Normalize($delta,0);&#10;    return $delta;&#10;  }&#10;&#10;  my($date1,$date2)=($D1,$D2);&#10;  my($tmp,$sign,$err,@tmp)=();&#10;&#10;  # make sure both are work days&#10;  if ($mode==2 || $mode==3) {&#10;    $date1=Date_NextWorkDay($date1,0,1);&#10;    $date2=Date_NextWorkDay($date2,0,1);&#10;  }&#10;&#10;  # make sure date1 comes before date2&#10;  if (Date_Cmp($date1,$date2)&gt;0) {&#10;    $sign="-";&#10;    $tmp=$date1;&#10;    $date1=$date2;&#10;    $date2=$tmp;&#10;  } else {&#10;    $sign="+";&#10;  }&#10;  if (Date_Cmp($date1,$date2)==0) {&#10;    return "+0:+0:+0:+0:+0:+0:+0"  if ($Cnf{"DeltaSigns"});&#10;    return "+0:0:0:0:0:0:0";&#10;  }&#10;&#10;  my($y1,$m1,$d1,$h1,$mn1,$s1)=_Date_Split($date1, 1);&#10;  my($y2,$m2,$d2,$h2,$mn2,$s2)=_Date_Split($date2, 1);&#10;  my($dy,$dm,$dw,$dd,$dh,$dmn,$ds,$ddd)=(0,0,0,0,0,0,0,0);&#10;&#10;  if ($mode != 3) {&#10;&#10;    # Do years&#10;    $dy=$y2-$y1;&#10;    $dm=0;&#10;    if ($dy&gt;0) {&#10;      $tmp=_DateCalc_DateDelta($date1,"+$dy:0:0:0:0:0:0",\$err,0);&#10;      if (Date_Cmp($tmp,$date2)&gt;0) {&#10;        $dy--;&#10;        $tmp=$date1;&#10;        $tmp=_DateCalc_DateDelta($date1,"+$dy:0:0:0:0:0:0",\$err,0)&#10;          if ($dy&gt;0);&#10;        $dm=12;&#10;      }&#10;      $date1=$tmp;&#10;    }&#10;&#10;    # Do months&#10;    $dm+=$m2-$m1;&#10;    if ($dm&gt;0) {&#10;      $tmp=_DateCalc_DateDelta($date1,"+0:$dm:0:0:0:0:0",\$err,0);&#10;      if (Date_Cmp($tmp,$date2)&gt;0) {&#10;        $dm--;&#10;        $tmp=$date1;&#10;        $tmp=_DateCalc_DateDelta($date1,"+0:$dm:0:0:0:0:0",\$err,0)&#10;          if ($dm&gt;0);&#10;      }&#10;      $date1=$tmp;&#10;    }&#10;&#10;    # At this point, check to see that we're on a business day again so that&#10;    # Aug 3 (Monday) -&gt; Sep 3 (Sunday) -&gt; Sep 4 (Monday)  = 1 month&#10;    if ($mode==2) {&#10;      if (! Date_IsWorkDay($date1,0)) {&#10;        $date1=Date_NextWorkDay($date1,0,1);&#10;      }&#10;    }&#10;  }&#10;&#10;  # Do days&#10;  if ($mode==2 || $mode==3) {&#10;    $dd=0;&#10;    while (1) {&#10;      $tmp=Date_NextWorkDay($date1,1,1);&#10;      if (Date_Cmp($tmp,$date2)&lt;=0) {&#10;        $dd++;&#10;        $date1=$tmp;&#10;      } else {&#10;        last;&#10;      }&#10;    }&#10;&#10;  } else {&#10;    ($y1,$m1,$d1)=( _Date_Split($date1, 1) )[0..2];&#10;    $dd=0;&#10;    # If we're jumping across months, set $d1 to the first of the next month&#10;    # (or possibly the 0th of next month which is equivalent to the last day&#10;    # of this month)&#10;    if ($m1!=$m2) {&#10;      $d_in_m[2]=29  if (Date_LeapYear($y1));&#10;      $dd=$d_in_m[$m1]-$d1+1;&#10;      $d1=1;&#10;      $tmp=_DateCalc_DateDelta($date1,"+0:0:0:$dd:0:0:0",\$err,0);&#10;      if (Date_Cmp($tmp,$date2)&gt;0) {&#10;        $dd--;&#10;        $d1--;&#10;        $tmp=_DateCalc_DateDelta($date1,"+0:0:0:$dd:0:0:0",\$err,0);&#10;      }&#10;      $date1=$tmp;&#10;    }&#10;&#10;    $ddd=0;&#10;    if ($d1&lt;$d2) {&#10;      $ddd=$d2-$d1;&#10;      $tmp=_DateCalc_DateDelta($date1,"+0:0:0:$ddd:0:0:0",\$err,0);&#10;      if (Date_Cmp($tmp,$date2)&gt;0) {&#10;        $ddd--;&#10;        $tmp=_DateCalc_DateDelta($date1,"+0:0:0:$ddd:0:0:0",\$err,0);&#10;      }&#10;      $date1=$tmp;&#10;    }&#10;    $dd+=$ddd;&#10;  }&#10;&#10;  # in business mode, make sure h1 comes before h2 (if not find delta between&#10;  # now and end of day and move to start of next business day)&#10;  $d1=( _Date_Split($date1, 1) )[2];&#10;  $dh=$dmn=$ds=0;&#10;  if ($mode==2 || $mode==3  and  $d1 != $d2) {&#10;    $tmp=Date_SetTime($date1,$Cnf{"WorkDayEnd"});&#10;    $tmp=_DateCalc_DateDelta($tmp,"+0:0:0:0:0:1:0")&#10;      if ($Cnf{"WorkDay24Hr"});&#10;    $tmp=_DateCalc_DateDate($date1,$tmp,0);&#10;    ($tmp,$tmp,$tmp,$tmp,$dh,$dmn,$ds)=_Delta_Split($tmp);&#10;    $date1=Date_NextWorkDay($date1,1,0);&#10;    $date1=Date_SetTime($date1,$Cnf{"WorkDayBeg"});&#10;    $d1=( _Date_Split($date1, 1) )[2];&#10;    confess "ERROR: DateCalc DateDate Business.\n"  if ($d1 != $d2);&#10;  }&#10;&#10;  # Hours, minutes, seconds&#10;  $tmp=_DateCalc_DateDate($date1,$date2,0);&#10;  @tmp=_Delta_Split($tmp);&#10;  $dh  += $tmp[4];&#10;  $dmn += $tmp[5];&#10;  $ds  += $tmp[6];&#10;&#10;  $tmp="$sign$dy:$dm:0:$dd:$dh:$dmn:$ds";&#10;  _Delta_Normalize($tmp,$mode);&#10;}&#10;&#10;sub _DateCalc_DeltaDelta {&#10;  print "DEBUG: _DateCalc_DeltaDelta\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($D1,$D2,$mode)=@_;&#10;  my(@delta1,@delta2,$i,$delta,@delta)=();&#10;  $mode=0  if (! defined $mode);&#10;&#10;  @delta1=_Delta_Split($D1);&#10;  @delta2=_Delta_Split($D2);&#10;  for ($i=0; $i&lt;7; $i++) {&#10;    $delta[$i]=$delta1[$i]+$delta2[$i];&#10;    $delta[$i]="+".$delta[$i]  if ($delta[$i]&gt;=0);&#10;  }&#10;&#10;  $delta=join(":",@delta);&#10;  $delta=_Delta_Normalize($delta,$mode);&#10;  return $delta;&#10;}&#10;&#10;sub _DateCalc_DateDelta {&#10;  print "DEBUG: _DateCalc_DateDelta\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($D1,$D2,$errref,$mode)=@_;&#10;  my($date)=();&#10;  my(@d_in_m)=(0,31,28,31,30,31,30,31,31,30,31,30,31);&#10;  my($h1,$m1,$h2,$m2,$len,$hh,$mm)=();&#10;  $mode=0  if (! defined $mode);&#10;&#10;  if ($mode==2 || $mode==3) {&#10;    $h1=$Curr{"WDBh"};&#10;    $m1=$Curr{"WDBm"};&#10;    $h2=$Curr{"WDEh"};&#10;    $m2=$Curr{"WDEm"};&#10;    $hh=$h2-$h1;&#10;    $mm=$m2-$m1;&#10;    if ($mm&lt;0) {&#10;      $hh--;&#10;      $mm+=60;&#10;    }&#10;  }&#10;&#10;  # Date, delta&#10;  my($y,$m,$d,$h,$mn,$s)=_Date_Split($D1, 1);&#10;  my($dy,$dm,$dw,$dd,$dh,$dmn,$ds)=_Delta_Split($D2);&#10;&#10;  # do the month/year part&#10;  $y+=$dy;&#10;  while (length($y)&lt;4) {&#10;    $y = "0$y";&#10;  }&#10;  _ModuloAddition(-12,$dm,\$m,\$y);   # -12 means 1-12 instead of 0-11&#10;  $d_in_m[2]=29  if (Date_LeapYear($y));&#10;&#10;  # if we have gone past the last day of a month, move the date back to&#10;  # the last day of the month&#10;  if ($d&gt;$d_in_m[$m]) {&#10;    $d=$d_in_m[$m];&#10;  }&#10;&#10;  # do the week part&#10;  if ($mode==0  ||  $mode==1) {&#10;    $dd += $dw*7;&#10;  } else {&#10;    $date=_DateCalc_DateDelta(_Date_Join($y,$m,$d,$h,$mn,$s),&#10;                              "+0:0:$dw:0:0:0:0",0);&#10;    ($y,$m,$d,$h,$mn,$s)=_Date_Split($date, 1);&#10;  }&#10;&#10;  # in business mode, set the day to a work day at this point so the h/mn/s&#10;  # stuff will work out&#10;  if ($mode==2 || $mode==3) {&#10;    $d=$d_in_m[$m] if ($d&gt;$d_in_m[$m]);&#10;    $date=Date_NextWorkDay(_Date_Join($y,$m,$d,$h,$mn,$s),0,1);&#10;    ($y,$m,$d,$h,$mn,$s)=_Date_Split($date, 1);&#10;  }&#10;&#10;  # seconds, minutes, hours&#10;  _ModuloAddition(60,$ds,\$s,\$mn);&#10;  if ($mode==2 || $mode==3) {&#10;    while (1) {&#10;      _ModuloAddition(60,$dmn,\$mn,\$h);&#10;      $h+= $dh;&#10;&#10;      if ($h&gt;$h2  or  $h==$h2 &amp;&amp; $mn&gt;$m2) {&#10;        $dh=$h-$h2;&#10;        $dmn=$mn-$m2;&#10;        $h=$h1;&#10;        $mn=$m1;&#10;        $dd++;&#10;&#10;      } elsif ($h&lt;$h1  or  $h==$h1 &amp;&amp; $mn&lt;$m1) {&#10;        $dh=$h-$h1;&#10;        $dmn=$m1-$mn;&#10;        $h=$h2;&#10;        $mn=$m2;&#10;        $dd--;&#10;&#10;      } elsif ($h==$h2  &amp;&amp;  $mn==$m2) {&#10;        $dd++;&#10;        $dh=-$hh;&#10;        $dmn=-$mm;&#10;&#10;      } else {&#10;        last;&#10;      }&#10;    }&#10;&#10;  } else {&#10;    _ModuloAddition(60,$dmn,\$mn,\$h);&#10;    _ModuloAddition(24,$dh,\$h,\$d);&#10;  }&#10;&#10;  # If we have just gone past the last day of the month, we need to make&#10;  # up for this:&#10;  if ($d&gt;$d_in_m[$m]) {&#10;    $dd+= $d-$d_in_m[$m];&#10;    $d=$d_in_m[$m];&#10;  }&#10;&#10;  # days&#10;  if ($mode==2 || $mode==3) {&#10;    if ($dd&gt;=0) {&#10;      $date=Date_NextWorkDay(_Date_Join($y,$m,$d,$h,$mn,$s),$dd,1);&#10;    } else {&#10;      $date=Date_PrevWorkDay(_Date_Join($y,$m,$d,$h,$mn,$s),-$dd,1);&#10;    }&#10;    ($y,$m,$d,$h,$mn,$s)=_Date_Split($date, 1);&#10;&#10;  } else {&#10;    $d_in_m[2]=29  if (Date_LeapYear($y));&#10;    $d=$d_in_m[$m]  if ($d&gt;$d_in_m[$m]);&#10;    $d += $dd;&#10;    while ($d&lt;1) {&#10;      $m--;&#10;      if ($m==0) {&#10;        $m=12;&#10;        $y--;&#10;        if (Date_LeapYear($y)) {&#10;          $d_in_m[2]=29;&#10;        } else {&#10;          $d_in_m[2]=28;&#10;        }&#10;      }&#10;      $d += $d_in_m[$m];&#10;    }&#10;    while ($d&gt;$d_in_m[$m]) {&#10;      $d -= $d_in_m[$m];&#10;      $m++;&#10;      if ($m==13) {&#10;        $m=1;&#10;        $y++;&#10;        if (Date_LeapYear($y)) {&#10;          $d_in_m[2]=29;&#10;        } else {&#10;          $d_in_m[2]=28;&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  if ($y&lt;0 or $y&gt;9999) {&#10;    $$errref=3;&#10;    return;&#10;  }&#10;  _Date_Join($y,$m,$d,$h,$mn,$s);&#10;}&#10;&#10;sub _Date_UpdateHolidays {&#10;  print "DEBUG: _Date_UpdateHolidays\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($year)=@_;&#10;  $Holiday{"year"}=$year;&#10;  $Holiday{"dates"}{$year}={};&#10;&#10;  my($date,$delta,$err)=();&#10;  my($key,@tmp,$tmp);&#10;&#10;  foreach $key (keys %{ $Holiday{"desc"} }) {&#10;    @tmp=_Recur_Split($key);&#10;    if (@tmp) {&#10;      $tmp=ParseDateString("${year}010100:00:00");&#10;      ($date)=ParseRecur($key,$tmp,$tmp,($year+1)."-01-01");&#10;      next  if (! $date);&#10;&#10;    } elsif ($key =~ /^(.*)([+-].*)$/) {&#10;      # Date +/- Delta&#10;      ($date,$delta)=($1,$2);&#10;      $tmp=ParseDateString("$date $year");&#10;      if ($tmp) {&#10;        $date=$tmp;&#10;      } else {&#10;        $date=ParseDateString($date);&#10;        next  if ($date !~ /^$year/);&#10;      }&#10;      $date=DateCalc($date,$delta,\$err,0);&#10;&#10;    } else {&#10;      # Date&#10;      $date=$key;&#10;      $tmp=ParseDateString("$date $year");&#10;      if ($tmp) {&#10;        $date=$tmp;&#10;      } else {&#10;        $date=ParseDateString($date);&#10;        next  if ($date !~ /^$year/);&#10;      }&#10;    }&#10;    $Holiday{"dates"}{$year}{$date}=$Holiday{"desc"}{$key};&#10;  }&#10;}&#10;&#10;# This sets a Date::Manip config variable.&#10;sub _Date_SetConfigVariable {&#10;  print "DEBUG: _Date_SetConfigVariable\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($var,$val)=@_;&#10;&#10;  # These are most appropriate for command line options instead of in files.&#10;  $Cnf{"PathSep"}=$val,          return  if ($var =~ /^PathSep$/i);&#10;  $Cnf{"PersonalCnf"}=$val,      return  if ($var =~ /^PersonalCnf$/i);&#10;  $Cnf{"PersonalCnfPath"}=$val,  return  if ($var =~ /^PersonalCnfPath$/i);&#10;  EraseHolidays(),              return  if ($var =~ /^EraseHolidays$/i);&#10;  $Cnf{"IgnoreGlobalCnf"}=1,     return  if ($var =~ /^IgnoreGlobalCnf$/i);&#10;  $Cnf{"GlobalCnf"}=$val,        return  if ($var =~ /^GlobalCnf$/i);&#10;&#10;  $Curr{"InitLang"}=1,&#10;  $Cnf{"Language"}=$val,         return  if ($var =~ /^Language$/i);&#10;  $Cnf{"DateFormat"}=$val,       return  if ($var =~ /^DateFormat$/i);&#10;  $Cnf{"TZ"}=$val,               return  if ($var =~ /^TZ$/i);&#10;  $Cnf{"ConvTZ"}=$val,           return  if ($var =~ /^ConvTZ$/i);&#10;  $Cnf{"Internal"}=$val,         return  if ($var =~ /^Internal$/i);&#10;  $Cnf{"FirstDay"}=$val,         return  if ($var =~ /^FirstDay$/i);&#10;  $Cnf{"WorkWeekBeg"}=$val,      return  if ($var =~ /^WorkWeekBeg$/i);&#10;  $Cnf{"WorkWeekEnd"}=$val,      return  if ($var =~ /^WorkWeekEnd$/i);&#10;  $Cnf{"WorkDayBeg"}=$val,&#10;  $Curr{"ResetWorkDay"}=1,       return  if ($var =~ /^WorkDayBeg$/i);&#10;  $Cnf{"WorkDayEnd"}=$val,&#10;  $Curr{"ResetWorkDay"}=1,       return  if ($var =~ /^WorkDayEnd$/i);&#10;  $Cnf{"WorkDay24Hr"}=$val,&#10;  $Curr{"ResetWorkDay"}=1,       return  if ($var =~ /^WorkDay24Hr$/i);&#10;  $Cnf{"DeltaSigns"}=$val,       return  if ($var =~ /^DeltaSigns$/i);&#10;  $Cnf{"Jan1Week1"}=$val,        return  if ($var =~ /^Jan1Week1$/i);&#10;  $Cnf{"YYtoYYYY"}=$val,         return  if ($var =~ /^YYtoYYYY$/i);&#10;  $Cnf{"UpdateCurrTZ"}=$val,     return  if ($var =~ /^UpdateCurrTZ$/i);&#10;  $Cnf{"IntCharSet"}=$val,       return  if ($var =~ /^IntCharSet$/i);&#10;  $Curr{"DebugVal"}=$val,        return  if ($var =~ /^Debug$/i);&#10;  $Cnf{"TomorrowFirst"}=$val,    return  if ($var =~ /^TomorrowFirst$/i);&#10;  $Cnf{"ForceDate"}=$val,        return  if ($var =~ /^ForceDate$/i);&#10;  $Cnf{"TodayIsMidnight"}=$val,  return  if ($var =~ /^TodayIsMidnight$/i);&#10;&#10;  confess "ERROR: Unknown configuration variable $var in Date::Manip.\n";&#10;}&#10;&#10;sub EraseHolidays {&#10;  print "DEBUG: EraseHolidays\n"  if ($Curr{"Debug"} =~ /trace/);&#10;&#10;  $Cnf{"EraseHolidays"}=0;&#10;  delete $Holiday{"list"};&#10;  $Holiday{"list"}={};&#10;  delete $Holiday{"desc"};&#10;  $Holiday{"desc"}={};&#10;  $Holiday{"dates"}={};&#10;}&#10;&#10;# This returns a pointer to a list of times and events in the format&#10;#    [ date [ events ], date, [ events ], ... ]&#10;# where each list of events are events that are in effect at the date&#10;# immediately preceding the list.&#10;#&#10;# This takes either one date or two dates as arguments.&#10;sub _Events_Calc {&#10;  print "DEBUG: _Events_Calc\n"  if ($Curr{"Debug"} =~ /trace/);&#10;&#10;  my($date0,$date1)=@_;&#10;&#10;  my($tmp);&#10;  $date0=ParseDateString($date0);&#10;  return undef  if (! $date0);&#10;  if ($date1) {&#10;    $date1=ParseDateString($date1);&#10;    if (Date_Cmp($date0,$date1)&gt;0) {&#10;      $tmp=$date1;&#10;      $date1=$date0;&#10;      $date0=$tmp;&#10;    }&#10;  } else {&#10;    $date1=_DateCalc_DateDelta($date0,"+0:0:0:0:0:0:1");&#10;  }&#10;&#10;  #&#10;  #   [ d0,d1,del,name ]     =&gt; [ d0, d1+del )&#10;  #   [ d0,0,del,name ]      =&gt; [ d0, d0+del )&#10;  #&#10;  my(%ret,$d0,$d1,$del,$name,$c0,$c1);&#10;  my(@tmp)=@{ $Events{"dates"} };&#10; DATE: while (@tmp) {&#10;    ($d0,$d1,$del,$name)=splice(@tmp,0,4);&#10;    $d0=ParseDateString($d0);&#10;    $d1=ParseDateString($d1)   if ($d1);&#10;    $del=ParseDateDelta($del)  if ($del);&#10;    if ($d1) {&#10;      if ($del) {&#10;        $d1=_DateCalc_DateDelta($d1,$del);&#10;      }&#10;    } else {&#10;      $d1=_DateCalc_DateDelta($d0,$del);&#10;    }&#10;    if (Date_Cmp($d0,$d1)&gt;0) {&#10;      $tmp=$d1;&#10;      $d1=$d0;&#10;      $d0=$tmp;&#10;    }&#10;    #         [ date0,date1 )&#10;    # [ d0,d1 )      OR     [ d0,d1 )&#10;    next DATE  if (Date_Cmp($d1,$date0)&lt;=0  ||&#10;                   Date_Cmp($d0,$date1)&gt;=0);&#10;    #      [ date0,date1 )&#10;    # [ d0,d1 )&#10;    # [ d0,                  d1 )&#10;    if (Date_Cmp($d0,$date0)&lt;=0) {&#10;      push @{ $ret{$date0} },$name;&#10;      push @{ $ret{$d1} },"!$name"  if (Date_Cmp($d1,$date1)&lt;0);&#10;      next DATE;&#10;    }&#10;    #      [ date0,date1 )&#10;    #                 [ d0,d1 )&#10;    if (Date_Cmp($d1,$date1)&gt;=0) {&#10;      push @{ $ret{$d0} },$name;&#10;      next DATE;&#10;    }&#10;    #      [ date0,date1 )&#10;    #         [ d0,d1 )&#10;    push @{ $ret{$d0} },$name;&#10;    push @{ $ret{$d1} },"!$name";&#10;  }&#10;&#10;  #&#10;  #   [ recur,delta0,delta1,name ]   =&gt; [ {date-delta0},{date+delta1} )&#10;  #&#10;  my($rec,$del0,$del1,@d);&#10;  @tmp=@{ $Events{"recur"} };&#10; RECUR: while (@tmp) {&#10;    ($rec,$del0,$del1,$name)=splice(@tmp,0,4);&#10;    @d=();&#10;&#10;  }&#10;&#10;  # Sort them AND take into account the "!$name" entries.&#10;  my(%tmp,$date,@tmp2,@ret);&#10;  @d=sort { Date_Cmp($a,$b) } keys %ret;&#10;  foreach $date (@d) {&#10;    @tmp=@{ $ret{$date} };&#10;    @tmp2=();&#10;    foreach $tmp (@tmp) {&#10;      push(@tmp2,$tmp), next  if ($tmp =~ /^!/);&#10;      $tmp{$tmp}=1;&#10;    }&#10;    foreach $tmp (@tmp2) {&#10;      $tmp =~ s/^!//;&#10;      delete $tmp{$tmp};&#10;    }&#10;    push(@ret,$date,[ keys %tmp ]);&#10;  }&#10;&#10;  %tmp = @ret;&#10;  @ret = ();&#10;  foreach my $d (sort { Date_Cmp($a,$b) } keys %tmp) {&#10;    my $e = $tmp{$d};&#10;    push @ret,($d,[ sort @$e ]);&#10;  }&#10;  return \@ret;&#10;}&#10;&#10;# This parses the raw events list&#10;sub _Events_ParseRaw {&#10;  print "DEBUG: _Events_ParseRaw\n"  if ($Curr{"Debug"} =~ /trace/);&#10;&#10;  # Only need to be parsed once&#10;  my($force)=@_;&#10;  $Events{"parsed"}=0  if ($force);&#10;  return  if ($Events{"parsed"});&#10;  $Events{"parsed"}=1;&#10;&#10;  my(@events)=@{ $Events{"raw"} };&#10;  my($event,$name,@event,$date0,$date1,$tmp,$delta,$recur0,$recur1,@recur,$r,&#10;     $recur);&#10; EVENT: while (@events) {&#10;    ($event,$name)=splice(@events,0,2);&#10;    @event=split(/\s*;\s*/,$event);&#10;&#10;    if ($#event == 0) {&#10;&#10;      if ($date0=ParseDateString($event[0])) {&#10;        #&#10;        # date = event&#10;        #&#10;        $tmp=ParseDateString("$event[0] 00:00:00");&#10;        if ($tmp  &amp;&amp;  $tmp eq $date0) {&#10;          $delta="+0:0:0:1:0:0:0";&#10;        } else {&#10;          $delta="+0:0:0:0:1:0:0";&#10;        }&#10;        push @{ $Events{"dates"} },($date0,0,$delta,$name);&#10;&#10;      } elsif ($recur=ParseRecur($event[0])) {&#10;        #&#10;        # recur = event&#10;        #&#10;        ($recur0,$recur1)=_Recur_Split($recur);&#10;        if ($recur0) {&#10;          if ($recur1) {&#10;            $r="$recur0:$recur1";&#10;          } else {&#10;            $r=$recur0;&#10;          }&#10;        } else {&#10;          $r=$recur1;&#10;        }&#10;        (@recur)=split(/:/,$r);&#10;        if (pop(@recur)==0  &amp;&amp;  pop(@recur)==0  &amp;&amp;  pop(@recur)==0) {&#10;          $delta="+0:0:0:1:0:0:0";&#10;        } else {&#10;          $delta="+0:0:0:0:1:0:0";&#10;        }&#10;        push @{ $Events{"recur"} },($recur,0,$delta,$name);&#10;&#10;      } else {&#10;        # ??? = event&#10;        warn "WARNING: illegal event ignored [ @event ]\n";&#10;        next EVENT;&#10;      }&#10;&#10;    } elsif ($#event == 1) {&#10;&#10;      if ($date0=ParseDateString($event[0])) {&#10;&#10;        if ($date1=ParseDateString($event[1])) {&#10;          #&#10;          # date ; date = event&#10;          #&#10;          $tmp=ParseDateString("$event[1] 00:00:00");&#10;          if ($tmp  &amp;&amp;  $tmp eq $date1) {&#10;            $date1=_DateCalc_DateDelta($date1,"+0:0:0:1:0:0:0");&#10;          }&#10;          push @{ $Events{"dates"} },($date0,$date1,0,$name);&#10;&#10;        } elsif ($delta=ParseDateDelta($event[1])) {&#10;          #&#10;          # date ; delta = event&#10;          #&#10;          push @{ $Events{"dates"} },($date0,0,$delta,$name);&#10;&#10;        } else {&#10;          # date ; ??? = event&#10;          warn "WARNING: illegal event ignored [ @event ]\n";&#10;          next EVENT;&#10;        }&#10;&#10;      } elsif ($recur=ParseRecur($event[0])) {&#10;&#10;        if ($delta=ParseDateDelta($event[1])) {&#10;          #&#10;          # recur ; delta = event&#10;          #&#10;          push @{ $Events{"recur"} },($recur,0,$delta,$name);&#10;&#10;        } else {&#10;          # recur ; ??? = event&#10;          warn "WARNING: illegal event ignored [ @event ]\n";&#10;          next EVENT;&#10;        }&#10;&#10;      } else {&#10;        # ??? ; ??? = event&#10;        warn "WARNING: illegal event ignored [ @event ]\n";&#10;        next EVENT;&#10;      }&#10;&#10;    } else {&#10;      # date ; delta0 ; delta1 = event&#10;      # recur ; delta0 ; delta1 = event&#10;      # ??? ; ??? ; ??? ... = event&#10;      warn "WARNING: illegal event ignored [ @event ]\n";&#10;      next EVENT;&#10;    }&#10;  }&#10;}&#10;&#10;# This reads an init file.&#10;sub _Date_InitFile {&#10;  print "DEBUG: _Date_InitFile\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($file)=@_;&#10;  my($in)=new IO::File;&#10;  local($_)=();&#10;  my($section)="vars";&#10;  my($var,$val,$recur,$name)=();&#10;&#10;  $in-&gt;open($file)  ||  return;&#10;  while(defined ($_=&lt;$in&gt;)) {&#10;    chomp;&#10;    s/^\s+//;&#10;    s/\s+$//;&#10;    next  if (! $_  or  /^\#/);&#10;&#10;    if (/^\*holiday/i) {&#10;      $section="holiday";&#10;      EraseHolidays()  if ($section =~ /holiday/i  &amp;&amp;  $Cnf{"EraseHolidays"});&#10;      next;&#10;    } elsif (/^\*events/i) {&#10;      $section="events";&#10;      next;&#10;    }&#10;&#10;    if ($section =~ /var/i) {&#10;      confess "ERROR: invalid Date::Manip config file line.\n  $_\n"&#10;        if (! /(.*\S)\s*=\s*(.*)$/);&#10;      ($var,$val)=($1,$2);&#10;      _Date_SetConfigVariable($var,$val);&#10;&#10;    } elsif ($section =~ /holiday/i) {&#10;      confess "ERROR: invalid Date::Manip config file line.\n  $_\n"&#10;        if (! /(.*\S)\s*=\s*(.*)$/);&#10;      ($recur,$name)=($1,$2);&#10;      $name=""  if (! defined $name);&#10;      $Holiday{"desc"}{$recur}=$name;&#10;&#10;    } elsif ($section =~ /events/i) {&#10;      confess "ERROR: invalid Date::Manip config file line.\n  $_\n"&#10;        if (! /(.*\S)\s*=\s*(.*)$/);&#10;      ($val,$var)=($1,$2);&#10;      push @{ $Events{"raw"} },($val,$var);&#10;&#10;    } else {&#10;      # A section not currently used by Date::Manip (but may be&#10;      # used by some extension to it).&#10;      next;&#10;    }&#10;  }&#10;  close($in);&#10;}&#10;&#10;# $flag=_Date_TimeCheck(\$h,\$mn,\$s,\$ampm);&#10;#   Returns 1 if any of the fields are bad.  All fields are optional, and&#10;#   all possible checks are done on the data.  If a field is not passed in,&#10;#   it is set to default values.  If data is missing, appropriate defaults&#10;#   are supplied.&#10;sub _Date_TimeCheck {&#10;  print "DEBUG: _Date_TimeCheck\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($h,$mn,$s,$ampm)=@_;&#10;  my($tmp1,$tmp2,$tmp3)=();&#10;&#10;  $$h=""     if (! defined $$h);&#10;  $$mn=""    if (! defined $$mn);&#10;  $$s=""     if (! defined $$s);&#10;  $$ampm=""  if (! defined $$ampm);&#10;  $$ampm=uc($$ampm)  if ($$ampm);&#10;&#10;  # Check hour&#10;  $tmp1=$Lang{$Cnf{"Language"}}{"AmPm"};&#10;  $tmp2="";&#10;  if ($$ampm =~ /^$tmp1$/i) {&#10;    $tmp3=$Lang{$Cnf{"Language"}}{"AM"};&#10;    $tmp2="AM"  if ($$ampm =~ /^$tmp3$/i);&#10;    $tmp3=$Lang{$Cnf{"Language"}}{"PM"};&#10;    $tmp2="PM"  if ($$ampm =~ /^$tmp3$/i);&#10;  } elsif ($$ampm) {&#10;    return 1;&#10;  }&#10;  if ($tmp2 eq "AM" || $tmp2 eq "PM") {&#10;    $$h="0$$h"    if (length($$h)==1);&#10;    return 1      if ($$h&lt;1 || $$h&gt;12);&#10;    $$h="00"      if ($tmp2 eq "AM"  and  $$h==12);&#10;    $$h += 12     if ($tmp2 eq "PM"  and  $$h!=12);&#10;  } else {&#10;    $$h="00"      if ($$h eq "");&#10;    $$h="0$$h"    if (length($$h)==1);&#10;    return 1      if (! _IsInt($$h,0,23));&#10;    $tmp2="AM"    if ($$h&lt;12);&#10;    $tmp2="PM"    if ($$h&gt;=12);&#10;  }&#10;  $$ampm=$Lang{$Cnf{"Language"}}{"AMstr"};&#10;  $$ampm=$Lang{$Cnf{"Language"}}{"PMstr"}  if ($tmp2 eq "PM");&#10;&#10;  # Check minutes&#10;  $$mn="00"       if ($$mn eq "");&#10;  $$mn="0$$mn"    if (length($$mn)==1);&#10;  return 1        if (! _IsInt($$mn,0,59));&#10;&#10;  # Check seconds&#10;  $$s="00"        if ($$s eq "");&#10;  $$s="0$$s"      if (length($$s)==1);&#10;  return 1        if (! _IsInt($$s,0,59));&#10;&#10;  return 0;&#10;}&#10;&#10;# $flag=_Date_DateCheck(\$y,\$m,\$d,\$h,\$mn,\$s,\$ampm,\$wk);&#10;#   Returns 1 if any of the fields are bad.  All fields are optional, and&#10;#   all possible checks are done on the data.  If a field is not passed in,&#10;#   it is set to default values.  If data is missing, appropriate defaults&#10;#   are supplied.&#10;#&#10;#   If the flag UpdateHolidays is set, the year is set to&#10;#   CurrHolidayYear.&#10;sub _Date_DateCheck {&#10;  print "DEBUG: _Date_DateCheck\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y,$m,$d,$h,$mn,$s,$ampm,$wk)=@_;&#10;  my($tmp1,$tmp2,$tmp3)=();&#10;&#10;  my(@d_in_m)=(0,31,28,31,30,31,30,31,31,30,31,30,31);&#10;  my($curr_y)=$Curr{"Y"};&#10;  my($curr_m)=$Curr{"M"};&#10;  my($curr_d)=$Curr{"D"};&#10;  $$m=1, $$d=1  if (defined $$y and ! defined $$m and ! defined $$d);&#10;  $$y=""     if (! defined $$y);&#10;  $$m=""     if (! defined $$m);&#10;  $$d=""     if (! defined $$d);&#10;  $$wk=""    if (! defined $$wk);&#10;  $$d=$curr_d  if ($$y eq "" and $$m eq "" and $$d eq "");&#10;&#10;  # Check year.&#10;  $$y=$curr_y             if ($$y eq "");&#10;  $$y=_Date_FixYear($$y)  if (length($$y)&lt;4);&#10;  return 1                if (! _IsInt($$y,0,9999));&#10;  $d_in_m[2]=29           if (Date_LeapYear($$y));&#10;&#10;  # Check month&#10;  $$m=$curr_m             if ($$m eq "");&#10;  $$m=$Lang{$Cnf{"Language"}}{"MonthH"}{lc($$m)}&#10;    if (exists $Lang{$Cnf{"Language"}}{"MonthH"}{lc($$m)});&#10;  $$m="0$$m"              if (length($$m)==1);&#10;  return 1                if (! _IsInt($$m,1,12));&#10;&#10;  # Check day&#10;  $$d="01"                if ($$d eq "");&#10;  $$d="0$$d"              if (length($$d)==1);&#10;  return 1                if (! _IsInt($$d,1,$d_in_m[$$m]));&#10;  if ($$wk) {&#10;    $tmp1=Date_DayOfWeek($$m,$$d,$$y);&#10;    $tmp2=$Lang{$Cnf{"Language"}}{"WeekH"}{lc($$wk)}&#10;      if (exists $Lang{$Cnf{"Language"}}{"WeekH"}{lc($$wk)});&#10;    return 1      if ($tmp1 != $tmp2);&#10;  }&#10;&#10;  return _Date_TimeCheck($h,$mn,$s,$ampm);&#10;}&#10;&#10;# Takes a year in 2 digit form and returns it in 4 digit form&#10;sub _Date_FixYear {&#10;  print "DEBUG: _Date_FixYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y)=@_;&#10;  my($curr_y)=$Curr{"Y"};&#10;  $y=$curr_y  if (! defined $y  or  ! $y);&#10;  return $y  if (length($y)==4);&#10;  confess "ERROR: Invalid year ($y)\n"  if (length($y)!=2);&#10;  my($y1,$y2)=();&#10;&#10;  if (lc($Cnf{"YYtoYYYY"}) eq "c") {&#10;    $y1=substr($y,0,2);&#10;    $y="$y1$y";&#10;&#10;  } elsif ($Cnf{"YYtoYYYY"} =~ /^c(\d{2})$/i) {&#10;    $y1=$1;&#10;    $y="$y1$y";&#10;&#10;  } elsif ($Cnf{"YYtoYYYY"} =~ /^c(\d{2})(\d{2})$/i) {&#10;    $y1="$1$2";&#10;    $y ="$1$y";&#10;    $y += 100  if ($y&lt;$y1);&#10;&#10;  } else {&#10;    $y1=$curr_y-$Cnf{"YYtoYYYY"};&#10;    $y2=$y1+99;&#10;    $y="19$y";&#10;    while ($y&lt;$y1) {&#10;      $y+=100;&#10;    }&#10;    while ($y&gt;$y2) {&#10;      $y-=100;&#10;    }&#10;  }&#10;  $y;&#10;}&#10;&#10;# _Date_NthWeekOfYear($y,$n);&#10;#   Returns a list of (YYYY,MM,DD) for the 1st day of the Nth week of the&#10;#   year.&#10;# _Date_NthWeekOfYear($y,$n,$dow,$flag);&#10;#   Returns a list of (YYYY,MM,DD) for the Nth DoW of the year.  If flag&#10;#   is nil, the first DoW of the year may actually be in the previous&#10;#   year (since the 1st week may include days from the previous year).&#10;#   If flag is non-nil, the 1st DoW of the year refers to the 1st one&#10;#   actually in the year&#10;sub _Date_NthWeekOfYear {&#10;  print "DEBUG: _Date_NthWeekOfYear\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($y,$n,$dow,$flag)=@_;&#10;  my($m,$d,$err,$tmp,$date,%dow)=();&#10;  $y=$Curr{"Y"}  if (! defined $y  or  ! $y);&#10;  $n=1       if (! defined $n  or  $n eq "");&#10;  return ()  if ($n&lt;0  ||  $n&gt;53);&#10;  if (defined $dow) {&#10;    $dow=lc($dow);&#10;    %dow=%{ $Lang{$Cnf{"Language"}}{"WeekH"} };&#10;    $dow=$dow{$dow}  if (exists $dow{$dow});&#10;    return ()  if ($dow&lt;1 || $dow&gt;7);&#10;    $flag=""   if (! defined $flag);&#10;  } else {&#10;    $dow="";&#10;    $flag="";&#10;  }&#10;&#10;  $y=_Date_FixYear($y)  if (length($y)&lt;4);&#10;  if ($Cnf{"Jan1Week1"}) {&#10;    $date=_Date_Join($y,1,1,0,0,0);&#10;  } else {&#10;    $date=_Date_Join($y,1,4,0,0,0);&#10;  }&#10;  $date=Date_GetPrev($date,$Cnf{"FirstDay"},1);&#10;  $date=Date_GetNext($date,$dow,1)  if ($dow ne "");&#10;&#10;  if ($flag) {&#10;    ($tmp)=_Date_Split($date, 1);&#10;    $n++  if ($tmp != $y);&#10;  }&#10;&#10;  if ($n&gt;1) {&#10;    $date=_DateCalc_DateDelta($date,"+0:0:". ($n-1) . ":0:0:0:0",\$err,0);&#10;  } elsif ($n==0) {&#10;    $date=_DateCalc_DateDelta($date,"-0:0:1:0:0:0:0",\$err,0);&#10;  }&#10;  ($y,$m,$d)=_Date_Split($date, 1);&#10;  ($y,$m,$d);&#10;}&#10;&#10;########################################################################&#10;# LANGUAGE INITIALIZATION&#10;########################################################################&#10;&#10;# 8-bit international characters can be gotten by "\xXX".  I don't know&#10;# how to get 16-bit characters.  I've got to read up on perllocale.&#10;sub _Char_8Bit {&#10;  my($hash)=@_;&#10;&#10;  #   grave `&#10;  #     A`    00c0     a`    00e0&#10;  #     E`    00c8     e`    00e8&#10;  #     I`    00cc     i`    00ec&#10;  #     O`    00d2     o`    00f2&#10;  #     U`    00d9     u`    00f9&#10;  #     W`    1e80     w`    1e81&#10;  #     Y`    1ef2     y`    1ef3&#10;&#10;  $$hash{"A`"} = "\xc0";   #   LATIN CAPITAL LETTER A WITH GRAVE&#10;  $$hash{"E`"} = "\xc8";   #   LATIN CAPITAL LETTER E WITH GRAVE&#10;  $$hash{"I`"} = "\xcc";   #   LATIN CAPITAL LETTER I WITH GRAVE&#10;  $$hash{"O`"} = "\xd2";   #   LATIN CAPITAL LETTER O WITH GRAVE&#10;  $$hash{"U`"} = "\xd9";   #   LATIN CAPITAL LETTER U WITH GRAVE&#10;  $$hash{"a`"} = "\xe0";   #   LATIN SMALL LETTER A WITH GRAVE&#10;  $$hash{"e`"} = "\xe8";   #   LATIN SMALL LETTER E WITH GRAVE&#10;  $$hash{"i`"} = "\xec";   #   LATIN SMALL LETTER I WITH GRAVE&#10;  $$hash{"o`"} = "\xf2";   #   LATIN SMALL LETTER O WITH GRAVE&#10;  $$hash{"u`"} = "\xf9";   #   LATIN SMALL LETTER U WITH GRAVE&#10;&#10;  #   acute '&#10;  #     A'    00c1     a'    00e1&#10;  #     C'    0106     c'    0107&#10;  #     E'    00c9     e'    00e9&#10;  #     I'    00cd     i'    00ed&#10;  #     L'    0139     l'    013a&#10;  #     N'    0143     n'    0144&#10;  #     O'    00d3     o'    00f3&#10;  #     R'    0154     r'    0155&#10;  #     S'    015a     s'    015b&#10;  #     U'    00da     u'    00fa&#10;  #     W'    1e82     w'    1e83&#10;  #     Y'    00dd     y'    00fd&#10;  #     Z'    0179     z'    017a&#10;&#10;  $$hash{"A'"} = "\xc1";   #   LATIN CAPITAL LETTER A WITH ACUTE&#10;  $$hash{"E'"} = "\xc9";   #   LATIN CAPITAL LETTER E WITH ACUTE&#10;  $$hash{"I'"} = "\xcd";   #   LATIN CAPITAL LETTER I WITH ACUTE&#10;  $$hash{"O'"} = "\xd3";   #   LATIN CAPITAL LETTER O WITH ACUTE&#10;  $$hash{"U'"} = "\xda";   #   LATIN CAPITAL LETTER U WITH ACUTE&#10;  $$hash{"Y'"} = "\xdd";   #   LATIN CAPITAL LETTER Y WITH ACUTE&#10;  $$hash{"a'"} = "\xe1";   #   LATIN SMALL LETTER A WITH ACUTE&#10;  $$hash{"e'"} = "\xe9";   #   LATIN SMALL LETTER E WITH ACUTE&#10;  $$hash{"i'"} = "\xed";   #   LATIN SMALL LETTER I WITH ACUTE&#10;  $$hash{"o'"} = "\xf3";   #   LATIN SMALL LETTER O WITH ACUTE&#10;  $$hash{"u'"} = "\xfa";   #   LATIN SMALL LETTER U WITH ACUTE&#10;  $$hash{"y'"} = "\xfd";   #   LATIN SMALL LETTER Y WITH ACUTE&#10;&#10;  #   double acute "         "&#10;  #     O"    0150     o"    0151&#10;  #     U"    0170     u"    0171&#10;&#10;  #   circumflex ^&#10;  #     A^    00c2     a^    00e2&#10;  #     C^    0108     c^    0109&#10;  #     E^    00ca     e^    00ea&#10;  #     G^    011c     g^    011d&#10;  #     H^    0124     h^    0125&#10;  #     I^    00ce     i^    00ee&#10;  #     J^    0134     j^    0135&#10;  #     O^    00d4     o^    00f4&#10;  #     S^    015c     s^    015d&#10;  #     U^    00db     u^    00fb&#10;  #     W^    0174     w^    0175&#10;  #     Y^    0176     y^    0177&#10;&#10;  $$hash{"A^"} = "\xc2";   #   LATIN CAPITAL LETTER A WITH CIRCUMFLEX&#10;  $$hash{"E^"} = "\xca";   #   LATIN CAPITAL LETTER E WITH CIRCUMFLEX&#10;  $$hash{"I^"} = "\xce";   #   LATIN CAPITAL LETTER I WITH CIRCUMFLEX&#10;  $$hash{"O^"} = "\xd4";   #   LATIN CAPITAL LETTER O WITH CIRCUMFLEX&#10;  $$hash{"U^"} = "\xdb";   #   LATIN CAPITAL LETTER U WITH CIRCUMFLEX&#10;  $$hash{"a^"} = "\xe2";   #   LATIN SMALL LETTER A WITH CIRCUMFLEX&#10;  $$hash{"e^"} = "\xea";   #   LATIN SMALL LETTER E WITH CIRCUMFLEX&#10;  $$hash{"i^"} = "\xee";   #   LATIN SMALL LETTER I WITH CIRCUMFLEX&#10;  $$hash{"o^"} = "\xf4";   #   LATIN SMALL LETTER O WITH CIRCUMFLEX&#10;  $$hash{"u^"} = "\xfb";   #   LATIN SMALL LETTER U WITH CIRCUMFLEX&#10;&#10;  #   tilde ~&#10;  #     A~    00c3    a~    00e3&#10;  #     I~    0128    i~    0129&#10;  #     N~    00d1    n~    00f1&#10;  #     O~    00d5    o~    00f5&#10;  #     U~    0168    u~    0169&#10;&#10;  $$hash{"A~"} = "\xc3";   #   LATIN CAPITAL LETTER A WITH TILDE&#10;  $$hash{"N~"} = "\xd1";   #   LATIN CAPITAL LETTER N WITH TILDE&#10;  $$hash{"O~"} = "\xd5";   #   LATIN CAPITAL LETTER O WITH TILDE&#10;  $$hash{"a~"} = "\xe3";   #   LATIN SMALL LETTER A WITH TILDE&#10;  $$hash{"n~"} = "\xf1";   #   LATIN SMALL LETTER N WITH TILDE&#10;  $$hash{"o~"} = "\xf5";   #   LATIN SMALL LETTER O WITH TILDE&#10;&#10;  #   macron -&#10;  #     A-    0100    a-    0101&#10;  #     E-    0112    e-    0113&#10;  #     I-    012a    i-    012b&#10;  #     O-    014c    o-    014d&#10;  #     U-    016a    u-    016b&#10;&#10;  #   breve ( [half circle up]&#10;  #     A(    0102    a(    0103&#10;  #     G(    011e    g(    011f&#10;  #     U(    016c    u(    016d&#10;&#10;  #   dot .&#10;  #     C.    010a    c.    010b&#10;  #     E.    0116    e.    0117&#10;  #     G.    0120    g.    0121&#10;  #     I.    0130&#10;  #     Z.    017b    z.    017c&#10;&#10;  #   diaeresis :  [side by side dots]&#10;  #     A:    00c4    a:    00e4&#10;  #     E:    00cb    e:    00eb&#10;  #     I:    00cf    i:    00ef&#10;  #     O:    00d6    o:    00f6&#10;  #     U:    00dc    u:    00fc&#10;  #     W:    1e84    w:    1e85&#10;  #     Y:    0178    y:    00ff&#10;&#10;  $$hash{"A:"} = "\xc4";   #   LATIN CAPITAL LETTER A WITH DIAERESIS&#10;  $$hash{"E:"} = "\xcb";   #   LATIN CAPITAL LETTER E WITH DIAERESIS&#10;  $$hash{"I:"} = "\xcf";   #   LATIN CAPITAL LETTER I WITH DIAERESIS&#10;  $$hash{"O:"} = "\xd6";   #   LATIN CAPITAL LETTER O WITH DIAERESIS&#10;  $$hash{"U:"} = "\xdc";   #   LATIN CAPITAL LETTER U WITH DIAERESIS&#10;  $$hash{"a:"} = "\xe4";   #   LATIN SMALL LETTER A WITH DIAERESIS&#10;  $$hash{"e:"} = "\xeb";   #   LATIN SMALL LETTER E WITH DIAERESIS&#10;  $$hash{"i:"} = "\xef";   #   LATIN SMALL LETTER I WITH DIAERESIS&#10;  $$hash{"o:"} = "\xf6";   #   LATIN SMALL LETTER O WITH DIAERESIS&#10;  $$hash{"u:"} = "\xfc";   #   LATIN SMALL LETTER U WITH DIAERESIS&#10;  $$hash{"y:"} = "\xff";   #   LATIN SMALL LETTER Y WITH DIAERESIS&#10;&#10;  #   ring o&#10;  #     U0    016e    u0    016f&#10;&#10;  #   cedilla ,  [squiggle down and left below the letter]&#10;  #     ,C    00c7    ,c    00e7&#10;  #     ,G    0122    ,g    0123&#10;  #     ,K    0136    ,k    0137&#10;  #     ,L    013b    ,l    013c&#10;  #     ,N    0145    ,n    0146&#10;  #     ,R    0156    ,r    0157&#10;  #     ,S    015e    ,s    015f&#10;  #     ,T    0162    ,t    0163&#10;&#10;  $$hash{",C"} = "\xc7";   #   LATIN CAPITAL LETTER C WITH CEDILLA&#10;  $$hash{",c"} = "\xe7";   #   LATIN SMALL LETTER C WITH CEDILLA&#10;&#10;  #   ogonek ;  [squiggle down and right below the letter]&#10;  #     A;    0104    a;    0105&#10;  #     E;    0118    e;    0119&#10;  #     I;    012e    i;    012f&#10;  #     U;    0172    u;    0173&#10;&#10;  #   caron &lt;  [little v on top]&#10;  #     A&lt;    01cd    a&lt;    01ce&#10;  #     C&lt;    010c    c&lt;    010d&#10;  #     D&lt;    010e    d&lt;    010f&#10;  #     E&lt;    011a    e&lt;    011b&#10;  #     L&lt;    013d    l&lt;    013e&#10;  #     N&lt;    0147    n&lt;    0148&#10;  #     R&lt;    0158    r&lt;    0159&#10;  #     S&lt;    0160    s&lt;    0161&#10;  #     T&lt;    0164    t&lt;    0165&#10;  #     Z&lt;    017d    z&lt;    017e&#10;&#10;&#10;  # Other characters&#10;&#10;  # First character is below, 2nd character is above&#10;  $$hash{"||"} = "\xa6";   #   BROKEN BAR&#10;  $$hash{" :"} = "\xa8";   #   DIAERESIS&#10;  $$hash{"-a"} = "\xaa";   #   FEMININE ORDINAL INDICATOR&#10;  #$$hash{" -"}= "\xaf";   #   MACRON   (narrow bar)&#10;  $$hash{" -"} = "\xad";   #   HYPHEN   (wide bar)&#10;  $$hash{" o"} = "\xb0";   #   DEGREE SIGN&#10;  $$hash{"-+"} = "\xb1";   #   PLUS\342\200\220MINUS SIGN&#10;  $$hash{" 1"} = "\xb9";   #   SUPERSCRIPT ONE&#10;  $$hash{" 2"} = "\xb2";   #   SUPERSCRIPT TWO&#10;  $$hash{" 3"} = "\xb3";   #   SUPERSCRIPT THREE&#10;  $$hash{" '"} = "\xb4";   #   ACUTE ACCENT&#10;  $$hash{"-o"} = "\xba";   #   MASCULINE ORDINAL INDICATOR&#10;  $$hash{" ."} = "\xb7";   #   MIDDLE DOT&#10;  $$hash{", "} = "\xb8";   #   CEDILLA&#10;  $$hash{"Ao"} = "\xc5";   #   LATIN CAPITAL LETTER A WITH RING ABOVE&#10;  $$hash{"ao"} = "\xe5";   #   LATIN SMALL LETTER A WITH RING ABOVE&#10;  $$hash{"ox"} = "\xf0";   #   LATIN SMALL LETTER ETH&#10;&#10;  # upside down characters&#10;&#10;  $$hash{"ud!"} = "\xa1";  #   INVERTED EXCLAMATION MARK&#10;  $$hash{"ud?"} = "\xbf";  #   INVERTED QUESTION MARK&#10;&#10;  # overlay characters&#10;&#10;  $$hash{"X o"} = "\xa4";  #   CURRENCY SIGN&#10;  $$hash{"Y ="} = "\xa5";  #   YEN SIGN&#10;  $$hash{"S o"} = "\xa7";  #   SECTION SIGN&#10;  $$hash{"O c"} = "\xa9";  #   COPYRIGHT SIGN    Copyright&#10;  $$hash{"O R"} = "\xae";  #   REGISTERED SIGN&#10;  $$hash{"D -"} = "\xd0";  #   LATIN CAPITAL LETTER ETH&#10;  $$hash{"O /"} = "\xd8";  #   LATIN CAPITAL LETTER O WITH STROKE&#10;  $$hash{"o /"} = "\xf8";  #   LATIN SMALL LETTER O WITH STROKE&#10;&#10;  # special names&#10;&#10;  $$hash{"1/4"} = "\xbc";  #   VULGAR FRACTION ONE QUARTER&#10;  $$hash{"1/2"} = "\xbd";  #   VULGAR FRACTION ONE HALF&#10;  $$hash{"3/4"} = "\xbe";  #   VULGAR FRACTION THREE QUARTERS&#10;  $$hash{"&lt;&lt;"}  = "\xab";  #   LEFT POINTING DOUBLE ANGLE QUOTATION MARK&#10;  $$hash{"&gt;&gt;"}  = "\xbb";  #   RIGHT POINTING DOUBLE ANGLE QUOTATION MARK&#10;  $$hash{"cent"}= "\xa2";  #   CENT SIGN&#10;  $$hash{"lb"}  = "\xa3";  #   POUND SIGN&#10;  $$hash{"mu"}  = "\xb5";  #   MICRO SIGN&#10;  $$hash{"beta"}= "\xdf";  #   LATIN SMALL LETTER SHARP S&#10;  $$hash{"para"}= "\xb6";  #   PILCROW SIGN&#10;  $$hash{"-|"}  = "\xac";  #   NOT SIGN&#10;  $$hash{"AE"}  = "\xc6";  #   LATIN CAPITAL LETTER AE&#10;  $$hash{"ae"}  = "\xe6";  #   LATIN SMALL LETTER AE&#10;  $$hash{"x"}   = "\xd7";  #   MULTIPLICATION SIGN&#10;  $$hash{"P"}   = "\xde";  #   LATIN CAPITAL LETTER THORN&#10;  $$hash{"/"}   = "\xf7";  #   DIVISION SIGN&#10;  $$hash{"p"}   = "\xfe";  #   LATIN SMALL LETTER THORN&#10;}&#10;&#10;# $hashref = _Date_Init_LANGUAGE;&#10;#   This returns a hash containing all of the initialization for a&#10;#   specific language.  The hash elements are:&#10;#&#10;#   @ month_name      full month names          January February ...&#10;#   @ month_abb       month abbreviations       Jan Feb ...&#10;#   @ day_name        day names                 Monday Tuesday ...&#10;#   @ day_abb         day abbreviations         Mon Tue ...&#10;#   @ day_char        day character abbrevs     M T ...&#10;#   @ am              AM notations&#10;#   @ pm              PM notations&#10;#&#10;#   @ num_suff        number with suffix        1st 2nd ...&#10;#   @ num_word        numbers spelled out       first second ...&#10;#&#10;#   $ now             words which mean now      now ...&#10;#   $ today           words which mean today    today ...&#10;#   $ last            words which mean last     last final ...&#10;#   $ each            words which mean each     each every ...&#10;#   $ of              of (as in a member of)    in of ...&#10;#                     ex.  4th day OF June&#10;#   $ at              at 4:00                   at&#10;#   $ on              on Sunday                 on&#10;#   $ future          in the future             in&#10;#   $ past            in the past               ago&#10;#   $ next            next item                 next&#10;#   $ prev            previous item             last previous&#10;#   $ later           2 hours later&#10;#&#10;#   % offset          a hash of special dates   { tomorrow-&gt;0:0:0:1:0:0:0 }&#10;#   % times           a hash of times           { noon-&gt;12:00:00 ... }&#10;#&#10;#   $ years           words for year            y yr year ...&#10;#   $ months          words for month&#10;#   $ weeks           words for week&#10;#   $ days            words for day&#10;#   $ hours           words for hour&#10;#   $ minutes         words for minute&#10;#   $ seconds         words for second&#10;#   % replace&#10;#       The replace element is quite important, but a bit tricky.  In&#10;#       English (and probably other languages), one of the abbreviations&#10;#       for the word month that would be nice is "m".  The problem is that&#10;#       "m" matches the "m" in "minute" which causes the string to be&#10;#       improperly matched in some cases.  Hence, the list of abbreviations&#10;#       for month is given as:&#10;#         "mon month months"&#10;#       In order to allow you to enter "m", replacements can be done.&#10;#       $replace is a list of pairs of words which are matched and replaced&#10;#       AS ENTIRE WORDS.  Having $replace equal to "m"-&gt;"month" means that&#10;#       the entire word "m" will be replaced with "month".  This allows the&#10;#       desired abbreviation to be used.  Make sure that replace contains&#10;#       an even number of words (i.e. all must be pairs).  Any time a&#10;#       desired abbreviation matches the start of any other, it has to go&#10;#       here.&#10;#&#10;#   $ exact           exact mode                exactly&#10;#   $ approx          approximate mode          approximately&#10;#   $ business        business mode             business&#10;#&#10;#   r sephm           hour/minute separator     (?::)&#10;#   r sepms           minute/second separator   (?::)&#10;#   r sepss           second/fraction separator (?:[.:])&#10;#&#10;#   Elements marked with an asterix (@) are returned as a set of lists.&#10;#   Each list contains the strings for each element.  The first set is used&#10;#   when the 7-bit ASCII (US) character set is wanted.  The 2nd set is used&#10;#   when an international character set is available.  Both of the 1st two&#10;#   sets should be complete (but the 2nd list can be left empty to force the&#10;#   first set to be used always).  The 3rd set and later can be partial sets&#10;#   if desired.&#10;#&#10;#   Elements marked with a dollar ($) are returned as a simple list of words.&#10;#&#10;#   Elements marked with a percent (%) are returned as a hash list.&#10;#&#10;#   Elements marked with (r) are regular expression elements which must not&#10;#   create a back reference.&#10;#&#10;# ***NOTE*** Every hash element (unless otherwise noted) MUST be defined in&#10;# every language.&#10;&#10;sub _Date_Init_English {&#10;  print "DEBUG: _Date_Init_English\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;&#10;  $$d{"month_name"}=&#10;    [["January","February","March","April","May","June",&#10;      "July","August","September","October","November","December"]];&#10;&#10;  $$d{"month_abb"}=&#10;    [["Jan","Feb","Mar","Apr","May","Jun",&#10;      "Jul","Aug","Sep","Oct","Nov","Dec"],&#10;     [],&#10;     ["","","","","","","","","Sept"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"]];&#10;  $$d{"day_abb"}=&#10;    [["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],&#10;     ["",   "Tues","",  "Thur","",  "",   ""]];&#10;  $$d{"day_char"}=&#10;    [["M","T","W","Th","F","Sa","S"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th",&#10;      "11th","12th","13th","14th","15th","16th","17th","18th","19th","20th",&#10;      "21st","22nd","23rd","24th","25th","26th","27th","28th","29th","30th",&#10;      "31st"]];&#10;  $$d{"num_word"}=&#10;    [["first","second","third","fourth","fifth","sixth","seventh","eighth",&#10;      "ninth","tenth","eleventh","twelfth","thirteenth","fourteenth",&#10;      "fifteenth","sixteenth","seventeenth","eighteenth","nineteenth",&#10;      "twentieth","twenty-first","twenty-second","twenty-third",&#10;      "twenty-fourth","twenty-fifth","twenty-sixth","twenty-seventh",&#10;      "twenty-eighth","twenty-ninth","thirtieth","thirty-first"]];&#10;&#10;  $$d{"now"}     =["now"];&#10;  $$d{"today"}   =["today"];&#10;  $$d{"last"}    =["last","final"];&#10;  $$d{"each"}    =["each","every"];&#10;  $$d{"of"}      =["in","of"];&#10;  $$d{"at"}      =["at"];&#10;  $$d{"on"}      =["on"];&#10;  $$d{"future"}  =["in"];&#10;  $$d{"past"}    =["ago"];&#10;  $$d{"next"}    =["next"];&#10;  $$d{"prev"}    =["previous","last"];&#10;  $$d{"later"}   =["later"];&#10;&#10;  $$d{"exact"}   =["exactly"];&#10;  $$d{"approx"}  =["approximately"];&#10;  $$d{"business"}=["business"];&#10;&#10;  $$d{"offset"}  =["yesterday","-0:0:0:1:0:0:0","tomorrow","+0:0:0:1:0:0:0","overmorrow","+0:0:0:2:0:0:0","ereyesterday","-0:0:0:2:0:0:0"];&#10;  $$d{"times"}   =["noon","12:00:00","midnight","00:00:00"];&#10;&#10;  $$d{"years"}   =["y","yr","year","yrs","years"];&#10;  $$d{"months"}  =["mon","month","months"];&#10;  $$d{"weeks"}   =["w","wk","wks","week","weeks"];&#10;  $$d{"days"}    =["d","day","days"];&#10;  $$d{"hours"}   =["h","hr","hrs","hour","hours"];&#10;  $$d{"minutes"} =["mn","min","minute","minutes"];&#10;  $$d{"seconds"} =["s","sec","second","seconds"];&#10;  $$d{"replace"} =["m","month"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;sub _Date_Init_Italian {&#10;  print "DEBUG: _Date_Init_Italian\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($i)=$h{"i`"};&#10;&#10;  $$d{"month_name"}=&#10;    [[qw(Gennaio Febbraio Marzo Aprile Maggio Giugno&#10;         Luglio Agosto Settembre Ottobre Novembre Dicembre)]];&#10;&#10;  $$d{"month_abb"}=&#10;    [[qw(Gen Feb Mar Apr Mag Giu Lug Ago Set Ott Nov Dic)]];&#10;&#10;  $$d{"day_name"}=&#10;    [[qw(Lunedi Martedi Mercoledi Giovedi Venerdi Sabato Domenica)],&#10;     [qw(Luned${i} Marted${i} Mercoled${i} Gioved${i} Venerd${i})]];&#10;  $$d{"day_abb"}=&#10;    [[qw(Lun Mar Mer Gio Ven Sab Dom)]];&#10;  $$d{"day_char"}=&#10;    [[qw(L Ma Me G V S D)]];&#10;&#10;  $$d{"num_suff"}=&#10;    [[qw(1mo 2do 3zo 4to 5to 6to 7mo 8vo 9no 10mo 11mo 12mo 13mo 14mo 15mo&#10;         16mo 17mo 18mo 19mo 20mo 21mo 22mo 23mo 24mo 25mo 26mo 27mo 28mo&#10;         29mo 3mo 31mo)]];&#10;  $$d{"num_word"}=&#10;    [[qw(primo secondo terzo quarto quinto sesto settimo ottavo nono decimo&#10;         undicesimo dodicesimo tredicesimo quattordicesimo quindicesimo&#10;         sedicesimo diciassettesimo diciottesimo diciannovesimo ventesimo&#10;         ventunesimo ventiduesimo ventitreesimo ventiquattresimo&#10;         venticinquesimo ventiseiesimo ventisettesimo ventottesimo&#10;         ventinovesimo trentesimo trentunesimo)]];&#10;&#10;  $$d{"now"}     =[qw(adesso)];&#10;  $$d{"today"}   =[qw(oggi)];&#10;  $$d{"last"}    =[qw(ultimo)];&#10;  $$d{"each"}    =[qw(ogni)];&#10;  $$d{"of"}      =[qw(della del)];&#10;  $$d{"at"}      =[qw(alle)];&#10;  $$d{"on"}      =[qw(di)];&#10;  $$d{"future"}  =[qw(fra)];&#10;  $$d{"past"}    =[qw(fa)];&#10;  $$d{"next"}    =[qw(prossimo)];&#10;  $$d{"prev"}    =[qw(ultimo)];&#10;  $$d{"later"}   =[qw(dopo)];&#10;&#10;  $$d{"exact"}   =[qw(esattamente)];&#10;  $$d{"approx"}  =[qw(circa)];&#10;  $$d{"business"}=[qw(lavorativi lavorativo)];&#10;&#10;  $$d{"offset"}  =[qw(ieri -0:0:0:1:0:0:0 domani +0:0:0:1:0:0:0)];&#10;  $$d{"times"}   =[qw(mezzogiorno 12:00:00 mezzanotte 00:00:00)];&#10;&#10;  $$d{"years"}   =[qw(anni anno a)];&#10;  $$d{"months"}  =[qw(mesi mese mes)];&#10;  $$d{"weeks"}   =[qw(settimane settimana sett)];&#10;  $$d{"days"}    =[qw(giorni giorno g)];&#10;  $$d{"hours"}   =[qw(ore ora h)];&#10;  $$d{"minutes"} =[qw(minuti minuto min)];&#10;  $$d{"seconds"} =[qw(secondi secondo sec)];&#10;  $$d{"replace"} =[qw(s sec m mes)];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = [qw(AM)];&#10;  $$d{"pm"}      = [qw(PM)];&#10;}&#10;&#10;sub _Date_Init_French {&#10;  print "DEBUG: _Date_Init_French\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($e)=$h{"e'"};&#10;  my($u)=$h{"u^"};&#10;  my($a)=$h{"a'"};&#10;&#10;  $$d{"month_name"}=&#10;    [["janvier","fevrier","mars","avril","mai","juin",&#10;      "juillet","aout","septembre","octobre","novembre","decembre"],&#10;     ["janvier","f${e}vrier","mars","avril","mai","juin",&#10;      "juillet","ao${u}t","septembre","octobre","novembre","d${e}cembre"]];&#10;  $$d{"month_abb"}=&#10;    [["jan","fev","mar","avr","mai","juin",&#10;      "juil","aout","sept","oct","nov","dec"],&#10;     ["jan","f${e}v","mar","avr","mai","juin",&#10;      "juil","ao${u}t","sept","oct","nov","d${e}c"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"]];&#10;  $$d{"day_abb"}=&#10;    [["lun","mar","mer","jeu","ven","sam","dim"]];&#10;  $$d{"day_char"}=&#10;    [["l","ma","me","j","v","s","d"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1er","2e","3e","4e","5e","6e","7e","8e","9e","10e",&#10;      "11e","12e","13e","14e","15e","16e","17e","18e","19e","20e",&#10;      "21e","22e","23e","24e","25e","26e","27e","28e","29e","30e",&#10;      "31e"]];&#10;  $$d{"num_word"}=&#10;    [["premier","deux","trois","quatre","cinq","six","sept","huit","neuf",&#10;      "dix","onze","douze","treize","quatorze","quinze","seize","dix-sept",&#10;      "dix-huit","dix-neuf","vingt","vingt et un","vingt-deux","vingt-trois",&#10;      "vingt-quatre","vingt-cinq","vingt-six","vingt-sept","vingt-huit",&#10;      "vingt-neuf","trente","trente et un"],&#10;     ["1re"]];&#10;&#10;  $$d{"now"}     =["maintenant"];&#10;  $$d{"today"}   =["aujourd'hui"];&#10;  $$d{"last"}    =["dernier"];&#10;  $$d{"each"}    =["chaque","tous les","toutes les"];&#10;  $$d{"of"}      =["en","de"];&#10;  $$d{"at"}      =["a","${a}0"];&#10;  $$d{"on"}      =["sur"];&#10;  $$d{"future"}  =["en"];&#10;  $$d{"past"}    =["il y a"];&#10;  $$d{"next"}    =["suivant"];&#10;  $$d{"prev"}    =["precedent","pr${e}c${e}dent"];&#10;  $$d{"later"}   =["plus tard"];&#10;&#10;  $$d{"exact"}   =["exactement"];&#10;  $$d{"approx"}  =["approximativement"];&#10;  $$d{"business"}=["professionel"];&#10;&#10;  $$d{"offset"}  =["hier","-0:0:0:1:0:0:0","demain","+0:0:0:1:0:0:0"];&#10;  $$d{"times"}   =["midi","12:00:00","minuit","00:00:00"];&#10;&#10;  $$d{"years"}   =["an","annee","ans","annees","ann${e}e","ann${e}es"];&#10;  $$d{"months"}  =["mois"];&#10;  $$d{"weeks"}   =["sem","semaine"];&#10;  $$d{"days"}    =["j","jour","jours"];&#10;  $$d{"hours"}   =["h","heure","heures"];&#10;  $$d{"minutes"} =["mn","min","minute","minutes"];&#10;  $$d{"seconds"} =["s","sec","seconde","secondes"];&#10;  $$d{"replace"} =["m","mois"];&#10;&#10;  $$d{"sephm"}   ='[h:]';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:,]';&#10;&#10;  $$d{"am"}      = ["du matin"];&#10;  $$d{"pm"}      = ["du soir"];&#10;}&#10;&#10;sub _Date_Init_Romanian {&#10;  print "DEBUG: _Date_Init_Romanian\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($p)=$h{"p"};&#10;  my($i)=$h{"i^"};&#10;  my($a)=$h{"a~"};&#10;  my($o)=$h{"-o"};&#10;&#10;  $$d{"month_name"}=&#10;    [["ianuarie","februarie","martie","aprilie","mai","iunie",&#10;      "iulie","august","septembrie","octombrie","noiembrie","decembrie"]];&#10;  $$d{"month_abb"}=&#10;    [["ian","febr","mart","apr","mai","iun",&#10;      "iul","aug","sept","oct","nov","dec"],&#10;     ["","feb"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["luni","marti","miercuri","joi","vineri","simbata","duminica"],&#10;     ["luni","mar${p}i","miercuri","joi","vineri","s${i}mb${a}t${a}",&#10;      "duminic${a}"]];&#10;  $$d{"day_abb"}=&#10;    [["lun","mar","mie","joi","vin","sim","dum"],&#10;     ["lun","mar","mie","joi","vin","s${i}m","dum"]];&#10;  $$d{"day_char"}=&#10;    [["L","Ma","Mi","J","V","S","D"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["prima","a doua","a 3-a","a 4-a","a 5-a","a 6-a","a 7-a","a 8-a",&#10;      "a 9-a","a 10-a","a 11-a","a 12-a","a 13-a","a 14-a","a 15-a",&#10;      "a 16-a","a 17-a","a 18-a","a 19-a","a 20-a","a 21-a","a 22-a",&#10;      "a 23-a","a 24-a","a 25-a","a 26-a","a 27-a","a 28-a","a 29-a",&#10;      "a 30-a","a 31-a"]];&#10;&#10;  $$d{"num_word"}=&#10;    [["prima","a doua","a treia","a patra","a cincea","a sasea","a saptea",&#10;      "a opta","a noua","a zecea","a unsprezecea","a doisprezecea",&#10;      "a treisprezecea","a patrusprezecea","a cincisprezecea","a saiprezecea",&#10;      "a saptesprezecea","a optsprezecea","a nouasprezecea","a douazecea",&#10;      "a douazecisiuna","a douazecisidoua","a douazecisitreia",&#10;      "a douazecisipatra","a douazecisicincea","a douazecisisasea",&#10;      "a douazecisisaptea","a douazecisiopta","a douazecisinoua","a treizecea",&#10;      "a treizecisiuna"],&#10;     ["prima","a doua","a treia","a patra","a cincea","a ${o}asea",&#10;      "a ${o}aptea","a opta","a noua","a zecea","a unsprezecea",&#10;      "a doisprezecea","a treisprezecea","a patrusprezecea","a cincisprezecea",&#10;      "a ${o}aiprezecea","a ${o}aptesprezecea","a optsprezecea",&#10;      "a nou${a}sprezecea","a dou${a}zecea","a dou${a}zeci${o}iuna",&#10;      "a dou${a}zeci${o}idoua","a dou${a}zeci${o}itreia",&#10;      "a dou${a}zeci${o}ipatra","a dou${a}zeci${o}icincea",&#10;      "a dou${a}zeci${o}i${o}asea","a dou${a}zeci${o}i${o}aptea",&#10;      "a dou${a}zeci${o}iopta","a dou${a}zeci${o}inoua","a treizecea",&#10;      "a treizeci${o}iuna"],&#10;     ["intii", "doi", "trei", "patru", "cinci", "sase", "sapte",&#10;      "opt","noua","zece","unsprezece","doisprezece",&#10;      "treisprezece","patrusprezece","cincisprezece","saiprezece",&#10;      "saptesprezece","optsprezece","nouasprezece","douazeci",&#10;      "douazecisiunu","douazecisidoi","douazecisitrei",&#10;      "douazecisipatru","douazecisicinci","douazecisisase","douazecisisapte",&#10;      "douazecisiopt","douazecisinoua","treizeci","treizecisiunu"],&#10;     ["${i}nt${i}i", "doi", "trei", "patru", "cinci", "${o}ase", "${o}apte",&#10;      "opt","nou${a}","zece","unsprezece","doisprezece",&#10;      "treisprezece","patrusprezece","cincisprezece","${o}aiprezece",&#10;      "${o}aptesprezece","optsprezece","nou${a}sprezece","dou${a}zeci",&#10;      "dou${a}zeci${o}iunu","dou${a}zeci${o}idoi","dou${a}zeci${o}itrei",&#10;      "dou${a}zecisipatru","dou${a}zeci${o}icinci","dou${a}zeci${o}i${o}ase",&#10;      "dou${a}zeci${o}i${o}apte","dou${a}zeci${o}iopt",&#10;      "dou${a}zeci${o}inou${a}","treizeci","treizeci${o}iunu"]];&#10;&#10;  $$d{"now"}     =["acum"];&#10;  $$d{"today"}   =["azi","astazi","ast${a}zi"];&#10;  $$d{"last"}    =["ultima"];&#10;  $$d{"each"}    =["fiecare"];&#10;  $$d{"of"}      =["din","in","n"];&#10;  $$d{"at"}      =["la"];&#10;  $$d{"on"}      =["on"];&#10;  $$d{"future"}  =["in","${i}n"];&#10;  $$d{"past"}    =["in urma", "${i}n urm${a}"];&#10;  $$d{"next"}    =["urmatoarea","urm${a}toarea"];&#10;  $$d{"prev"}    =["precedenta","ultima"];&#10;  $$d{"later"}   =["mai tirziu", "mai t${i}rziu"];&#10;&#10;  $$d{"exact"}   =["exact"];&#10;  $$d{"approx"}  =["aproximativ"];&#10;  $$d{"business"}=["de lucru","lucratoare","lucr${a}toare"];&#10;&#10;  $$d{"offset"}  =["ieri","-0:0:0:1:0:0:0",&#10;                   "alaltaieri", "-0:0:0:2:0:0:0",&#10;                   "alalt${a}ieri","-0:0:0:2:0:0:0",&#10;                   "miine","+0:0:0:1:0:0:0",&#10;                   "m${i}ine","+0:0:0:1:0:0:0",&#10;                   "poimiine","+0:0:0:2:0:0:0",&#10;                   "poim${i}ine","+0:0:0:2:0:0:0"];&#10;  $$d{"times"}   =["amiaza","12:00:00",&#10;                   "amiaz${a}","12:00:00",&#10;                   "miezul noptii","00:00:00",&#10;                   "miezul nop${p}ii","00:00:00"];&#10;&#10;  $$d{"years"}   =["ani","an","a"];&#10;  $$d{"months"}  =["luni","luna","lun${a}","l"];&#10;  $$d{"weeks"}   =["saptamini","s${a}pt${a}m${i}ni","saptamina",&#10;                   "s${a}pt${a}m${i}na","sapt","s${a}pt"];&#10;  $$d{"days"}    =["zile","zi","z"];&#10;  $$d{"hours"}   =["ore", "ora", "or${a}", "h"];&#10;  $$d{"minutes"} =["minute","min","m"];&#10;  $$d{"seconds"} =["secunde","sec",];&#10;  $$d{"replace"} =["s","secunde"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:,]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;sub _Date_Init_Swedish {&#10;  print "DEBUG: _Date_Init_Swedish\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($ao)=$h{"ao"};&#10;  my($o) =$h{"o:"};&#10;  my($a) =$h{"a:"};&#10;&#10;  $$d{"month_name"}=&#10;    [["Januari","Februari","Mars","April","Maj","Juni",&#10;      "Juli","Augusti","September","Oktober","November","December"]];&#10;  $$d{"month_abb"}=&#10;    [["Jan","Feb","Mar","Apr","Maj","Jun",&#10;      "Jul","Aug","Sep","Okt","Nov","Dec"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Mandag","Tisdag","Onsdag","Torsdag","Fredag","Lordag","Sondag"],&#10;     ["M${ao}ndag","Tisdag","Onsdag","Torsdag","Fredag","L${o}rdag",&#10;      "S${o}ndag"]];&#10;  $$d{"day_abb"}=&#10;    [["Man","Tis","Ons","Tor","Fre","Lor","Son"],&#10;     ["M${ao}n","Tis","Ons","Tor","Fre","L${o}r","S${o}n"]];&#10;  $$d{"day_char"}=&#10;    [["M","Ti","O","To","F","L","S"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1:a","2:a","3:e","4:e","5:e","6:e","7:e","8:e","9:e","10:e",&#10;      "11:e","12:e","13:e","14:e","15:e","16:e","17:e","18:e","19:e","20:e",&#10;      "21:a","22:a","23:e","24:e","25:e","26:e","27:e","28:e","29:e","30:e",&#10;      "31:a"]];&#10;  $$d{"num_word"}=&#10;    [["forsta","andra","tredje","fjarde","femte","sjatte","sjunde",&#10;      "attonde","nionde","tionde","elfte","tolfte","trettonde","fjortonde",&#10;      "femtonde","sextonde","sjuttonde","artonde","nittonde","tjugonde",&#10;      "tjugoforsta","tjugoandra","tjugotredje","tjugofjarde","tjugofemte",&#10;      "tjugosjatte","tjugosjunde","tjugoattonde","tjugonionde",&#10;      "trettionde","trettioforsta"],&#10;     ["f${o}rsta","andra","tredje","fj${a}rde","femte","sj${a}tte","sjunde",&#10;      "${ao}ttonde","nionde","tionde","elfte","tolfte","trettonde","fjortonde",&#10;      "femtonde","sextonde","sjuttonde","artonde","nittonde","tjugonde",&#10;      "tjugof${o}rsta","tjugoandra","tjugotredje","tjugofj${a}rde","tjugofemte",&#10;      "tjugosj${a}tte","tjugosjunde","tjugo${ao}ttonde","tjugonionde",&#10;      "trettionde","trettiof${o}rsta"]];&#10;&#10;  $$d{"now"}     =["nu"];&#10;  $$d{"today"}   =["idag"];&#10;  $$d{"last"}    =["forra","f${o}rra","senaste"];&#10;  $$d{"each"}    =["varje"];&#10;  $$d{"of"}      =["om"];&#10;  $$d{"at"}      =["kl","kl.","klockan"];&#10;  $$d{"on"}      =["pa","p${ao}"];&#10;  $$d{"future"}  =["om"];&#10;  $$d{"past"}    =["sedan"];&#10;  $$d{"next"}    =["nasta","n${a}sta"];&#10;  $$d{"prev"}    =["forra","f${o}rra"];&#10;  $$d{"later"}   =["senare"];&#10;&#10;  $$d{"exact"}   =["exakt"];&#10;  $$d{"approx"}  =["ungefar","ungef${a}r"];&#10;  $$d{"business"}=["arbetsdag","arbetsdagar"];&#10;&#10;  $$d{"offset"}  =["ig${ao}r","-0:0:0:1:0:0:0","igar","-0:0:0:1:0:0:0",&#10;                   "imorgon","+0:0:0:1:0:0:0"];&#10;  $$d{"times"}   =["mitt pa dagen","12:00:00","mitt p${ao} dagen","12:00:00",&#10;                   "midnatt","00:00:00"];&#10;&#10;  $$d{"years"}   =["ar","${ao}r"];&#10;  $$d{"months"}  =["man","manad","manader","m${ao}n","m${ao}nad","m${ao}nader"];&#10;  $$d{"weeks"}   =["v","vecka","veckor"];&#10;  $$d{"days"}    =["d","dag","dagar"];&#10;  $$d{"hours"}   =["t","tim","timme","timmar"];&#10;  $$d{"minutes"} =["min","minut","minuter"];&#10;  $$d{"seconds"} =["s","sek","sekund","sekunder"];&#10;  $$d{"replace"} =["m","minut"];&#10;&#10;  $$d{"sephm"}   ='[.:]';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["FM"];&#10;  $$d{"pm"}      = ["EM"];&#10;}&#10;&#10;sub _Date_Init_German {&#10;  print "DEBUG: _Date_Init_German\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($a)=$h{"a:"};&#10;  my($u)=$h{"u:"};&#10;  my($o)=$h{"o:"};&#10;  my($b)=$h{"beta"};&#10;&#10;  $$d{"month_name"}=&#10;    [["Januar","Februar","Maerz","April","Mai","Juni",&#10;      "Juli","August","September","Oktober","November","Dezember"],&#10;    ["J${a}nner","Februar","M${a}rz","April","Mai","Juni",&#10;      "Juli","August","September","Oktober","November","Dezember"]];&#10;  $$d{"month_abb"}=&#10;    [["Jan","Feb","Mar","Apr","Mai","Jun",&#10;      "Jul","Aug","Sep","Okt","Nov","Dez"],&#10;     ["J${a}n","Feb","M${a}r","Apr","Mai","Jun",&#10;      "Jul","Aug","Sep","Okt","Nov","Dez"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag",&#10;      "Sonntag"]];&#10;  $$d{"day_abb"}=&#10;    [["Mo","Di","Mi","Do","Fr","Sa","So"]];&#10;  $$d{"day_char"}=&#10;    [["M","Di","Mi","Do","F","Sa","So"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1.","2.","3.","4.","5.","6.","7.","8.","9.","10.",&#10;      "11.","12.","13.","14.","15.","16.","17.","18.","19.","20.",&#10;      "21.","22.","23.","24.","25.","26.","27.","28.","29.","30.",&#10;      "31."]];&#10;  $$d{"num_word"}=&#10;    [&#10;     ["erste","zweite","dritte","vierte","funfte","sechste","siebente",&#10;      "achte","neunte","zehnte","elfte","zwolfte","dreizehnte","vierzehnte",&#10;      "funfzehnte","sechzehnte","siebzehnte","achtzehnte","neunzehnte",&#10;      "zwanzigste","einundzwanzigste","zweiundzwanzigste","dreiundzwanzigste",&#10;      "vierundzwanzigste","funfundzwanzigste","sechundzwanzigste",&#10;      "siebundzwanzigste","achtundzwanzigste","neunundzwanzigste",&#10;      "dreibigste","einunddreibigste"],&#10;     ["erste","zweite","dritte","vierte","f${u}nfte","sechste","siebente",&#10;      "achte","neunte","zehnte","elfte","zw${o}lfte","dreizehnte",&#10;      "vierzehnte","f${u}nfzehnte","sechzehnte","siebzehnte","achtzehnte",&#10;      "neunzehnte","zwanzigste","einundzwanzigste","zweiundzwanzigste",&#10;      "dreiundzwanzigste","vierundzwanzigste","f${u}nfundzwanzigste",&#10;      "sechundzwanzigste","siebundzwanzigste","achtundzwanzigste",&#10;      "neunundzwanzigste","drei${b}igste","einunddrei${b}igste"],&#10;    ["erster"]];&#10;&#10;  $$d{"now"}     =["jetzt"];&#10;  $$d{"today"}   =["heute"];&#10;  $$d{"last"}    =["letzte","letzten"];&#10;  $$d{"each"}    =["jeden"];&#10;  $$d{"of"}      =["der","im","des"];&#10;  $$d{"at"}      =["um"];&#10;  $$d{"on"}      =["am"];&#10;  $$d{"future"}  =["in"];&#10;  $$d{"past"}    =["vor"];&#10;  $$d{"next"}    =["nachste","n${a}chste","nachsten","n${a}chsten"];&#10;  $$d{"prev"}    =["vorherigen","vorherige","letzte","letzten"];&#10;  $$d{"later"}   =["spater","sp${a}ter"];&#10;&#10;  $$d{"exact"}   =["genau"];&#10;  $$d{"approx"}  =["ungefahr","ungef${a}hr"];&#10;  $$d{"business"}=["Arbeitstag"];&#10;&#10;  $$d{"offset"}  =["gestern","-0:0:0:1:0:0:0","morgen","+0:0:0:1:0:0:0","${u}bermorgen","+0:0:0:2:0:0:0"];&#10;  $$d{"times"}   =["mittag","12:00:00","mitternacht","00:00:00"];&#10;&#10;  $$d{"years"}   =["j","Jahr","Jahre","Jahren"];&#10;  $$d{"months"}  =["Monat","Monate","Monaten"];&#10;  $$d{"weeks"}   =["w","Woche","Wochen"];&#10;  $$d{"days"}    =["t","Tag","Tage","Tagen"];&#10;  $$d{"hours"}   =["h","std","Stunde","Stunden"];&#10;  $$d{"minutes"} =["min","Minute","Minuten"];&#10;  $$d{"seconds"} =["s","sek","Sekunde","Sekunden"];&#10;  $$d{"replace"} =["m","Monat"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   ='[: ]';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["FM"];&#10;  $$d{"pm"}      = ["EM"];&#10;}&#10;&#10;sub _Date_Init_Dutch {&#10;  print "DEBUG: _Date_Init_Dutch\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;&#10;  $$d{"month_name"}=&#10;    [["januari","februari","maart","april","mei","juni","juli","augustus",&#10;      "september","october","november","december"],&#10;     ["","","","","","","","","","oktober"]];&#10;&#10;  $$d{"month_abb"}=&#10;    [["jan","feb","maa","apr","mei","jun","jul",&#10;      "aug","sep","oct","nov","dec"],&#10;     ["","","mrt","","","","","","","okt"]];&#10;  $$d{"day_name"}=&#10;    [["maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag",&#10;      "zondag"]];&#10;  $$d{"day_abb"}=&#10;    [["ma","di","wo","do","vr","zat","zon"],&#10;     ["","","","","","za","zo"]];&#10;  $$d{"day_char"}=&#10;    [["M","D","W","D","V","Za","Zo"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1ste","2de","3de","4de","5de","6de","7de","8ste","9de","10de",&#10;      "11de","12de","13de","14de","15de","16de","17de","18de","19de","20ste",&#10;      "21ste","22ste","23ste","24ste","25ste","26ste","27ste","28ste","29ste",&#10;      "30ste","31ste"]];&#10;  $$d{"num_word"}=&#10;    [["eerste","tweede","derde","vierde","vijfde","zesde","zevende","achtste",&#10;      "negende","tiende","elfde","twaalfde",&#10;      map {"${_}tiende";} qw (der veer vijf zes zeven acht negen),&#10;      "twintigste",&#10;      map {"${_}entwintigste";} qw (een twee drie vier vijf zes zeven acht&#10;                                    negen),&#10;      "dertigste","eenendertigste"],&#10;     ["","","","","","","","","","","","","","","","","","","","",&#10;      map {"${_}-en-twintigste";} qw (een twee drie vier vijf zes zeven acht&#10;                                      negen),&#10;      "dertigste","een-en-dertigste"],&#10;     ["een","twee","drie","vier","vijf","zes","zeven","acht","negen","tien",&#10;      "elf","twaalf",&#10;      map {"${_}tien"} qw (der veer vijf zes zeven acht negen),&#10;      "twintig",&#10;      map {"${_}entwintig"} qw (een twee drie vier vijf zes zeven acht negen),&#10;      "dertig","eenendertig"],&#10;     ["","","","","","","","","","","","","","","","","","","","",&#10;      map {"${_}-en-twintig"} qw (een twee drie vier vijf zes zeven acht&#10;                                  negen),&#10;      "dertig","een-en-dertig"]];&#10;&#10;  $$d{"now"}     =["nu","nou"];&#10;  $$d{"today"}   =["vandaag"];&#10;  $$d{"last"}    =["laatste"];&#10;  $$d{"each"}    =["elke","elk"];&#10;  $$d{"of"}      =["in","van"];&#10;  $$d{"at"}      =["om"];&#10;  $$d{"on"}      =["op"];&#10;  $$d{"future"}  =["over"];&#10;  $$d{"past"}    =["geleden","vroeger","eerder"];&#10;  $$d{"next"}    =["volgende","volgend"];&#10;  $$d{"prev"}    =["voorgaande","voorgaand"];&#10;  $$d{"later"}   =["later"];&#10;&#10;  $$d{"exact"}   =["exact","precies","nauwkeurig"];&#10;  $$d{"approx"}  =["ongeveer","ong",'ong\.',"circa","ca",'ca\.'];&#10;  $$d{"business"}=["werk","zakelijke","zakelijk"];&#10;&#10;  $$d{"offset"}  =["morgen","+0:0:0:1:0:0:0","overmorgen","+0:0:0:2:0:0:0",&#10;                   "gisteren","-0:0:0:1:0:0:0","eergisteren","-0::00:2:0:0:0"];&#10;  $$d{"times"}   =["noen","12:00:00","middernacht","00:00:00"];&#10;&#10;  $$d{"years"}   =["jaar","jaren","ja","j"];&#10;  $$d{"months"}  =["maand","maanden","mnd"];&#10;  $$d{"weeks"}   =["week","weken","w"];&#10;  $$d{"days"}    =["dag","dagen","d"];&#10;  $$d{"hours"}   =["uur","uren","u","h"];&#10;  $$d{"minutes"} =["minuut","minuten","min"];&#10;  $$d{"seconds"} =["seconde","seconden","sec","s"];&#10;  $$d{"replace"} =["m","minuten"];&#10;&#10;  $$d{"sephm"}   ='[:.uh]';&#10;  $$d{"sepms"}   ='[:.m]';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["am","a.m.","vm","v.m.","voormiddag","'s_ochtends",&#10;                    "ochtend","'s_nachts","nacht"];&#10;  $$d{"pm"}      = ["pm","p.m.","nm","n.m.","namiddag","'s_middags","middag",&#10;                    "'s_avonds","avond"];&#10;}&#10;&#10;sub _Date_Init_Polish {&#10;  print "DEBUG: _Date_Init_Polish\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;&#10;  $$d{"month_name"}=&#10;    [["stycznia","luty","marca","kwietnia","maja","czerwca",&#10;      "lipca","sierpnia","wrzesnia","pazdziernika","listopada","grudnia"],&#10;     ["stycznia","luty","marca","kwietnia","maja","czerwca","lipca",&#10;      "sierpnia","wrze\x9cnia","pa\x9fdziernika","listopada","grudnia"]];&#10;  $$d{"month_abb"}=&#10;    [["sty.","lut.","mar.","kwi.","maj","cze.",&#10;      "lip.","sie.","wrz.","paz.","lis.","gru."],&#10;     ["sty.","lut.","mar.","kwi.","maj","cze.",&#10;      "lip.","sie.","wrz.","pa\x9f.","lis.","gru."]];&#10;&#10;  $$d{"day_name"}=&#10;    [["poniedzialek","wtorek","sroda","czwartek","piatek","sobota",&#10;      "niedziela"],&#10;     ["poniedzia\x81\xb3ek","wtorek","\x9croda","czwartek","pi\x81\xb9tek",&#10;      "sobota","niedziela"]];&#10;  $$d{"day_abb"}=&#10;    [["po.","wt.","sr.","cz.","pi.","so.","ni."],&#10;     ["po.","wt.","\x9cr.","cz.","pi.","so.","ni."]];&#10;  $$d{"day_char"}=&#10;    [["p","w","e","c","p","s","n"],&#10;     ["p","w","\x9c.","c","p","s","n"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1.","2.","3.","4.","5.","6.","7.","8.","9.","10.",&#10;      "11.","12.","13.","14.","15.","16.","17.","18.","19.","20.",&#10;      "21.","22.","23.","24.","25.","26.","27.","28.","29.","30.",&#10;      "31."]];&#10;  $$d{"num_word"}=&#10;    [["pierwszego","drugiego","trzeczego","czwartego","piatego","szostego",&#10;      "siodmego","osmego","dziewiatego","dziesiatego",&#10;      "jedenastego","dwunastego","trzynastego","czternastego","pietnastego",&#10;      "szestnastego","siedemnastego","osiemnastego","dziewietnastego",&#10;      "dwudziestego",&#10;      "dwudziestego pierwszego","dwudziestego drugiego",&#10;      "dwudziestego trzeczego","dwudziestego czwartego",&#10;      "dwudziestego piatego","dwudziestego szostego",&#10;      "dwudziestego siodmego","dwudziestego osmego",&#10;      "dwudziestego dziewiatego","trzydziestego","trzydziestego pierwszego"],&#10;     ["pierwszego","drugiego","trzeczego","czwartego","pi\x81\xb9tego",&#10;      "sz\x81\xf3stego","si\x81\xf3dmego","\x81\xf3smego","dziewi\x81\xb9tego",&#10;      "dziesi\x81\xb9tego","jedenastego","dwunastego","trzynastego",&#10;      "czternastego","pi\x81\xeatnastego","szestnastego","siedemnastego",&#10;      "osiemnastego","dziewietnastego","dwudziestego",&#10;      "dwudziestego pierwszego","dwudziestego drugiego",&#10;      "dwudziestego trzeczego","dwudziestego czwartego",&#10;      "dwudziestego pi\x81\xb9tego","dwudziestego sz\x81\xf3stego",&#10;      "dwudziestego si\x81\xf3dmego","dwudziestego \x81\xf3smego",&#10;      "dwudziestego dziewi\x81\xb9tego","trzydziestego",&#10;      "trzydziestego pierwszego"]];&#10;&#10;  $$d{"now"}     =["teraz"];&#10;  $$d{"today"}   =["dzisaj"];&#10;  $$d{"last"}    =["ostatni","ostatna"];&#10;  $$d{"each"}    =["kazdy","ka\x81\xbfdy", "kazdym","ka\x81\xbfdym"];&#10;  $$d{"of"}      =["w","z"];&#10;  $$d{"at"}      =["o","u"];&#10;  $$d{"on"}      =["na"];&#10;  $$d{"future"}  =["za"];&#10;  $$d{"past"}    =["temu"];&#10;  $$d{"next"}    =["nastepny","nast\x81\xeapny","nastepnym","nast\x81\xeapnym",&#10;                   "przyszly","przysz\x81\xb3y","przyszlym",&#10;                   "przysz\x81\xb3ym"];&#10;  $$d{"prev"}    =["zeszly","zesz\x81\xb3y","zeszlym","zesz\x81\xb3ym"];&#10;  $$d{"later"}   =["later"];&#10;&#10;  $$d{"exact"}   =["doklandnie","dok\x81\xb3andnie"];&#10;  $$d{"approx"}  =["w przyblizeniu","w przybli\x81\xbfeniu","mniej wiecej",&#10;                   "mniej wi\x81\xeacej","okolo","oko\x81\xb3o"];&#10;  $$d{"business"}=["sluzbowy","s\x81\xb3u\x81\xbfbowy","sluzbowym",&#10;                   "s\x81\xb3u\x81\xbfbowym"];&#10;&#10;  $$d{"times"}   =["po\x81\xb3udnie","12:00:00",&#10;                   "p\x81\xf3\x81\xb3noc","00:00:00",&#10;                   "poludnie","12:00:00","polnoc","00:00:00"];&#10;  $$d{"offset"}  =["wczoraj","-0:0:1:0:0:0","jutro","+0:0:1:0:0:0"];&#10;&#10;  $$d{"years"}   =["rok","lat","lata","latach"];&#10;  $$d{"months"}  =["m.","miesiac","miesi\x81\xb9c","miesiecy",&#10;                   "miesi\x81\xeacy","miesiacu","miesi\x81\xb9cu"];&#10;  $$d{"weeks"}   =["ty.","tydzien","tydzie\x81\xf1","tygodniu"];&#10;  $$d{"days"}    =["d.","dzien","dzie\x81\xf1","dni"];&#10;  $$d{"hours"}   =["g.","godzina","godziny","godzinie"];&#10;  $$d{"minutes"} =["mn.","min.","minut","minuty"];&#10;  $$d{"seconds"} =["s.","sekund","sekundy"];&#10;  $$d{"replace"} =["m.","miesiac"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;sub _Date_Init_Spanish {&#10;  print "DEBUG: _Date_Init_Spanish\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;&#10;  $$d{"month_name"}=&#10;    [["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto",&#10;      "Septiembre","Octubre","Noviembre","Diciembre"]];&#10;&#10;  $$d{"month_abb"}=&#10;    [["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct",&#10;      "Nov","Dic"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Lunes","Martes","Miercoles","Jueves","Viernes","Sabado","Domingo"]];&#10;  $$d{"day_abb"}=&#10;    [["Lun","Mar","Mie","Jue","Vie","Sab","Dom"]];&#10;  $$d{"day_char"}=&#10;    [["L","Ma","Mi","J","V","S","D"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1o","2o","3o","4o","5o","6o","7o","8o","9o","10o",&#10;      "11o","12o","13o","14o","15o","16o","17o","18o","19o","20o",&#10;      "21o","22o","23o","24o","25o","26o","27o","28o","29o","30o","31o"],&#10;     ["1a","2a","3a","4a","5a","6a","7a","8a","9a","10a",&#10;      "11a","12a","13a","14a","15a","16a","17a","18a","19a","20a",&#10;      "21a","22a","23a","24a","25a","26a","27a","28a","29a","30a","31a"]];&#10;  $$d{"num_word"}=&#10;    [["Primero","Segundo","Tercero","Cuarto","Quinto","Sexto","Septimo",&#10;      "Octavo","Noveno","Decimo","Decimo Primero","Decimo Segundo",&#10;      "Decimo Tercero","Decimo Cuarto","Decimo Quinto","Decimo Sexto",&#10;      "Decimo Septimo","Decimo Octavo","Decimo Noveno","Vigesimo",&#10;      "Vigesimo Primero","Vigesimo Segundo","Vigesimo Tercero",&#10;      "Vigesimo Cuarto","Vigesimo Quinto","Vigesimo Sexto",&#10;      "Vigesimo Septimo","Vigesimo Octavo","Vigesimo Noveno","Trigesimo",&#10;      "Trigesimo Primero"],&#10;     ["Primera","Segunda","Tercera","Cuarta","Quinta","Sexta","Septima",&#10;      "Octava","Novena","Decima","Decimo Primera","Decimo Segunda",&#10;      "Decimo Tercera","Decimo Cuarta","Decimo Quinta","Decimo Sexta",&#10;      "Decimo Septima","Decimo Octava","Decimo Novena","Vigesima",&#10;      "Vigesimo Primera","Vigesimo Segunda","Vigesimo Tercera",&#10;      "Vigesimo Cuarta","Vigesimo Quinta","Vigesimo Sexta",&#10;      "Vigesimo Septima","Vigesimo Octava","Vigesimo Novena","Trigesima",&#10;      "Trigesimo Primera"]];&#10;&#10;  $$d{"now"}     =["Ahora"];&#10;  $$d{"today"}   =["Hoy"];&#10;  $$d{"last"}    =["ultimo"];&#10;  $$d{"each"}    =["cada"];&#10;  $$d{"of"}      =["en","de"];&#10;  $$d{"at"}      =["a"];&#10;  $$d{"on"}      =["el"];&#10;  $$d{"future"}  =["en"];&#10;  $$d{"past"}    =["hace"];&#10;  $$d{"next"}    =["siguiente"];&#10;  $$d{"prev"}    =["anterior"];&#10;  $$d{"later"}   =["later"];&#10;&#10;  $$d{"exact"}   =["exactamente"];&#10;  $$d{"approx"}  =["aproximadamente"];&#10;  $$d{"business"}=["laborales"];&#10;&#10;  $$d{"offset"}  =["ayer","-0:0:0:1:0:0:0","manana","+0:0:0:1:0:0:0"];&#10;  $$d{"times"}   =["mediodia","12:00:00","medianoche","00:00:00"];&#10;&#10;  $$d{"years"}   =["a","ano","ano","anos","anos"];&#10;  $$d{"months"}  =["m","mes","mes","meses"];&#10;  $$d{"weeks"}   =["sem","semana","semana","semanas"];&#10;  $$d{"days"}    =["d","dia","dias"];&#10;  $$d{"hours"}   =["hr","hrs","hora","horas"];&#10;  $$d{"minutes"} =["min","min","minuto","minutos"];&#10;  $$d{"seconds"} =["s","seg","segundo","segundos"];&#10;  $$d{"replace"} =["m","mes"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;sub _Date_Init_Portuguese {&#10;  print "DEBUG: _Date_Init_Portuguese\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($o) = $h{"-o"};&#10;  my($c) = $h{",c"};&#10;  my($a) = $h{"a'"};&#10;  my($e) = $h{"e'"};&#10;  my($u) = $h{"u'"};&#10;  my($o2)= $h{"o'"};&#10;  my($a2)= $h{"a`"};&#10;  my($a3)= $h{"a~"};&#10;  my($e2)= $h{"e^"};&#10;&#10;  $$d{"month_name"}=&#10;    [["Janeiro","Fevereiro","Marco","Abril","Maio","Junho",&#10;      "Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],&#10;     ["Janeiro","Fevereiro","Mar${c}o","Abril","Maio","Junho",&#10;      "Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"]];&#10;&#10;  $$d{"month_abb"}=&#10;    [["Jan","Fev","Mar","Abr","Mai","Jun",&#10;      "Jul","Ago","Set","Out","Nov","Dez"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Segunda","Terca","Quarta","Quinta","Sexta","Sabado","Domingo"],&#10;     ["Segunda","Ter${c}a","Quarta","Quinta","Sexta","S${a}bado","Domingo"]];&#10;  $$d{"day_abb"}=&#10;    [["Seg","Ter","Qua","Qui","Sex","Sab","Dom"],&#10;     ["Seg","Ter","Qua","Qui","Sex","S${a}b","Dom"]];&#10;  $$d{"day_char"}=&#10;    [["Sg","T","Qa","Qi","Sx","Sb","D"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1${o}","2${o}","3${o}","4${o}","5${o}","6${o}","7${o}","8${o}",&#10;      "9${o}","10${o}","11${o}","12${o}","13${o}","14${o}","15${o}",&#10;      "16${o}","17${o}","18${o}","19${o}","20${o}","21${o}","22${o}",&#10;      "23${o}","24${o}","25${o}","26${o}","27${o}","28${o}","29${o}",&#10;      "30${o}","31${o}"]];&#10;  $$d{"num_word"}=&#10;    [["primeiro","segundo","terceiro","quarto","quinto","sexto","setimo",&#10;      "oitavo","nono","decimo","decimo primeiro","decimo segundo",&#10;      "decimo terceiro","decimo quarto","decimo quinto","decimo sexto",&#10;      "decimo setimo","decimo oitavo","decimo nono","vigesimo",&#10;      "vigesimo primeiro","vigesimo segundo","vigesimo terceiro",&#10;      "vigesimo quarto","vigesimo quinto","vigesimo sexto","vigesimo setimo",&#10;      "vigesimo oitavo","vigesimo nono","trigesimo","trigesimo primeiro"],&#10;     ["primeiro","segundo","terceiro","quarto","quinto","sexto","s${e}timo",&#10;      "oitavo","nono","d${e}cimo","d${e}cimo primeiro","d${e}cimo segundo",&#10;      "d${e}cimo terceiro","d${e}cimo quarto","d${e}cimo quinto",&#10;      "d${e}cimo sexto","d${e}cimo s${e}timo","d${e}cimo oitavo",&#10;      "d${e}cimo nono","vig${e}simo","vig${e}simo primeiro",&#10;      "vig${e}simo segundo","vig${e}simo terceiro","vig${e}simo quarto",&#10;      "vig${e}simo quinto","vig${e}simo sexto","vig${e}simo s${e}timo",&#10;      "vig${e}simo oitavo","vig${e}simo nono","trig${e}simo",&#10;      "trig${e}simo primeiro"]];&#10;&#10;  $$d{"now"}     =["agora"];&#10;  $$d{"today"}   =["hoje"];&#10;  $$d{"last"}    =["${u}ltimo","ultimo"];&#10;  $$d{"each"}    =["cada"];&#10;  $$d{"of"}      =["da","do"];&#10;  $$d{"at"}      =["as","${a2}s"];&#10;  $$d{"on"}      =["na","no"];&#10;  $$d{"future"}  =["em"];&#10;  $$d{"past"}    =["a","${a2}"];&#10;  $$d{"next"}    =["proxima","proximo","pr${o2}xima","pr${o2}ximo"];&#10;  $$d{"prev"}    =["ultima","ultimo","${u}ltima","${u}ltimo"];&#10;  $$d{"later"}   =["passadas","passados"];&#10;&#10;  $$d{"exact"}   =["exactamente"];&#10;  $$d{"approx"}  =["aproximadamente"];&#10;  $$d{"business"}=["util","uteis"];&#10;&#10;  $$d{"offset"}  =["ontem","-0:0:0:1:0:0:0",&#10;                   "amanha","+0:0:0:1:0:0:0","amanh${a3}","+0:0:0:1:0:0:0"];&#10;  $$d{"times"}   =["meio-dia","12:00:00","meia-noite","00:00:00"];&#10;&#10;  $$d{"years"}   =["anos","ano","ans","an","a"];&#10;  $$d{"months"}  =["meses","m${e2}s","mes","m"];&#10;  $$d{"weeks"}   =["semanas","semana","sem","sems","s"];&#10;  $$d{"days"}    =["dias","dia","d"];&#10;  $$d{"hours"}   =["horas","hora","hr","hrs"];&#10;  $$d{"minutes"} =["minutos","minuto","min","mn"];&#10;  $$d{"seconds"} =["segundos","segundo","seg","sg"];&#10;  $$d{"replace"} =["m","mes","s","sems"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[,]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;sub _Date_Init_Russian {&#10;  print "DEBUG: _Date_Init_Russian\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;  my(%h)=();&#10;  _Char_8Bit(\%h);&#10;  my($a) =$h{"a:"};&#10;&#10;  $$d{"month_name"}=&#10;    [&#10;     ["\xd1\xce\xd7\xc1\xd2\xd1","\xc6\xc5\xd7\xd2\xc1\xcc\xd1",&#10;      "\xcd\xc1\xd2\xd4\xc1","\xc1\xd0\xd2\xc5\xcc\xd1","\xcd\xc1\xd1",&#10;      "\xc9\xc0\xce\xd1",&#10;      "\xc9\xc0\xcc\xd1","\xc1\xd7\xc7\xd5\xd3\xd4\xc1",&#10;      "\xd3\xc5\xce\xd4\xd1\xc2\xd2\xd1","\xcf\xcb\xd4\xd1\xc2\xd2\xd1",&#10;      "\xce\xcf\xd1\xc2\xd2\xd1","\xc4\xc5\xcb\xc1\xc2\xd2\xd1"],&#10;     ["\xd1\xce\xd7\xc1\xd2\xd8","\xc6\xc5\xd7\xd2\xc1\xcc\xd8",&#10;      "\xcd\xc1\xd2\xd4","\xc1\xd0\xd2\xc5\xcc\xd8","\xcd\xc1\xca",&#10;      "\xc9\xc0\xce\xd8",&#10;      "\xc9\xc0\xcc\xd8","\xc1\xd7\xc7\xd5\xd3\xd4",&#10;      "\xd3\xc5\xce\xd4\xd1\xc2\xd2\xd8","\xcf\xcb\xd4\xd1\xc2\xd2\xd8",&#10;      "\xce\xcf\xd1\xc2\xd2\xd8","\xc4\xc5\xcb\xc1\xc2\xd2\xd8"]&#10;    ];&#10;&#10;  $$d{"month_abb"}=&#10;    [["\xd1\xce\xd7","\xc6\xc5\xd7","\xcd\xd2\xd4","\xc1\xd0\xd2",&#10;      "\xcd\xc1\xca","\xc9\xc0\xce",&#10;      "\xc9\xc0\xcc","\xc1\xd7\xc7","\xd3\xce\xd4","\xcf\xcb\xd4",&#10;      "\xce\xcf\xd1\xc2","\xc4\xc5\xcb"],&#10;     ["","\xc6\xd7\xd2","","","\xcd\xc1\xd1","",&#10;      "","","\xd3\xc5\xce","\xcf\xcb\xd4","\xce\xcf\xd1",""]];&#10;&#10;  $$d{"day_name"}=&#10;    [["\xd0\xcf\xce\xc5\xc4\xc5\xcc\xd8\xce\xc9\xcb",&#10;      "\xd7\xd4\xcf\xd2\xce\xc9\xcb","\xd3\xd2\xc5\xc4\xc1",&#10;      "\xde\xc5\xd4\xd7\xc5\xd2\xc7","\xd0\xd1\xd4\xce\xc9\xc3\xc1",&#10;      "\xd3\xd5\xc2\xc2\xcf\xd4\xc1",&#10;      "\xd7\xcf\xd3\xcb\xd2\xc5\xd3\xc5\xce\xd8\xc5"]];&#10;  $$d{"day_abb"}=&#10;    [["\xd0\xce\xc4","\xd7\xd4\xd2","\xd3\xd2\xc4","\xde\xd4\xd7",&#10;      "\xd0\xd4\xce","\xd3\xd5\xc2","\xd7\xd3\xcb"],&#10;     ["\xd0\xcf\xce","\xd7\xd4\xcf","\xd3\xd2e","\xde\xc5\xd4",&#10;      "\xd0\xd1\xd4","\xd3\xd5\xc2","\xd7\xcf\xd3\xcb"]];&#10;  $$d{"day_char"}=&#10;    [["\xd0\xce","\xd7\xd4","\xd3\xd2","\xde\xd4","\xd0\xd4","\xd3\xc2",&#10;      "\xd7\xd3"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1 ","2 ","3 ","4 ","5 ","6 ","7 ","8 ","9 ","10 ",&#10;      "11 ","12 ","13 ","14 ","15 ","16 ","17 ","18 ","19 ","20 ",&#10;      "21 ","22 ","23 ","24 ","25 ","26 ","27 ","28 ","29 ","30 ",&#10;      "31 "]];&#10;  $$d{"num_word"}=&#10;    [["\xd0\xc5\xd2\xd7\xd9\xca","\xd7\xd4\xcf\xd2\xcf\xca",&#10;      "\xd4\xd2\xc5\xd4\xc9\xca","\xde\xc5\xd4\xd7\xc5\xd2\xd4\xd9\xca",&#10;      "\xd0\xd1\xd4\xd9\xca","\xdb\xc5\xd3\xd4\xcf\xca",&#10;      "\xd3\xc5\xc4\xd8\xcd\xcf\xca","\xd7\xcf\xd3\xd8\xcd\xcf\xca",&#10;      "\xc4\xc5\xd7\xd1\xd4\xd9\xca","\xc4\xc5\xd3\xd1\xd4\xd9\xca",&#10;      "\xcf\xc4\xc9\xce\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xc4\xd7\xc5\xce\xc1\xc4\xde\xc1\xd4\xd9\xca",&#10;      "\xd4\xd2\xc5\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xde\xc5\xd4\xd9\xd2\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xd0\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xdb\xc5\xd3\xd4\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xd7\xcf\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xc4\xc5\xd7\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xd9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xd4\xcf\xd2\xcf\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd4\xd2\xc5\xd4\xc9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xde\xc5\xd4\xd7\xc5\xd2\xd4\xd9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xd1\xd4\xd9\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xdb\xc5\xd3\xd4\xcf\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd3\xc5\xc4\xd8\xcd\xcf\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xcf\xd3\xd8\xcd\xcf\xca",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xc4\xc5\xd7\xd1\xd4\xd9\xca",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xd9\xca",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xd9\xca"],&#10;&#10;     ["\xd0\xc5\xd2\xd7\xcf\xc5","\xd7\xd4\xcf\xd2\xcf\xc5",&#10;      "\xd4\xd2\xc5\xd4\xd8\xc5","\xde\xc5\xd4\xd7\xc5\xd2\xd4\xcf\xc5",&#10;      "\xd0\xd1\xd4\xcf\xc5","\xdb\xc5\xd3\xd4\xcf\xc5",&#10;      "\xd3\xc5\xc4\xd8\xcd\xcf\xc5","\xd7\xcf\xd3\xd8\xcd\xcf\xc5",&#10;      "\xc4\xc5\xd7\xd1\xd4\xcf\xc5","\xc4\xc5\xd3\xd1\xd4\xcf\xc5",&#10;      "\xcf\xc4\xc9\xce\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc5\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xd4\xd2\xc5\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xde\xc5\xd4\xd9\xd2\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xd0\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xdb\xc5\xd3\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xd7\xcf\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xc4\xc5\xd7\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xd4\xcf\xd2\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd4\xd2\xc5\xd4\xd8\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xde\xc5\xd4\xd7\xc5\xd2\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xd1\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xdb\xc5\xd3\xd4\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd3\xc5\xc4\xd8\xcd\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xcf\xd3\xd8\xcd\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xc4\xc5\xd7\xd1\xd4\xcf\xc5",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xcf\xc5",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xcf\xc5"],&#10;&#10;     ["\xd0\xc5\xd2\xd7\xcf\xc7\xcf","\xd7\xd4\xcf\xd2\xcf\xc7\xcf",&#10;      "\xd4\xd2\xc5\xd4\xd8\xc5\xc7\xcf",&#10;      "\xde\xc5\xd4\xd7\xc5\xd2\xd4\xcf\xc7\xcf","\xd0\xd1\xd4\xcf\xc7\xcf",&#10;      "\xdb\xc5\xd3\xd4\xcf\xc7\xcf","\xd3\xc5\xc4\xd8\xcd\xcf\xc7\xcf",&#10;      "\xd7\xcf\xd3\xd8\xcd\xcf\xc7\xcf",&#10;      "\xc4\xc5\xd7\xd1\xd4\xcf\xc7\xcf","\xc4\xc5\xd3\xd1\xd4\xcf\xc7\xcf",&#10;      "\xcf\xc4\xc9\xce\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc5\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xd4\xd2\xc5\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xde\xc5\xd4\xd9\xd2\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xd0\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xdb\xc5\xd3\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xd7\xcf\xd3\xc5\xcd\xd8\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xc4\xc5\xd7\xd1\xd4\xce\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xd4\xcf\xd2\xcf\xc5",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd4\xd2\xc5\xd4\xd8\xc5\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xde\xc5\xd4\xd7\xc5\xd2\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd0\xd1\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xdb\xc5\xd3\xd4\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd3\xc5\xc4\xd8\xcd\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xd7\xcf\xd3\xd8\xcd\xcf\xc7\xcf",&#10;      "\xc4\xd7\xc1\xc4\xc3\xc1\xd4\xd8 \xc4\xc5\xd7\xd1\xd4\xcf\xc7\xcf",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xcf\xc7\xcf",&#10;      "\xd4\xd2\xc9\xc4\xc3\xc1\xd4\xd8 \xd0\xc5\xd2\xd7\xcf\xc7\xcf"]];&#10;&#10;  $$d{"now"}     =["\xd3\xc5\xca\xde\xc1\xd3"];&#10;  $$d{"today"}   =["\xd3\xc5\xc7\xcf\xc4\xce\xd1"];&#10;  $$d{"last"}    =["\xd0\xcf\xd3\xcc\xc5\xc4\xce\xc9\xca"];&#10;  $$d{"each"}    =["\xcb\xc1\xd6\xc4\xd9\xca"];&#10;  $$d{"of"}      =[" "];&#10;  $$d{"at"}      =["\xd7"];&#10;  $$d{"on"}      =["\xd7"];&#10;  $$d{"future"}  =["\xd7\xd0\xc5\xd2\xc5\xc4 \xce\xc1"];&#10;  $$d{"past"}    =["\xce\xc1\xda\xc1\xc4 \xce\xc1 "];&#10;  $$d{"next"}    =["\xd3\xcc\xc5\xc4\xd5\xc0\xdd\xc9\xca"];&#10;  $$d{"prev"}    =["\xd0\xd2\xc5\xc4\xd9\xc4\xd5\xdd\xc9\xca"];&#10;  $$d{"later"}   =["\xd0\xcf\xda\xd6\xc5"];&#10;&#10;  $$d{"exact"}   =["\xd4\xcf\xde\xce\xcf"];&#10;  $$d{"approx"}  =["\xd0\xd2\xc9\xcd\xc5\xd2\xce\xcf"];&#10;  $$d{"business"}=["\xd2\xc1\xc2\xcf\xde\xc9\xc8"];&#10;&#10;  $$d{"offset"}  =["\xd0\xcf\xda\xc1\xd7\xde\xc5\xd2\xc1","-0:0:0:2:0:0:0",&#10;                   "\xd7\xde\xc5\xd2\xc1","-0:0:0:1:0:0:0",&#10;                   "\xda\xc1\xd7\xd4\xd2\xc1","+0:0:0:1:0:0:0",&#10;                   "\xd0\xcf\xd3\xcc\xc5\xda\xc1\xd7\xd4\xd2\xc1",&#10;                   "+0:0:0:2:0:0:0"];&#10;  $$d{"times"}   =["\xd0\xcf\xcc\xc4\xc5\xce\xd8","12:00:00",&#10;                   "\xd0\xcf\xcc\xce\xcf\xde\xd8","00:00:00"];&#10;&#10;  $$d{"years"}   =["\xc7","\xc7\xc4","\xc7\xcf\xc4","\xcc\xc5\xd4",&#10;                   "\xcc\xc5\xd4","\xc7\xcf\xc4\xc1"];&#10;  $$d{"months"}  =["\xcd\xc5\xd3","\xcd\xc5\xd3\xd1\xc3",&#10;                   "\xcd\xc5\xd3\xd1\xc3\xc5\xd7"];&#10;  $$d{"weeks"}   =["\xce\xc5\xc4\xc5\xcc\xd1","\xce\xc5\xc4\xc5\xcc\xd8",&#10;                   "\xce\xc5\xc4\xc5\xcc\xc9","\xce\xc5\xc4\xc5\xcc\xc0"];&#10;  $$d{"days"}    =["\xc4","\xc4\xc5\xce\xd8","\xc4\xce\xc5\xca",&#10;                   "\xc4\xce\xd1"];&#10;  $$d{"hours"}   =["\xde","\xde.","\xde\xd3","\xde\xd3\xd7","\xde\xc1\xd3",&#10;                   "\xde\xc1\xd3\xcf\xd7","\xde\xc1\xd3\xc1"];&#10;  $$d{"minutes"} =["\xcd\xce","\xcd\xc9\xce","\xcd\xc9\xce\xd5\xd4\xc1",&#10;                   "\xcd\xc9\xce\xd5\xd4"];&#10;  $$d{"seconds"} =["\xd3","\xd3\xc5\xcb","\xd3\xc5\xcb\xd5\xce\xc4\xc1",&#10;                   "\xd3\xc5\xcb\xd5\xce\xc4"];&#10;  $$d{"replace"} =[];&#10;&#10;  $$d{"sephm"}   ="[:\xde]";&#10;  $$d{"sepms"}   ="[:\xcd]";&#10;  $$d{"sepss"}   ="[:.\xd3]";&#10;&#10;  $$d{"am"}      = ["\xc4\xd0","${a}\xf0","${a}.\xf0.","\xce\xcf\xde\xc9",&#10;                    "\xd5\xd4\xd2\xc1",&#10;                    "\xc4\xcf \xd0\xcf\xcc\xd5\xc4\xce\xd1"];&#10;  $$d{"pm"}      = ["\xd0\xd0","\xf0\xf0","\xf0.\xf0.","\xc4\xce\xd1",&#10;                    "\xd7\xc5\xde\xc5\xd2\xc1",&#10;                    "\xd0\xcf\xd3\xcc\xc5 \xd0\xcf\xcc\xd5\xc4\xce\xd1",&#10;                    "\xd0\xcf \xd0\xcf\xcc\xd5\xc4\xce\xc0"];&#10;}&#10;&#10;sub _Date_Init_Turkish {&#10;  print "DEBUG: _Date_Init_Turkish\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;&#10;  $$d{"month_name"}=&#10;    [&#10;     ["ocak","subat","mart","nisan","mayis","haziran",&#10;      "temmuz","agustos","eylul","ekim","kasim","aralik"],&#10;     ["ocak","\xfeubat","mart","nisan","may\xfds","haziran",&#10;      "temmuz","a\xf0ustos","eyl\xfcl","ekim","kas\xfdm","aral\xfdk"]&#10;     ];&#10;&#10;  $$d{"month_abb"}=&#10;    [&#10;     ["oca","sub","mar","nis","may","haz",&#10;      "tem","agu","eyl","eki","kas","ara"],&#10;     ["oca","\xfeub","mar","nis","may","haz",&#10;      "tem","a\xf0u","eyl","eki","kas","ara"]&#10;     ];&#10;&#10;  $$d{"day_name"}=&#10;    [&#10;     ["pazartesi","sali","carsamba","persembe","cuma","cumartesi","pazar"],&#10;     ["pazartesi","sal\xfd","\xe7ar\xfeamba","per\xfeembe","cuma",&#10;      "cumartesi","pazar"],&#10;     ];&#10;&#10;  $$d{"day_abb"}=&#10;    [&#10;     ["pzt","sal","car","per","cum","cts","paz"],&#10;     ["pzt","sal","\xe7ar","per","cum","cts","paz"],&#10;     ];&#10;&#10;  $$d{"day_char"}=&#10;    [["Pt","S","Cr","Pr","C","Ct","P"],&#10;     ["Pt","S","\xc7","Pr","C","Ct","P"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [[ "1.", "2.", "3.", "4.", "5.", "6.", "7.", "8.", "9.", "10.",&#10;       "11.", "12.", "13.", "14.", "15.", "16.", "17.", "18.", "19.", "20.",&#10;       "21.", "22.", "23.", "24.", "25.", "26.", "27.", "28.", "29.", "30.",&#10;       "31."]];&#10;&#10;  $$d{"num_word"}=&#10;    [&#10;     ["birinci","ikinci","ucuncu","dorduncu",&#10;      "besinci","altinci","yedinci","sekizinci",&#10;      "dokuzuncu","onuncu","onbirinci","onikinci",&#10;      "onucuncu","ondordoncu",&#10;      "onbesinci","onaltinci","onyedinci","onsekizinci",&#10;      "ondokuzuncu","yirminci","yirmibirinci","yirmikinci",&#10;      "yirmiucuncu","yirmidorduncu",&#10;      "yirmibesinci","yirmialtinci","yirmiyedinci","yirmisekizinci",&#10;      "yirmidokuzuncu","otuzuncu","otuzbirinci"],&#10;     ["birinci","ikinci","\xfc\xe7\xfcnc\xfc","d\xf6rd\xfcnc\xfc",&#10;      "be\xfeinci","alt\xfdnc\xfd","yedinci","sekizinci",&#10;      "dokuzuncu","onuncu","onbirinci","onikinci",&#10;      "on\xfc\xe7\xfcnc\xfc","ond\xf6rd\xfcnc\xfc",&#10;      "onbe\xfeinci","onalt\xfdnc\xfd","onyedinci","onsekizinci",&#10;      "ondokuzuncu","yirminci","yirmibirinci","yirmikinci",&#10;      "yirmi\xfc\xe7\xfcnc\xfc","yirmid\xf6rd\xfcnc\xfc",&#10;      "yirmibe\xfeinci","yirmialt\xfdnc\xfd","yirmiyedinci","yirmisekizinci",&#10;      "yirmidokuzuncu","otuzuncu","otuzbirinci"]&#10;     ];&#10;&#10;  $$d{"now"}     =["\xfeimdi", "simdi"];&#10;  $$d{"today"}   =["bugun", "bug\xfcn"];&#10;  $$d{"last"}    =["son", "sonuncu"];&#10;  $$d{"each"}    =["her"];&#10;  $$d{"of"}      =["of"];&#10;  $$d{"at"}      =["saat"];&#10;  $$d{"on"}      =["on"];&#10;  $$d{"future"}  =["gelecek"];&#10;  $$d{"past"}    =["ge\xe7mi\xfe", "gecmis","gecen", "ge\xe7en"];&#10;  $$d{"next"}    =["gelecek","sonraki"];&#10;  $$d{"prev"}    =["onceki","\xf6nceki"];&#10;  $$d{"later"}   =["sonra"];&#10;&#10;  $$d{"exact"}   =["tam"];&#10;  $$d{"approx"}  =["yakla\xfe\xfdk", "yaklasik"];&#10;  $$d{"business"}=["i\xfe","\xe7al\xfd\xfema","is", "calisma"];&#10;&#10;  $$d{"offset"}  =["d\xfcn","-0:0:0:1:0:0:0",&#10;                   "dun", "-0:0:0:1:0:0:0",&#10;                   "yar\xfdn","+0:0:0:1:0:0:0",&#10;                   "yarin","+0:0:0:1:0:0:0"];&#10;&#10;  $$d{"times"}   =["\xf6\xf0len","12:00:00",&#10;                   "oglen","12:00:00",&#10;                   "yarim","12:300:00",&#10;                   "yar\xfdm","12:30:00",&#10;                   "gece yar\xfds\xfd","00:00:00",&#10;                   "gece yarisi","00:00:00"];&#10;&#10;  $$d{"years"}   =["yil","y"];&#10;  $$d{"months"}  =["ay","a"];&#10;  $$d{"weeks"}   =["hafta", "h"];&#10;  $$d{"days"}    =["gun","g"];&#10;  $$d{"hours"}   =["saat"];&#10;  $$d{"minutes"} =["dakika","dak","d"];&#10;  $$d{"seconds"} =["saniye","sn",];&#10;  $$d{"replace"} =["s","saat"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:,]';&#10;&#10;  $$d{"am"}      = ["\xf6gleden \xf6nce","ogleden once"];&#10;  $$d{"pm"}      = ["\xf6\xf0leden sonra","ogleden sonra"];&#10;}&#10;&#10;sub _Date_Init_Danish {&#10;  print "DEBUG: _Date_Init_Danish\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;&#10;  $$d{"month_name"}=&#10;    [["Januar","Februar","Marts","April","Maj","Juni",&#10;      "Juli","August","September","Oktober","November","December"]];&#10;  $$d{"month_abb"}=&#10;    [["Jan","Feb","Mar","Apr","Maj","Jun",&#10;      "Jul","Aug","Sep","Okt","Nov","Dec"]];&#10;&#10;  $$d{"day_name"}=&#10;    [["Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lordag","Sondag"],&#10;     ["Mandag","Tirsdag","Onsdag","Torsdag","Fredag","L\xf8rdag","S\xf8ndag"]];&#10;&#10;  $$d{"day_abb"}=&#10;    [["Man","Tir","Ons","Tor","Fre","Lor","Son"],&#10;     ["Man","Tir","Ons","Tor","Fre","L\xf8r","S\xf8n"]];&#10;  $$d{"day_char"}=&#10;    [["M","Ti","O","To","F","L","S"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1:e","2:e","3:e","4:e","5:e","6:e","7:e","8:e","9:e","10:e",&#10;      "11:e","12:e","13:e","14:e","15:e","16:e","17:e","18:e","19:e","20:e",&#10;      "21:e","22:e","23:e","24:e","25:e","26:e","27:e","28:e","29:e","30:e",&#10;      "31:e"]];&#10;  $$d{"num_word"}=&#10;    [["forste","anden","tredie","fjerde","femte","sjette","syvende",&#10;      "ottende","niende","tiende","elfte","tolvte","trettende","fjortende",&#10;      "femtende","sekstende","syttende","attende","nittende","tyvende",&#10;      "enogtyvende","toogtyvende","treogtyvende","fireogtyvende","femogtyvende",&#10;      "seksogtyvende","syvogtyvende","otteogtyvende","niogtyvende",&#10;      "tredivte","enogtredivte"],&#10;     ["f\xf8rste","anden","tredie","fjerde","femte","sjette","syvende",&#10;      "ottende","niende","tiende","elfte","tolvte","trettende","fjortende",&#10;      "femtende","sekstende","syttende","attende","nittende","tyvende",&#10;      "enogtyvende","toogtyvende","treogtyvende","fireogtyvende","femogtyvende",&#10;      "seksogtyvende","syvogtyvende","otteogtyvende","niogtyvende",&#10;      "tredivte","enogtredivte"]];&#10;&#10;  $$d{"now"}     =["nu"];&#10;  $$d{"today"}   =["idag"];&#10;  $$d{"last"}    =["forrige","sidste","nyeste"];&#10;  $$d{"each"}    =["hver"];&#10;  $$d{"of"}      =["om"];&#10;  $$d{"at"}      =["kl","kl.","klokken"];&#10;  $$d{"on"}      =["pa","p\xe5"];&#10;  $$d{"future"}  =["om"];&#10;  $$d{"past"}    =["siden"];&#10;  $$d{"next"}    =["nasta","n\xe6ste"];&#10;  $$d{"prev"}    =["forrige"];&#10;  $$d{"later"}   =["senere"];&#10;&#10;  $$d{"exact"}   =["pracist","pr\xe6cist"];&#10;  $$d{"approx"}  =["circa"];&#10;  $$d{"business"}=["arbejdsdag","arbejdsdage"];&#10;&#10;  $$d{"offset"}  =["ig\xe5r","-0:0:0:1:0:0:0","igar","-0:0:0:1:0:0:0",&#10;                   "imorgen","+0:0:0:1:0:0:0"];&#10;  $$d{"times"}   =["midt pa dagen","12:00:00","midt p\xe5 dagen","12:00:00",&#10;                   "midnat","00:00:00"];&#10;&#10;  $$d{"years"}   =["ar","\xe5r"];&#10;  $$d{"months"}  =["man","maned","maneder","m\xe5n","m\xe5ned","m\xe5neder"];&#10;  $$d{"weeks"}   =["u","uge","uger"];&#10;  $$d{"days"}    =["d","dag","dage"];&#10;  $$d{"hours"}   =["t","tim","time","timer"];&#10;  $$d{"minutes"} =["min","minut","minutter"];&#10;  $$d{"seconds"} =["s","sek","sekund","sekunder"];&#10;  $$d{"replace"} =["m","minut"];&#10;&#10;  $$d{"sephm"}   ='[.:]';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["FM"];&#10;  $$d{"pm"}      = ["EM"];&#10;}&#10;&#10;sub _Date_Init_Catalan {&#10;  print "DEBUG: _Date_Init_Catalan\n"  if ($Curr{"Debug"} =~ /trace/);&#10;  my($d)=@_;&#10;&#10;  $$d{"month_name"}=&#10;    [["Gener","Febrer","Marc","Abril","Maig","Juny",&#10;      "Juliol","Agost","Setembre","Octubre","Novembre","Desembre"],&#10;     ["Gener","Febrer","Març","Abril","Maig","Juny",&#10;      "Juliol","Agost","Setembre","Octubre","Novembre","Desembre"],&#10;     ["Gener","Febrer","Marc,","Abril","Maig","Juny",&#10;      "Juliol","Agost","Setembre","Octubre","Novembre","Desembre"]];&#10;&#10;  $$d{"month_abb"}=&#10;    [["Gen","Feb","Mar","Abr","Mai","Jun",&#10;      "Jul","Ago","Set","Oct","Nov","Des"],&#10;     [],&#10;     ["","","","","","",&#10;      "","","","","","Dec"] #common mistake&#10;    ];&#10;&#10;  $$d{"day_name"}=&#10;    [["Dilluns","Dimarts","Dimecres","Dijous","Divendres","Dissabte","Diumenge"]];&#10;  $$d{"day_abb"}=&#10;    [["Dll","Dmt","Dmc","Dij","Div","Dis","Diu"],&#10;     ["","Dim","","","","",""],&#10;     ["","","Dic","","","",""]&#10;     ];&#10;  $$d{"day_char"}=&#10;    [["Dl","Dm","Dc","Dj","Dv","Ds","Du"] ,&#10;    ["L","M","X","J","V","S","U"]];&#10;&#10;  $$d{"num_suff"}=&#10;    [["1er","2n","3r","4t","5e","6e","7e","8e","9e","10e",&#10;      "11e","12e","13e","14e","15e","16e","17e","18e","19e","20e",&#10;      "21e","22e","23e","24e","25e","26e","27e","28e","29e","30e",&#10;      "31e"],&#10;     ["1er","2n","3r","4t","5è","6è","7è","8è","9è","10è",&#10;      "11è","12è","13è","14è","15è","16è","17è","18è","19è","20è",&#10;      "21è","22è","23è","24è","25è","26è","27è","28è","29è","30è",&#10;      "31è"]];&#10;  $$d{"num_word"}=&#10;    [["primer","segon","tercer","quart","cinque","sise","sete","vuite",&#10;      "nove","dese","onze","dotze","tretze","catorze",&#10;      "quinze","setze","dissete","divuite","dinove",&#10;      "vinte","vint-i-une","vint-i-dose","vint-i-trese",&#10;      "vint-i-quatre","vint-i-cinque","vint-i-sise","vint-i-sete",&#10;      "vint-i-vuite","vint-i-nove","trente","trenta-une"],&#10;     ["primer","segon","tercer","quart","cinquè","sisè","setè","vuitè",&#10;      "novè","desè","onzè","dotzè","tretzè","catorzè",&#10;      "quinzè","setzè","dissetè","divuitè","dinovè",&#10;      "vintè","vint-i-unè","vint-i-dosè","vint-i-tresè",&#10;      "vint-i-quatrè","vint-i-cinquè","vint-i-sisè","vint-i-setè",&#10;      "vint-i-vuitè","vint-i-novè","trentè","trenta-unè"]];&#10;&#10;  $$d{"now"}     =["avui","ara"];&#10;  $$d{"last"}    =["darrer","últim","darrera","última"];&#10;  $$d{"each"}    =["cada","cadascun","cadascuna"];&#10;  $$d{"of"}      =["de","d'"];&#10;  $$d{"at"}      =["a les","a","al"];&#10;  $$d{"on"}      =["el"];&#10;  $$d{"future"}  =["d'aquí a"];&#10;  $$d{"past"}    =["fa"];&#10;  $$d{"next"}    =["proper"];&#10;  $$d{"prev"}    =["passat","proppassat","anterior"];&#10;  $$d{"later"}   =["més tard"];&#10;&#10;  $$d{"exact"}   =["exactament"];&#10;  $$d{"approx"}  =["approximadament"];&#10;  $$d{"business"}=["empresa"];&#10;&#10;  $$d{"offset"}  =["ahir","-0:0:0:1:0:0:0","demà","+0:0:0:1:0:0:0","abans d'ahir","-0:0:0:2:0:0:0","demà passat","+0:0:0:2:0:0:0",];&#10;  $$d{"times"}   =["migdia","12:00:00","mitjanit","00:00:00"];&#10;&#10;  $$d{"years"}   =["a","an","any","anys"];&#10;  $$d{"months"}  =["mes","me","ms"];&#10;  $$d{"weeks"}   =["se","set","setm","setmana","setmanes"];&#10;  $$d{"days"}    =["d","dia","dies"];&#10;  $$d{"hours"}   =["h","ho","hores","hora"];&#10;  $$d{"minutes"} =["mn","min","minut","minuts"];&#10;  $$d{"seconds"} =["s","seg","segon","segons"];&#10;  $$d{"replace"} =["m","mes","s","setmana"];&#10;&#10;  $$d{"sephm"}   =':';&#10;  $$d{"sepms"}   =':';&#10;  $$d{"sepss"}   ='[.:]';&#10;&#10;  $$d{"am"}      = ["AM","A.M."];&#10;  $$d{"pm"}      = ["PM","P.M."];&#10;}&#10;&#10;########################################################################&#10;# FROM MY PERSONAL LIBRARIES&#10;########################################################################&#10;&#10;no integer;&#10;&#10;# _ModuloAddition($N,$add,\$val,\$rem);&#10;#   This calculates $val=$val+$add and forces $val to be in a certain range.&#10;#   This is useful for adding numbers for which only a certain range is&#10;#   allowed (for example, minutes can be between 0 and 59 or months can be&#10;#   between 1 and 12).  The absolute value of $N determines the range and&#10;#   the sign of $N determines whether the range is 0 to N-1 (if N&gt;0) or&#10;#   1 to N (N&lt;0).  The remainder (as modulo N) is added to $rem.&#10;#   Example:&#10;#     To add 2 hours together (with the excess returned in days) use:&#10;#       _ModuloAddition(60,$s1,\$s,\$day);&#10;sub _ModuloAddition {&#10;  my($N,$add,$val,$rem)=@_;&#10;  return  if ($N==0);&#10;  $$val+=$add;&#10;  if ($N&lt;0) {&#10;    # 1 to N&#10;    $N = -$N;&#10;    if ($$val&gt;$N) {&#10;      $$rem+= int(($$val-1)/$N);&#10;      $$val = ($$val-1)%$N +1;&#10;    } elsif ($$val&lt;1) {&#10;      $$rem-= int(-$$val/$N)+1;&#10;      $$val = $N-(-$$val % $N);&#10;    }&#10;&#10;  } else {&#10;    # 0 to N-1&#10;    if ($$val&gt;($N-1)) {&#10;      $$rem+= int($$val/$N);&#10;      $$val = $$val%$N;&#10;    } elsif ($$val&lt;0) {&#10;      $$rem-= int(-($$val+1)/$N)+1;&#10;      $$val = ($N-1)-(-($$val+1)%$N);&#10;    }&#10;  }&#10;}&#10;&#10;# $Flag=_IsInt($String [,$low, $high]);&#10;#    Returns 1 if $String is a valid integer, 0 otherwise.  If $low is&#10;#    entered, $String must be &gt;= $low.  If $high is entered, $String must&#10;#    be &lt;= $high.  It is valid to check only one of the bounds.&#10;sub _IsInt {&#10;  my($N,$low,$high)=@_;&#10;  return 0  if (! defined $N  or&#10;                $N !~ /^\s*[-+]?\d+\s*$/  or&#10;                defined $low   &amp;&amp;  $N&lt;$low  or&#10;                defined $high  &amp;&amp;  $N&gt;$high);&#10;  return 1;&#10;}&#10;&#10;# $File=_CleanFile($file);&#10;#   This cleans up a path to remove the following things:&#10;#     double slash       /a//b  -&gt; /a/b&#10;#     trailing dot       /a/.   -&gt; /a&#10;#     leading dot        ./a    -&gt; a&#10;#     trailing slash     a/     -&gt; a&#10;sub _CleanFile {&#10;  my($file)=@_;&#10;  $file =~ s/\s*$//;&#10;  $file =~ s/^\s*//;&#10;  $file =~ s|//+|/|g;  # multiple slash&#10;  $file =~ s|/\.$|/|;  # trailing /. (leaves trailing slash)&#10;  $file =~ s|^\./||    # leading ./&#10;    if ($file ne "./");&#10;  $file =~ s|/$||      # trailing slash&#10;    if ($file ne "/");&#10;  return $file;&#10;}&#10;&#10;# $File=_ExpandTilde($file);&#10;#   This checks to see if a "~" appears as the first character in a path.&#10;#   If it does, the "~" expansion is interpreted (if possible) and the full&#10;#   path is returned.  If a "~" expansion is used but cannot be&#10;#   interpreted, an empty string is returned.&#10;#&#10;#   This is Windows/Mac friendly.&#10;#   This is efficient.&#10;sub _ExpandTilde {&#10;  my($file)=shift;&#10;  my($user,$home)=();&#10;  # ~aaa/bbb=      ~  aaa      /bbb&#10;  if ($file =~ s|^~([^/]*)||) {&#10;    $user=$1;&#10;    # Single user operating systems (Mac, MSWindows) don't have the getpwnam&#10;    # and getpwuid routines defined.  Try to catch various different ways&#10;    # of knowing we are on one of these systems:&#10;    return ""  if ($OS eq "Windows"  or&#10;                   $OS eq "Mac"  or&#10;                   $OS eq "Netware"  or&#10;                   $OS eq "MPE");&#10;    $user=""  if (! defined $user);&#10;&#10;    if ($user) {&#10;      $home= (getpwnam($user))[7];&#10;    } else {&#10;      $home= (getpwuid($&lt;))[7];&#10;    }&#10;    $home = VMS::Filespec::unixpath($home)  if ($OS eq "VMS");&#10;    return ""  if (! $home);&#10;    $file="$home/$file";&#10;  }&#10;  $file;&#10;}&#10;&#10;# $File=_FullFilePath($file);&#10;#   Returns the full or relative path to $file (expanding "~" if necessary).&#10;#   Returns an empty string if a "~" expansion cannot be interpreted.  The&#10;#   path does not need to exist.  _CleanFile is called.&#10;sub _FullFilePath {&#10;  my($file)=shift;&#10;  my($rootpat) = '^/'; #default pattern to match absolute path&#10;  $rootpat = '^(\\|/|([A-Za-z]:[\\/]))' if ($OS eq 'Windows');&#10;  $file=_ExpandTilde($file);&#10;  return ""  if (! $file);&#10;  return _CleanFile($file);&#10;}&#10;&#10;# $Flag=_CheckFilePath($file [,$mode]);&#10;#   Checks to see if $file exists, to see what type it is, and whether&#10;#   the script can access it.  If it exists and has the correct mode, 1&#10;#   is returned.&#10;#&#10;#   $mode is a string which may contain any of the valid file test operator&#10;#   characters except t, M, A, C.  The appropriate test is run for each&#10;#   character.  For example, if $mode is "re" the -r and -e tests are both&#10;#   run.&#10;#&#10;#   An empty string is returned if the file doesn't exist.  A 0 is returned&#10;#   if the file exists but any test fails.&#10;#&#10;#   All characters in $mode which do not correspond to valid tests are&#10;#   ignored.&#10;sub _CheckFilePath {&#10;  my($file,$mode)=@_;&#10;  my($test)=();&#10;  $file=_FullFilePath($file);&#10;  $mode = ""  if (! defined $mode);&#10;&#10;  # Run tests&#10;  return 0  if (! defined $file or ! $file);&#10;  return 0  if ((                  ! -e $file) or&#10;                ($mode =~ /r/  &amp;&amp;  ! -r $file) or&#10;                ($mode =~ /w/  &amp;&amp;  ! -w $file) or&#10;                ($mode =~ /x/  &amp;&amp;  ! -x $file) or&#10;                ($mode =~ /R/  &amp;&amp;  ! -R $file) or&#10;                ($mode =~ /W/  &amp;&amp;  ! -W $file) or&#10;                ($mode =~ /X/  &amp;&amp;  ! -X $file) or&#10;                ($mode =~ /o/  &amp;&amp;  ! -o $file) or&#10;                ($mode =~ /O/  &amp;&amp;  ! -O $file) or&#10;                ($mode =~ /z/  &amp;&amp;  ! -z $file) or&#10;                ($mode =~ /s/  &amp;&amp;  ! -s $file) or&#10;                ($mode =~ /f/  &amp;&amp;  ! -f $file) or&#10;                ($mode =~ /d/  &amp;&amp;  ! -d $file) or&#10;                ($mode =~ /l/  &amp;&amp;  ! -l $file) or&#10;                ($mode =~ /s/  &amp;&amp;  ! -s $file) or&#10;                ($mode =~ /p/  &amp;&amp;  ! -p $file) or&#10;                ($mode =~ /b/  &amp;&amp;  ! -b $file) or&#10;                ($mode =~ /c/  &amp;&amp;  ! -c $file) or&#10;                ($mode =~ /u/  &amp;&amp;  ! -u $file) or&#10;                ($mode =~ /g/  &amp;&amp;  ! -g $file) or&#10;                ($mode =~ /k/  &amp;&amp;  ! -k $file) or&#10;                ($mode =~ /T/  &amp;&amp;  ! -T $file) or&#10;                ($mode =~ /B/  &amp;&amp;  ! -B $file));&#10;  return 1;&#10;}&#10;#&amp;&amp;&#10;&#10;# $Path=_FixPath($path [,$full] [,$mode] [,$error]);&#10;#   Makes sure that every directory in $path (a colon separated list of&#10;#   directories) appears as a full path or relative path.  All "~"&#10;#   expansions are removed.  All trailing slashes are removed also.  If&#10;#   $full is non-nil, relative paths are expanded to full paths as well.&#10;#&#10;#   If $mode is given, it may be either "e", "r", or "w".  In this case,&#10;#   additional checking is done to each directory.  If $mode is "e", it&#10;#   need ony exist to pass the check.  If $mode is "r", it must have have&#10;#   read and execute permission.  If $mode is "w", it must have read,&#10;#   write, and execute permission.&#10;#&#10;#   The value of $error determines what happens if the directory does not&#10;#   pass the test.  If it is non-nil, if any directory does not pass the&#10;#   test, the subroutine returns the empty string.  Otherwise, it is simply&#10;#   removed from $path.&#10;#&#10;#   The corrected path is returned.&#10;sub _FixPath {&#10;  my($path,$full,$mode,$err)=@_;&#10;  local($_)="";&#10;  my(@dir)=split(/$Cnf{"PathSep"}/,$path);&#10;  $full=0  if (! defined $full);&#10;  $mode="" if (! defined $mode);&#10;  $err=0   if (! defined $err);&#10;  $path="";&#10;  if ($mode eq "e") {&#10;    $mode="de";&#10;  } elsif ($mode eq "r") {&#10;    $mode="derx";&#10;  } elsif ($mode eq "w") {&#10;    $mode="derwx";&#10;  }&#10;&#10;  foreach (@dir) {&#10;&#10;    # Expand path&#10;    if ($full) {&#10;      $_=_FullFilePath($_);&#10;    } else {&#10;      $_=_ExpandTilde($_);&#10;    }&#10;    if (! $_) {&#10;      return ""  if ($err);&#10;      next;&#10;    }&#10;&#10;    # Check mode&#10;    if (! $mode  or  _CheckFilePath($_,$mode)) {&#10;      $path .= $Cnf{"PathSep"} . $_;&#10;    } else {&#10;      return "" if ($err);&#10;    }&#10;  }&#10;  $path =~ s/^$Cnf{"PathSep"}//;&#10;  return $path;&#10;}&#10;#&amp;&amp;&#10;&#10;# $File=_SearchPath($file,$path [,$mode] [,@suffixes]);&#10;#   Searches through directories in $path for a file named $file.  The&#10;#   full path is returned if one is found, or an empty string otherwise.&#10;#   The file may exist with one of the @suffixes.  The mode is checked&#10;#   similar to _CheckFilePath.&#10;#&#10;#   The first full path that matches the name and mode is returned.  If none&#10;#   is found, an empty string is returned.&#10;sub _SearchPath {&#10;  my($file,$path,$mode,@suff)=@_;&#10;  my($f,$s,$d,@dir,$fs)=();&#10;  $path=_FixPath($path,1,"r");&#10;  @dir=split(/$Cnf{"PathSep"}/,$path);&#10;  foreach $d (@dir) {&#10;    $f="$d/$file";&#10;    $f=~ s|//|/|g;&#10;    return $f if (_CheckFilePath($f,$mode));&#10;    foreach $s (@suff) {&#10;      $fs="$f.$s";&#10;      return $fs if (_CheckFilePath($fs,$mode));&#10;    }&#10;  }&#10;  return "";&#10;}&#10;&#10;# @list=_ReturnList($str);&#10;#    This takes a string which should be a comma separated list of integers&#10;#    or ranges (5-7).  It returns a sorted list of all integers referred to&#10;#    by the string, or () if there is an invalid element.&#10;#&#10;#    Negative integers are also handled.  "-2--1" is equivalent to "-2,-1".&#10;sub _ReturnList {&#10;  my($str)=@_;&#10;  my(@ret,@str,$from,$to,$tmp)=();&#10;  @str=split(/,/,$str);&#10;  foreach $str (@str) {&#10;    if ($str =~ /^[-+]?\d+$/) {&#10;      push(@ret,$str);&#10;    } elsif ($str =~ /^([-+]?\d+)-([-+]?\d+)$/) {&#10;      ($from,$to)=($1,$2);&#10;      if ($from&gt;$to) {&#10;        $tmp=$from;&#10;        $from=$to;&#10;        $to=$tmp;&#10;      }&#10;      push(@ret,$from..$to);&#10;    } else {&#10;      return ();&#10;    }&#10;  }&#10;  @ret;&#10;}&#10;&#10;1;&#10;# Local Variables:&#10;# mode: cperl&#10;# indent-tabs-mode: nil&#10;# cperl-indent-level: 3&#10;# cperl-continued-statement-offset: 2&#10;# cperl-continued-brace-offset: 0&#10;# cperl-brace-offset: 0&#10;# cperl-brace-imaginary-offset: 0&#10;# cperl-label-offset: -2&#10;# End:&#10;</value>
      </property>
      <property>
        <propertyName>ec_tags</propertyName>
        <expandable>1</expandable>
        <value>  </value>
      </property>
      <property>
        <propertyName>tz</propertyName>
        <description>Local Timezone to be used when converting time values</description>
        <expandable>0</expandable>
        <value>CST5CDT</value>
      </property>
      <property>
        <propertyName>wftimer.pl</propertyName>
        <description></description>
        <expandable>0</expandable>
        <value>#!/bin/perl&#10;# wftimer - a tool to perform scheduled transitions for workflows.&#10;#&#10;# This code is intended to run from a scheduled procedure.  It locates all&#10;# active workflows where the "wft_transition_time" property value occurs&#10;# in the past, and for each workflow thus found, it performs the manual&#10;# transition named in the "wft_transition_name" property (after setting&#10;# the "wft_transitioned" property, which is used to exclude workflows that&#10;# have already been transitioned).&#10;&#10;use strict;&#10;use ElectricCommander;&#10;&#10;my $debug = 1;&#10;&#10;# Find out when "now" is in a string we can use with findObjects()&#10;my ($sec,$min,$hour,$mday,$mon,$year,$wday, $yday) = gmtime();&#10;my $timeNow = sprintf("%04d-%02d-%02dT%02d:%02d:%02d.000Z",&#10;		  $year + 1900, $mon + 1, $mday, $hour, $min, $sec);&#10;print "Time now is: $timeNow\n";&#10;&#10;my $ec = new ElectricCommander();&#10;my $xp = $ec-&gt;findObjects("transition", {&#10;    maxIds =&gt; 0,&#10;    sort =&gt; [ {propertyName =&gt; "projectName",  order =&gt; 'ascending'},&#10;	      {propertyName =&gt; "workflowName", order =&gt; 'ascending'},&#10;	      {propertyName =&gt; "stateName",    order =&gt; 'ascending'},&#10;	      {propertyName =&gt; "index",        order =&gt; 'ascending'} ],&#10;    select =&gt; [ {propertyName =&gt; "wftTransitionTime"},&#10;		{propertyName =&gt; "wftTransitioned"} ],&#10;    filter =&gt; [&#10;	       {operator    =&gt; "and",&#10;	        filter =&gt; [ {propertyName =&gt; "trigger",&#10;			     operator     =&gt; "equals",&#10;			     operand1     =&gt; "manual"},&#10;			    {propertyName =&gt; "wftTransitionTime",&#10;			     operator     =&gt; "lessOrEqual",&#10;			     operand1     =&gt; $timeNow},&#10;			    {propertyName =&gt; "wftTransitioned",&#10;			     operator     =&gt; "isNull"},&#10;		          ],&#10;	       },&#10;	     ],&#10;	}&#10;    );&#10;print "findObjects:\n" . $xp-&gt;findnodes_as_string("/") . "\n" if ($debug &gt; 2);&#10;&#10;my %haveSeenWF = ();&#10;&#10;my $objectNodeset = $xp-&gt;find('/responses/response/object');&#10;foreach my $o ( $objectNodeset-&gt;get_nodelist() ) {&#10;    print "\nProcessing Node:\n" . XML::XPath::XMLParser::as_string($o) . "\n" if ($debug &gt; 1);&#10;    my $objectId = $xp-&gt;find('./objectId', $o)-&gt;string_value();&#10;    my $project = $xp-&gt;find('./transition/projectName', $o)-&gt;string_value();&#10;    my $workflow = $xp-&gt;find('./transition/workflowName', $o)-&gt;string_value();&#10;    my $state = $xp-&gt;find('./transition/stateName', $o)-&gt;string_value();&#10;    my $transition = $xp-&gt;find('./transition/transitionName', $o)-&gt;string_value();&#10;    my $target = $xp-&gt;find('./transition/targetState', $o)-&gt;string_value();&#10;    my $index = $xp-&gt;find('./transition/index', $o)-&gt;string_value();&#10;&#10;    my $wfxp = $ec-&gt;getWorkflow($project, $workflow);&#10;    my $activeState = $wfxp-&gt;find('/responses/response/workflow/activeState')-&gt;string_value();&#10;    my $completed = $wfxp-&gt;find('/responses/response/workflow/completed')-&gt;string_value();&#10;    my $workflowId = $wfxp-&gt;find('/responses/response/workflow/workflowId')-&gt;string_value();&#10;&#10;    print "($objectId) $project $workflow " if ($debug);&#10;    if ($completed) {&#10;	print "(completed)\n" if ($debug);&#10;	next;&#10;    }&#10;&#10;    print "$state " if ($debug);&#10;    if ($state ne $activeState) {&#10;	print "(inactive state)\n" if ($debug);&#10;	next;&#10;    }&#10;&#10;    print  "\"$transition\" ($index) -&gt; \"$target\"\n" if ($debug);&#10;&#10;    if ($haveSeenWF{$workflowId}) {&#10;	print "Workflow \"$workflow\": already transitioned, skipping \"$transition\" ($index) -&gt; \"$target\"\n";&#10;    } else {&#10;	$haveSeenWF{$workflowId}++;&#10;	print "Workflow \"$workflow\": performing transition \"$transition\" ($index) -&gt; \"$target\"\n";&#10;        my $pxp = $ec-&gt;setProperty('wftTransitioned', '1', {objectId=&gt;$objectId});&#10;	my $txp = $ec-&gt;transitionWorkflow($project, $workflow, $state, $transition);&#10;    }&#10;}&#10;</value>
      </property>
    </propertySheet>
    <procedure>
      <procedureName>tick</procedureName>
      <description>&lt;html&gt;&lt;i&gt;Timer Tick&lt;/i&gt; - a procedure executed periodically via schedule that looks for workflow transitions to be performed.&lt;/html&gt;</description>
      <jobNameTemplate></jobNameTemplate>
      <resourceName>local</resourceName>
      <workspaceName>default</workspaceName>
      <propertySheet>
      </propertySheet>
      <step>
        <stepName>Find and execute transitions</stepName>
        <alwaysRun>0</alwaysRun>
        <broadcast>0</broadcast>
        <command>$[/myProject/wftimer.pl]</command>
        <condition></condition>
        <description>An ec-perl step that uses findObjects to locate all transitions that are ready to be transitioned, and executes those transitions</description>
        <errorHandling>abortProcedure</errorHandling>
        <exclusiveMode>none</exclusiveMode>
        <logFileName></logFileName>
        <parallel>0</parallel>
        <postProcessor></postProcessor>
        <releaseMode>none</releaseMode>
        <resourceName></resourceName>
        <shell>ec-perl</shell>
        <timeLimit>15</timeLimit>
        <timeLimitUnits>minutes</timeLimitUnits>
        <workingDirectory></workingDirectory>
        <workspaceName></workspaceName>
        <propertySheet>
          <property>
            <propertyName>ec_customEditorData</propertyName>
            <propertySheet>
              <property>
                <propertyName>formType</propertyName>
                <expandable>1</expandable>
                <value>command</value>
              </property>
            </propertySheet>
          </property>
        </propertySheet>
      </step>
      <step>
        <stepName>cleanup</stepName>
        <alwaysRun>1</alwaysRun>
        <broadcast>0</broadcast>
        <command># Cleanup: liberally re-used from ElectricSentry::Driver.pm&#10;#&#10;# Copyright (c) 2006-2009 Electric Cloud, Inc.&#10;# All rights reserved&#10;&#10;use strict;&#10;use ElectricCommander;&#10;use XML::XPath;&#10;&#10;#-------------------------------------------------------------------------&#10;# Cleanup&#10;#-------------------------------------------------------------------------&#10;&#10;my $ec = ElectricCommander-&gt;new();&#10;&#10;# Check for the OS Type&#10;my $osIsWindows = $^O =~ /MSWin/;&#10;&#10;#  Find all previous runs of this job&#10;my @filterList;&#10;push(&#10;    @filterList,&#10;    {&#10;	"propertyName" =&gt; "projectName",&#10;	"operator"     =&gt; "equals",&#10;	"operand1"     =&gt; '$[/myProject/projectName]'&#10;    }&#10;);&#10;push(&#10;    @filterList,&#10;    {&#10;        "propertyName" =&gt; "procedureName",&#10;        "operator"     =&gt; "equals",&#10;        "operand1"     =&gt; '$[/myProcedure/procedureName]'&#10;    }&#10;);&#10;push(&#10;    @filterList,&#10;    {&#10;        "propertyName" =&gt; "status",&#10;        "operator"     =&gt; "equals",&#10;        "operand1"     =&gt; "completed"&#10;    }&#10;);&#10;&#10;# Run the Query&#10;my $xPath = $ec-&gt;findObjects("job", {numObjects =&gt; "500", filter =&gt; \@filterList});&#10;&#10;# Loop over all returned jobs&#10;my $nodeset = $xPath-&gt;find('//job');&#10;foreach my $node ( $nodeset-&gt;get_nodelist ) {&#10;&#10;    #  Find the workspaces (there can be more than one if some steps&#10;    #  were configured to use a different workspace&#10;    my $jobId   = $xPath-&gt;findvalue( 'jobId',   $node );&#10;    my $jobName = $xPath-&gt;findvalue( 'jobName', $node );&#10;    my $xPath = $ec-&gt;getJobInfo($jobId);&#10;    my $wsNodeset = $xPath-&gt;find('//job/workspace');&#10;    foreach my $wsNode ( $wsNodeset-&gt;get_nodelist ) {&#10;&#10;        my $workspace;&#10;        if ($osIsWindows) {&#10;            $workspace = $xPath-&gt;findvalue( './winUNC', $wsNode );&#10;            $workspace =~ s/\/\//\\\\/g;&#10;        } else {&#10;            $workspace = $xPath-&gt;findvalue( './unix', $wsNode );&#10;        }&#10;&#10;        # Delete the workspace (after checking its name as a sanity test)&#10;        # look for "job_nnn" or "ElectricSentry-nnn"&#10;        if ( $workspace =~ /[-_][\d]+$/ ) {&#10;            use File::Path;&#10;            rmtree( [$workspace] );&#10;            print "Deleted workspace - $workspace\n";&#10;        }&#10;    }&#10;&#10;    # Delete the job&#10;    $ec-&gt;deleteJob($jobId);&#10;    print "Deleted job - $jobName\n";&#10;}&#10;</command>
        <condition></condition>
        <description>Cleans up old job records.</description>
        <errorHandling>failProcedure</errorHandling>
        <exclusiveMode>none</exclusiveMode>
        <logFileName></logFileName>
        <parallel>0</parallel>
        <postProcessor></postProcessor>
        <releaseMode>none</releaseMode>
        <resourceName></resourceName>
        <shell>ec-perl</shell>
        <timeLimit>5</timeLimit>
        <timeLimitUnits>minutes</timeLimitUnits>
        <workingDirectory></workingDirectory>
        <workspaceName></workspaceName>
        <propertySheet>
          <property>
            <propertyName>ec_customEditorData</propertyName>
            <propertySheet>
              <property>
                <propertyName>formType</propertyName>
                <expandable>1</expandable>
                <value>command</value>
              </property>
            </propertySheet>
          </property>
        </propertySheet>
      </step>
    </procedure>
    <procedure>
      <procedureName>TransitionAt</procedureName>
      <description>Library sub-procedure used to mark a transition to transition at a specific time.</description>
      <jobNameTemplate></jobNameTemplate>
      <resourceName></resourceName>
      <workspaceName></workspaceName>
      <propertySheet>
        <property>
          <propertyName>ec_customEditorData</propertyName>
          <propertySheet>
            <property>
              <propertyName>parameters</propertyName>
              <propertySheet>
                <property>
                  <propertyName>n</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
                <property>
                  <propertyName>transition</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
                <property>
                  <propertyName>units</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>options</propertyName>
                      <propertySheet>
                        <property>
                          <propertyName>list</propertyName>
                          <expandable>1</expandable>
                          <value>minutes|hours|days</value>
                        </property>
                        <property>
                          <propertyName>type</propertyName>
                          <expandable>1</expandable>
                          <value>simpleList</value>
                        </property>
                      </propertySheet>
                    </property>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
                <property>
                  <propertyName>when</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
              </propertySheet>
            </property>
          </propertySheet>
        </property>
      </propertySheet>
      <formalParameter>
        <formalParameterName>transition</formalParameterName>
        <defaultValue></defaultValue>
        <description>Enter the name of the transition that should be taken when the time expires.  This transition must a transition out of the current state in the current workflow.</description>
        <expansionDeferred>0</expansionDeferred>
        <required>1</required>
        <type>entry</type>
      </formalParameter>
      <formalParameter>
        <formalParameterName>when</formalParameterName>
        <defaultValue></defaultValue>
        <description>Date/Time at which the transition should occur.</description>
        <expansionDeferred>0</expansionDeferred>
        <required>1</required>
        <type>entry</type>
      </formalParameter>
      <step>
        <stepName>Mark Transition</stepName>
        <alwaysRun>0</alwaysRun>
        <broadcast>0</broadcast>
        <command>#!ec-perl&#10;use strict;&#10;use ElectricCommander;&#10;&#10;# Establish our connection to Commander&#10;my $ec = ElectricCommander-&gt;new();&#10;&#10;# Load in the Date::Manip library which we have tucked away in a property&#10;my $lib = $ec-&gt;getProperty("/myProject/Manip.pm")-&gt;findvalue("//value")-&gt;value();&#10;eval($lib) or die("Error loading Date::Manip.pm library from property: $@\n");&#10;&#10;# Input parameters (expanded in-line by Commander for us)&#10;my $transition = '$[transition]';&#10;my $when = '$[when]';&#10;my $tz = '$[/myProject/tz]';&#10;&#10;# Define the local timezone from the property in this project&#10;Date::Manip::Date_Init('TodayIsMidnight=1', 'TZ=' . $tz);&#10;&#10;# Parse the "vague" human-type date string&#10;my $d = Date::Manip::ParseDate($when);&#10;&#10;# Convert to UTC&#10;$d = Date::Manip::Date_ConvTZ($d, '', 'UTC' );&#10;&#10;# And finally create the Commander-style time/date string&#10;my $timeThen = Date::Manip::UnixDate($d, '%Y-%m-%dT%H:%M:%S.000Z');&#10;&#10;# Compute the path to the transition in question&#10;my $tpath = '/myState/transitions/' . $transition;&#10;&#10;# Set the correct property (and clean up old ones, just in case)&#10;$ec-&gt;setProperty($tpath . '/wftTransitionTime', $timeThen);&#10;$ec-&gt;abortOnError(0);&#10;$ec-&gt;deleteProperty($tpath . '/wftTransitioned');&#10;$ec-&gt;abortOnError(1);&#10;&#10;# Done.&#10;</command>
        <condition></condition>
        <description></description>
        <errorHandling>abortProcedure</errorHandling>
        <exclusiveMode>none</exclusiveMode>
        <logFileName></logFileName>
        <parallel>0</parallel>
        <postProcessor></postProcessor>
        <releaseMode>none</releaseMode>
        <resourceName></resourceName>
        <shell>ec-perl</shell>
        <timeLimit></timeLimit>
        <timeLimitUnits>minutes</timeLimitUnits>
        <workingDirectory></workingDirectory>
        <workspaceName></workspaceName>
        <propertySheet>
          <property>
            <propertyName>ec_customEditorData</propertyName>
            <propertySheet>
              <property>
                <propertyName>formType</propertyName>
                <expandable>1</expandable>
                <value>command</value>
              </property>
            </propertySheet>
          </property>
        </propertySheet>
      </step>
    </procedure>
    <procedure>
      <procedureName>TransitionIn</procedureName>
      <description>Library sub-procedure used to mark a transition to transition in a specified time from now.</description>
      <jobNameTemplate></jobNameTemplate>
      <resourceName></resourceName>
      <workspaceName></workspaceName>
      <propertySheet>
        <property>
          <propertyName>ec_customEditorData</propertyName>
          <propertySheet>
            <property>
              <propertyName>parameters</propertyName>
              <propertySheet>
                <property>
                  <propertyName>n</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
                <property>
                  <propertyName>transition</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
                <property>
                  <propertyName>units</propertyName>
                  <propertySheet>
                    <property>
                      <propertyName>options</propertyName>
                      <propertySheet>
                        <property>
                          <propertyName>list</propertyName>
                          <expandable>1</expandable>
                          <value>minutes|hours|days</value>
                        </property>
                        <property>
                          <propertyName>type</propertyName>
                          <expandable>1</expandable>
                          <value>simpleList</value>
                        </property>
                      </propertySheet>
                    </property>
                    <property>
                      <propertyName>formType</propertyName>
                      <expandable>1</expandable>
                      <value>standard</value>
                    </property>
                  </propertySheet>
                </property>
              </propertySheet>
            </property>
          </propertySheet>
        </property>
      </propertySheet>
      <formalParameter>
        <formalParameterName>n</formalParameterName>
        <defaultValue></defaultValue>
        <description>Number of seconds, minutes, hours, or days in the future when the transition should occur</description>
        <expansionDeferred>0</expansionDeferred>
        <required>1</required>
        <type>entry</type>
      </formalParameter>
      <formalParameter>
        <formalParameterName>transition</formalParameterName>
        <defaultValue></defaultValue>
        <description>Enter the name of the transition that should be taken when the time expires.  This transition must a transition out of the current state in the current workflow.</description>
        <expansionDeferred>0</expansionDeferred>
        <required>1</required>
        <type>entry</type>
      </formalParameter>
      <formalParameter>
        <formalParameterName>units</formalParameterName>
        <defaultValue>minutes</defaultValue>
        <description>Select the desired units - minutes, hours, or days</description>
        <expansionDeferred>0</expansionDeferred>
        <required>1</required>
        <type>select</type>
      </formalParameter>
      <step>
        <stepName>Mark Transition</stepName>
        <alwaysRun>0</alwaysRun>
        <broadcast>0</broadcast>
        <command>#!ec-perl&#10;use ElectricCommander;&#10;use strict;&#10;&#10;# Define parameters (expanded in-line by Commander for us)&#10;my $n = '$[n]';&#10;my $units = '$[units]';&#10;my $transition = '$[transition]';&#10;&#10;# Calculate the real value for n in seconds&#10;if ($units eq 'days') {&#10;    $n = $n * 60 * 60 * 24;&#10;} elsif ($units eq 'hours') {&#10;    $n = $n * 60 * 60;&#10;} else {&#10;    $n = $n * 60;&#10;}&#10;&#10;# Get the time value for the specified time in the future&#10;my $then = time() + $n;&#10;&#10;# Convert to the correctly-formatted time string, in UTC&#10;my ($sec,$min,$hour,$mday,$mon,$year,$wday, $yday) = gmtime($then);&#10;my $timeThen = sprintf("%04d-%02d-%02dT%02d:%02d:%02d.000Z",&#10;		       $year + 1900, $mon + 1, $mday, $hour, $min, $sec);&#10;&#10;# Compute the path to the transition in question&#10;my $tpath = '/myState/transitions/' . $transition;&#10;&#10;# Set the correct property (and clean up old ones, just in case)&#10;my $ec = ElectricCommander-&gt;new();&#10;$ec-&gt;setProperty($tpath . '/wftTransitionTime', $timeThen);&#10;$ec-&gt;abortOnError(0);&#10;$ec-&gt;deleteProperty($tpath . '/wftTransitioned');&#10;$ec-&gt;abortOnError(1);&#10;&#10;# Done.&#10;</command>
        <condition></condition>
        <description></description>
        <errorHandling>abortProcedure</errorHandling>
        <exclusiveMode>none</exclusiveMode>
        <logFileName></logFileName>
        <parallel>0</parallel>
        <postProcessor></postProcessor>
        <releaseMode>none</releaseMode>
        <resourceName></resourceName>
        <shell>ec-perl</shell>
        <timeLimit></timeLimit>
        <timeLimitUnits>minutes</timeLimitUnits>
        <workingDirectory></workingDirectory>
        <workspaceName></workspaceName>
        <propertySheet>
          <property>
            <propertyName>ec_customEditorData</propertyName>
            <propertySheet>
              <property>
                <propertyName>formType</propertyName>
                <expandable>1</expandable>
                <value>command</value>
              </property>
            </propertySheet>
          </property>
        </propertySheet>
      </step>
    </procedure>
    <schedule>
      <scheduleName>workflowTick</scheduleName>
      <beginDate></beginDate>
      <description>The schedule that periodically runs the workflow timer tick procedure</description>
      <endDate></endDate>
      <interval>3</interval>
      <intervalUnits>minutes</intervalUnits>
      <misfirePolicy>ignore</misfirePolicy>
      <monthDays></monthDays>
      <priority>normal</priority>
      <procedureName>tick</procedureName>
      <scheduleDisabled>0</scheduleDisabled>
      <startTime>05:00</startTime>
      <stopTime>23:00</stopTime>
      <timeZone>America/Chicago</timeZone>
      <weekDays></weekDays>
      <propertySheet>
        <property>
          <propertyName>ec_customEditorData</propertyName>
          <propertySheet>
            <property>
              <propertyName>formType</propertyName>
              <expandable>1</expandable>
              <value>standard</value>
            </property>
          </propertySheet>
        </property>
      </propertySheet>
    </schedule>
    <workflowDefinition>
      <workflowDefinitionName>Test-inTheFuture</workflowDefinitionName>
      <description>Runs a workflow that waits until some time in the future, specified at start time</description>
      <workflowNameTemplate></workflowNameTemplate>
      <propertySheet>
      </propertySheet>
      <stateDefinition>
        <stateDefinitionName>Begin</stateDefinitionName>
        <description>A fine place to start</description>
        <startable>1</startable>
        <subprocedure>TransitionAt</subprocedure>
        <subproject></subproject>
        <substartingState></substartingState>
        <subworkflowDefinition></subworkflowDefinition>
        <actualParameters>
          <property>
            <propertyName>transition</propertyName>
            <expandable>1</expandable>
            <value>time expired</value>
          </property>
          <property>
            <propertyName>when</propertyName>
            <expandable>1</expandable>
            <value>$[waitUntil]</value>
          </property>
        </actualParameters>
        <propertySheet>
          <property>
            <propertyName>ec_customEditorData</propertyName>
            <propertySheet>
              <property>
                <propertyName>parameters</propertyName>
                <propertySheet>
                  <property>
                    <propertyName>waitUntil</propertyName>
                    <propertySheet>
                      <property>
                        <propertyName>formType</propertyName>
                        <expandable>1</expandable>
                        <value>standard</value>
                      </property>
                    </propertySheet>
                  </property>
                </propertySheet>
              </property>
            </propertySheet>
          </property>
        </propertySheet>
        <formalParameter>
          <formalParameterName>waitUntil</formalParameterName>
          <defaultValue></defaultValue>
          <description>Enter the human-readable date/time at which this workflow should automatically transition to the completed state.</description>
          <expansionDeferred>0</expansionDeferred>
          <required>1</required>
          <type>entry</type>
        </formalParameter>
        <transitionDefinition>
          <transitionDefinitionName>time expired</transitionDefinitionName>
          <condition></condition>
          <description>This transition is taken when the pre-determined time has expired.</description>
          <trigger>manual</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>End</targetState>
        </transitionDefinition>
      </stateDefinition>
      <stateDefinition>
        <stateDefinitionName>End</stateDefinitionName>
        <description>All good things come to an end</description>
        <startable>0</startable>
        <propertySheet>
        </propertySheet>
      </stateDefinition>
    </workflowDefinition>
    <workflowDefinition>
      <workflowDefinitionName>Test-loopForever</workflowDefinitionName>
      <description>A test workflow that just hangs around for ever.</description>
      <workflowNameTemplate></workflowNameTemplate>
      <propertySheet>
      </propertySheet>
      <stateDefinition>
        <stateDefinitionName>InTheBeginning</stateDefinitionName>
        <description>Everything has to start somewhere</description>
        <startable>1</startable>
        <propertySheet>
        </propertySheet>
        <transitionDefinition>
          <transitionDefinitionName>specification delivered</transitionDefinitionName>
          <condition></condition>
          <description></description>
          <trigger>onEnter</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>Coding</targetState>
        </transitionDefinition>
      </stateDefinition>
      <stateDefinition>
        <stateDefinitionName>Coding</stateDefinitionName>
        <description></description>
        <startable>0</startable>
        <subprocedure>TransitionIn</subprocedure>
        <subproject></subproject>
        <substartingState></substartingState>
        <subworkflowDefinition></subworkflowDefinition>
        <actualParameters>
          <property>
            <propertyName>n</propertyName>
            <expandable>1</expandable>
            <value>25</value>
          </property>
          <property>
            <propertyName>transition</propertyName>
            <expandable>1</expandable>
            <value>complete</value>
          </property>
          <property>
            <propertyName>units</propertyName>
            <expandable>1</expandable>
            <value>minutes</value>
          </property>
        </actualParameters>
        <propertySheet>
        </propertySheet>
        <transitionDefinition>
          <transitionDefinitionName>complete</transitionDefinitionName>
          <condition></condition>
          <description></description>
          <trigger>manual</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>Testing</targetState>
        </transitionDefinition>
        <transitionDefinition>
          <transitionDefinitionName>cancel project</transitionDefinitionName>
          <condition></condition>
          <description></description>
          <trigger>manual</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>Done</targetState>
        </transitionDefinition>
      </stateDefinition>
      <stateDefinition>
        <stateDefinitionName>Testing</stateDefinitionName>
        <description></description>
        <startable>0</startable>
        <subprocedure>TransitionIn</subprocedure>
        <subproject></subproject>
        <substartingState></substartingState>
        <subworkflowDefinition></subworkflowDefinition>
        <actualParameters>
          <property>
            <propertyName>n</propertyName>
            <expandable>1</expandable>
            <value>20</value>
          </property>
          <property>
            <propertyName>transition</propertyName>
            <expandable>1</expandable>
            <value>failed</value>
          </property>
          <property>
            <propertyName>units</propertyName>
            <expandable>1</expandable>
            <value>minutes</value>
          </property>
        </actualParameters>
        <propertySheet>
        </propertySheet>
        <transitionDefinition>
          <transitionDefinitionName>failed</transitionDefinitionName>
          <condition></condition>
          <description></description>
          <trigger>manual</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>Coding</targetState>
        </transitionDefinition>
        <transitionDefinition>
          <transitionDefinitionName>complete project</transitionDefinitionName>
          <condition></condition>
          <description></description>
          <trigger>manual</trigger>
          <propertySheet>
          </propertySheet>
          <targetState>Done</targetState>
        </transitionDefinition>
      </stateDefinition>
      <stateDefinition>
        <stateDefinitionName>Done</stateDefinitionName>
        <description></description>
        <startable>0</startable>
        <propertySheet>
        </propertySheet>
      </stateDefinition>
    </workflowDefinition>
  </project>
</exportedData>
